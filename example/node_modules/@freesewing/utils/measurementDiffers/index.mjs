// The completes the list of measurements with the ones
// we can calculate based on what we already have
function complete(m) {
  // Added by plugin-bust:
  m.bust = m.chest; // Added by plugin-measurements:

  m.crossSeamBack = m.crossSeam - m.crossSeamFront;
  m.seatBackArc = m.seatBack / 2;
  m.waistBackArc = m.waistBack / 2;
  if (m.bust && m.bustFront) m.bustBack = m.bust - m.bustFront;
  m.seatFront = m.seat - m.seatBack;
  m.seatFrontArc = m.seatFront / 2;
  m.waistFront = m.waist - m.waistBack;
  m.waistFrontArc = m.waistFront / 2;
  if (m.hightBust && m.highBustFront) m.highBustBack = m.highBust - m.highBustFront;
  return m;
}

/*
 * These are a set of measurements of an average-sized woman.
 * We simply extrapolate for other sizes (based on neck)
 * by keeping the same proportions.
 * That is almost certainly not the best sizing table you can get,
 * but we are not in the business of standard sizes, so this will do.
 */

var withBreasts = complete({
  ankle: 245,
  biceps: 270,
  bustFront: 480,
  bustSpan: 160,
  chest: 925,
  crossSeam: 740,
  crossSeamFront: 370,
  crotchDepth: 270,
  heel: 315,
  head: 565,
  highBust: 865,
  highBustFront: 440,
  hips: 900,
  hpsToBust: 275,
  hpsToWaistBack: 395,
  hpsToWaistFront: 400,
  inseam: 765,
  knee: 380,
  neck: 340,
  seat: 1010,
  seatBack: 520,
  shoulderSlope: 13,
  shoulderToElbow: 340,
  shoulderToShoulder: 415,
  shoulderToWrist: 590,
  underbust: 780,
  upperLeg: 570,
  waist: 750,
  waistBack: 380,
  waistToFloor: 1050,
  waistToHips: 125,
  waistToKnee: 600,
  waistToSeat: 250,
  waistToUnderbust: 80,
  waistToUpperLeg: 285,
  wrist: 165
});

/*
 * These are a set of measurements of an average-sized man.
 * We simply extrapolate for other sizes (based on neck)
 * by keeping the same proportions.
 * That is almost certainly not the best sizing table you can get,
 * but we are not in the business of standard sizes, so this will do.
 */

var withoutBreasts = complete({
  ankle: 235,
  biceps: 350,
  chest: 1000,
  crossSeam: 870,
  crossSeamFront: 410,
  crotchDepth: 340,
  heel: 360,
  head: 590,
  hips: 840,
  hpsToBust: 280,
  hpsToWaistBack: 470,
  inseam: 780,
  knee: 410,
  neck: 380,
  seat: 1020,
  seatBack: 560,
  shoulderSlope: 13,
  shoulderToElbow: 360,
  shoulderToShoulder: 450,
  shoulderToWrist: 630,
  upperLeg: 625,
  waist: 810,
  waistBack: 410,
  waistToFloor: 1160,
  waistToHips: 130,
  waistToKnee: 640,
  waistToSeat: 270,
  waistToUpperLeg: 340,
  wrist: 175
});

/*
 * Since linear measurements don't scale the same as circumference
 * measurements, we apply a correction ratio.
 */
let a = 0.5; // arc

let c = 1; // circumference

let v = 0.65; // vertical

var ratio = {
  // Arc measurements
  bustFront: a,
  bustSpan: a,
  highBustFront: a,
  // Circumference measurements
  ankle: c,
  biceps: c,
  chest: c,
  highBust: c,
  hips: c,
  neck: c,
  underbust: c,
  // Vertical measurements
  crotchDepth: v,
  hpsToBust: v,
  hpsToWaistBack: v,
  hpsToWaistFront: v,
  waistToHips: v,
  waistToKnee: v,
  waistToSeat: v,
  waistToUnderbust: v,
  waistToUpperLeg: v,
  // Other
  seatBack: 0.6,
  waistBack: 0.85,
  crossSeam: 0.6,
  crossSeamFront: 0.3,
  head: 0.35,
  heel: 0.25,
  inseam: 0.25,
  knee: 0.65,
  seat: 0.6,
  shoulderToElbow: 0.5,
  shoulderToShoulder: 0.65,
  shoulderToWrist: 0.3,
  upperLeg: 0.45,
  waist: 0.85,
  waistToFloor: 0.4,
  wrist: 0.5
};

const neckstimate = (neck = false, measurement = false, breasts = false, noRound = false) => {
  let data = breasts ? withBreasts : withoutBreasts; // Shoulder slope is in degrees now. Always return de default.

  if (measurement === 'shoulderSlope') return withBreasts.shoulderSlope;
  if (!neck) throw new Error('neckstimate() requires a neck measurement in mm as first parameter');

  if (!measurement) {
    // No measurement passed
    throw new Error('new neckstimate() requires a valid measurement name as second parameter. (received ' + JSON.stringify(measurement) + ')');
  }

  if (typeof data[measurement] === 'undefined') {
    if (typeof withBreasts[measurement] === 'undefined') {
      // We used to throw this error, but let's just return null instead so things don't go off the rails
      console.log(new Error(`neckstimate() called with an invalid measurement name (${measurement})`));
      return null;
    } else {
      console.log(`WARNING: neckstimate() called for a breasts-only measurement (${measurement}) on a no-breasts person`); // Return something anyway, rather than fall over

      data = withBreasts;
    }
  } // This is what should happen


  let delta = neck / data.neck * data[measurement] - data[measurement];
  return noRound ? data[measurement] + delta * ratio[measurement] : Math.round(data[measurement] + delta * ratio[measurement]);
};

//   0 and 2 is great
//   2 to 5 is hmmm
//   and above 5 is probably wrong

const measurementDiffers = (neckCircumference, measurementName, measurementValue, breasts = false, absolute = true) => {
  Math.round((measurementValue - neckstimate(neckCircumference, measurementName, breasts)) / 20);
  return absolute ? Math.abs(Math.round((measurementValue - neckstimate(neckCircumference, measurementName, breasts)) / 20)) : (measurementValue - neckstimate(neckCircumference, measurementName, breasts, true)) / 20;
};

export default measurementDiffers;
//# sourceMappingURL=index.mjs.map
