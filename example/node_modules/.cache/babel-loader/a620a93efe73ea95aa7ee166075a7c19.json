{"ast":null,"code":"import _objectSpread from \"F:/Documents/Freesewing Patterns/18shift/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"F:/Documents/Freesewing Patterns/18shift/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"F:/Documents/Freesewing Patterns/18shift/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"F:/Documents/Freesewing Patterns/18shift/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"F:/Documents/Freesewing Patterns/18shift/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:/Documents/Freesewing Patterns/18shift/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @freesewing/core | v2.17.0\n * A library for creating made-to-measure sewing patterns\n * (c) 2021 Joost De Cock <joost@joost.at> (https://github.com/joostdecock)\n * @license MIT\n */\nfunction Attributes() {\n  this.list = {};\n}\n/** Adds an attribute */\n\n\nAttributes.prototype.add = function (name, value) {\n  if (typeof this.list[name] === 'undefined') {\n    this.list[name] = [];\n  }\n\n  this.list[name].push(value);\n  return this;\n};\n/** Sets an attribute, overwriting existing value */\n\n\nAttributes.prototype.set = function (name, value) {\n  this.list[name] = [value];\n  return this;\n};\n/** Removes an attribute */\n\n\nAttributes.prototype.remove = function (name) {\n  delete this.list[name];\n  return this;\n};\n/** Retrieves an attribute */\n\n\nAttributes.prototype.get = function (name) {\n  if (typeof this.list[name] === 'undefined') return false;else return this.list[name].join(' ');\n};\n/** Retrieves an attribute as array*/\n\n\nAttributes.prototype.getAsArray = function (name) {\n  if (typeof this.list[name] === 'undefined') return false;else return this.list[name];\n};\n/** Returns SVG code for attributes */\n\n\nAttributes.prototype.render = function () {\n  var svg = '';\n\n  for (var key in this.list) {\n    svg += \" \".concat(key, \"=\\\"\").concat(this.list[key].join(' '), \"\\\"\");\n  }\n\n  return svg;\n};\n/** Returns CSS code for attributes */\n\n\nAttributes.prototype.renderAsCss = function () {\n  var css = '';\n\n  for (var key in this.list) {\n    css += \" \".concat(key, \":\").concat(this.list[key].join(' '), \";\");\n  }\n\n  return css;\n};\n/** Returns SVG code for attributes with a fiven prefix\n * typically used for data-text*/\n\n\nAttributes.prototype.renderIfPrefixIs = function () {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var svg = '';\n  var prefixLen = prefix.length;\n\n  for (var key in this.list) {\n    if (key.substr(0, prefixLen) === prefix) {\n      svg += \" \".concat(key.substr(prefixLen), \"=\\\"\").concat(this.list[key].join(' '), \"\\\"\");\n    }\n  }\n\n  return svg;\n};\n/** Returns a props object for attributes with a fiven prefix\n * typically used for data-text*/\n\n\nAttributes.prototype.asPropsIfPrefixIs = function () {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var props = {};\n  var prefixLen = prefix.length;\n\n  for (var key in this.list) {\n    if (key.substr(0, prefixLen) === prefix) {\n      var propKey = key.substr(prefixLen);\n      if (propKey === 'class') propKey = 'className';\n      props[propKey] = this.get(key);\n    }\n  }\n\n  return props;\n};\n/** Returns a deep copy of this */\n\n\nAttributes.prototype.clone = function () {\n  var clone = new Attributes();\n  clone.list = JSON.parse(JSON.stringify(this.list));\n  return clone;\n};\n\nfunction Point(x, y) {\n  var debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  this.x = x;\n  this.y = y;\n  this.attributes = new Attributes();\n  Object.defineProperty(this, 'debug', {\n    value: debug,\n    configurable: true\n  });\n}\n/** Adds the raise method for a path not created through the proxy **/\n\n\nPoint.prototype.withRaise = function () {\n  var raise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  if (raise) Object.defineProperty(this, 'raise', {\n    value: raise\n  });\n  return this;\n};\n/** Debug method to validate point data **/\n\n\nPoint.prototype.check = function () {\n  if (typeof this.x !== 'number') this.raise.warning('X value of `Point` is not a number');\n  if (typeof this.y !== 'number') this.raise.warning('Y value of `Point` is not a number');\n};\n/** Radians to degrees */\n\n\nPoint.prototype.rad2deg = function (radians) {\n  return radians * 57.29577951308232;\n};\n/** Degrees to radians */\n\n\nPoint.prototype.deg2rad = function (degrees) {\n  return degrees / 57.29577951308232;\n};\n/** Adds an attribute. This is here to make this call chainable in assignment */\n\n\nPoint.prototype.attr = function (name, value) {\n  var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (this.debug) this.check();\n  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);\n  return this;\n};\n/** Returns the distance between this point and that point */\n\n\nPoint.prototype.dist = function (that) {\n  if (this.debug) {\n    this.check();\n    that.check();\n  }\n\n  var dx = this.x - that.x;\n  var dy = this.y - that.y;\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n/** Returns slope of a line made by this point and that point */\n\n\nPoint.prototype.slope = function (that) {\n  if (this.debug) {\n    this.check();\n    that.check();\n  }\n\n  return (that.y - this.y) / (that.x - this.x);\n};\n/** Returns the x-delta between this point and that point */\n\n\nPoint.prototype.dx = function (that) {\n  if (this.debug) {\n    this.check();\n    that.check();\n  }\n\n  return that.x - this.x;\n};\n/** Returns the y-delta between this point and that point */\n\n\nPoint.prototype.dy = function (that) {\n  if (this.debug) {\n    this.check();\n    that.check();\n  }\n\n  return that.y - this.y;\n};\n/** Returns the angle between this point and that point */\n\n\nPoint.prototype.angle = function (that) {\n  if (this.debug) {\n    this.check();\n    that.check();\n  }\n\n  var rad = Math.atan2(-1 * this.dy(that), this.dx(that));\n\n  while (rad < 0) {\n    rad += 2 * Math.PI;\n  }\n\n  return this.rad2deg(rad);\n};\n/** Rotate this point deg around that point */\n\n\nPoint.prototype.rotate = function (deg, that) {\n  if (this.debug) {\n    this.check();\n    that.check();\n    if (typeof deg !== 'number') this.raise.warning('Called `Point.rotate(deg,that)` but `deg` is not a number');\n    if (that instanceof Point !== true) this.raise.warning('Called `Point.rotate(deg,that)` but `that` is not a `Point` object');\n  }\n\n  var radius = this.dist(that);\n  var angle = this.angle(that);\n  var x = that.x + radius * Math.cos(this.deg2rad(angle + deg)) * -1;\n  var y = that.y + radius * Math.sin(this.deg2rad(angle + deg));\n  return new Point(x, y, this.debug).withRaise(this.raise);\n};\n/** returns an identical copy of this point */\n\n\nPoint.prototype.copy = function () {\n  if (this.debug) this.check();\n  return new Point(this.x, this.y, this.debug).withRaise(this.raise);\n};\n/** Mirrors this point around X value of that point */\n\n\nPoint.prototype.flipX = function () {\n  var that = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (this.debug) {\n    this.check();\n\n    if (that) {\n      if (that instanceof Point !== true) this.raise.warning('Called `Point.rotate(deg,that)` but `that` is not a `Point` object');\n      that.check();\n    }\n  }\n\n  if (that === false || that.x === 0) return new Point(this.x * -1, this.y, this.debug).withRaise(this.raise);else return new Point(that.x + this.dx(that), this.y, this.debug).withRaise(this.raise);\n};\n/** Mirrors this point around Y value of that point */\n\n\nPoint.prototype.flipY = function () {\n  var that = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (this.debug) {\n    this.check();\n\n    if (that) {\n      if (that instanceof Point !== true) this.raise.warning('Called `Point.flipY(that)` but `that` is not a `Point` object');\n      that.check();\n    }\n  }\n\n  if (that === false || that.y === 0) return new Point(this.x, this.y * -1, this.debug).withRaise(this.raise);else return new Point(this.x, that.y + this.dy(that), this.debug).withRaise(this.raise);\n};\n/** Shifts this point distance in the deg direction */\n\n\nPoint.prototype.shift = function (deg, distance) {\n  if (this.debug) {\n    this.check();\n    if (typeof distance !== 'number') this.raise.warning('Called `Point.shift` but `distance` is not a number');\n  }\n\n  var p = this.copy();\n  p.x += distance;\n  return p.rotate(deg, this);\n};\n/** Shifts this point distance in the direction of that point */\n\n\nPoint.prototype.shiftTowards = function (that, distance) {\n  if (this.debug) {\n    if (typeof distance !== 'number') this.raise.warning('Called `Point.shiftTowards` but `distance` is not a number');\n    if (that instanceof Point !== true) this.raise.warning('Called `Point.shiftTowards(that, distance)` but `that` is not a `Point` object');\n    this.check();\n    that.check();\n  }\n\n  if (this.debug) this.check();\n  return this.shift(this.angle(that), distance);\n};\n/** Checks whether this has the same coordinates as that */\n\n\nPoint.prototype.sitsOn = function (that) {\n  if (this.debug) {\n    if (that instanceof Point !== true) this.raise.warning('Called `Point.sitsOn(that)` but `that` is not a `Point` object');\n    this.check();\n    that.check();\n  }\n\n  if (this.x === that.x && this.y === that.y) return true;else return false;\n};\n/** Checks whether this has roughly the same coordinates as that */\n\n\nPoint.prototype.sitsRoughlyOn = function (that) {\n  if (this.debug) {\n    if (that instanceof Point !== true) this.raise.warning('Called `Point.sitsRoughlyOn(that)` but `that` is not a `Point` object');\n    this.check();\n    that.check();\n  }\n\n  if (Math.round(this.x) === Math.round(that.x) && Math.round(this.y) === Math.round(that.y)) return true;else return false;\n};\n/** Shifts this point fraction of the distance towards that point */\n\n\nPoint.prototype.shiftFractionTowards = function (that, fraction) {\n  if (this.debug) {\n    if (that instanceof Point !== true) this.raise.warning('Called `Point.shiftFractionTowards(that, fraction)` but `that` is not a `Point` object');\n    if (typeof fraction !== 'number') this.raise.warning('Called `Point.shiftFractionTowards` but `fraction` is not a number');\n    this.check();\n    that.check();\n  }\n\n  return this.shiftTowards(that, this.dist(that) * fraction);\n};\n/** Shifts this point distance beyond that point */\n\n\nPoint.prototype.shiftOutwards = function (that, distance) {\n  if (this.debug) {\n    if (that instanceof Point !== true) this.raise.warning('Called `Point.shiftOutwards(that, distance)` but `that` is not a `Point` object');\n    if (typeof distance !== 'number') this.raise.warning('Called `Point.shiftOutwards(that, distance)` but `distance` is not a number');\n    this.check();\n    that.check();\n  }\n\n  return this.shiftTowards(that, this.dist(that) + distance);\n};\n/** Returns a deep copy of this */\n\n\nPoint.prototype.clone = function () {\n  if (this.debug) this.check();\n  var clone = new Point(this.x, this.y, this.debug).withRaise(this.raise);\n  clone.attributes = this.attributes.clone();\n  return clone;\n};\n/** Applies a translate transform */\n\n\nPoint.prototype.translate = function (x, y) {\n  if (this.debug) {\n    this.check();\n    if (typeof x !== 'number') this.raise.warning('Called `Point.translate(x,y)` but `x` is not a number');\n    if (typeof y !== 'number') this.raise.warning('Called `Point.translate(x,y)` but `y` is not a number');\n  }\n\n  var p = this.copy();\n  p.x += x;\n  p.y += y;\n  return p;\n};\n\nvar abs$1 = Math.abs,\n    cos$1 = Math.cos,\n    sin$1 = Math.sin,\n    acos$1 = Math.acos,\n    atan2 = Math.atan2,\n    sqrt$1 = Math.sqrt,\n    pow = Math.pow; // cube root function yielding real roots\n\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n} // trig constants\n\n\nvar pi$1 = Math.PI,\n    tau = 2 * pi$1,\n    quart = pi$1 / 2,\n    // float precision significant decimal\nepsilon = 0.000001,\n    // extremas used in bbox calculation and similar algorithms\nnMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n    nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n    // a zero coordinate, which is surprisingly useful\nZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n}; // Bezier utility functions\n\nvar utils$1 = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],\n  arcfn: function arcfn(t, derivativeFn) {\n    var d = derivativeFn(t);\n    var l = d.x * d.x + d.y * d.y;\n\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n\n    return sqrt$1(l);\n  },\n  compute: function compute(t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    var order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    var mt = 1 - t;\n    var p = points; // constant?\n\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      var ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n\n      return ret;\n    } // quadratic/cubic curve?\n\n\n    if (order < 4) {\n      var mt2 = mt * mt,\n          t2 = t * t,\n          a,\n          b,\n          c,\n          d = 0;\n\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n\n      var _ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t\n      };\n\n      if (_3d) {\n        _ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n\n      return _ret;\n    } // higher order curves: use de Casteljau's computation\n\n\n    var dCpts = JSON.parse(JSON.stringify(points));\n\n    while (dCpts.length > 1) {\n      for (var i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n  computeWithRatios: function computeWithRatios(t, points, ratios, _3d) {\n    var mt = 1 - t,\n        r = ratios,\n        p = points;\n    var f1 = r[0],\n        f2 = r[1],\n        f3 = r[2],\n        f4 = r[3],\n        d; // spec for linear\n\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t\n      };\n    } // upgrade to quadratic\n\n\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t\n      };\n    } // upgrade to cubic\n\n\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t\n      };\n    }\n  },\n  derive: function derive(points, _3d) {\n    var dpoints = [];\n\n    for (var p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      var list = [];\n\n      for (var j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n\n        list.push(dpt);\n      }\n\n      dpoints.push(list);\n      p = list;\n    }\n\n    return dpoints;\n  },\n  between: function between(v, m, M) {\n    return m <= v && v <= M || utils$1.approximately(v, m) || utils$1.approximately(v, M);\n  },\n  approximately: function approximately(a, b, precision) {\n    return abs$1(a - b) <= (precision || epsilon);\n  },\n  length: function length(derivativeFn) {\n    var z = 0.5,\n        len = utils$1.Tvalues.length;\n    var sum = 0;\n\n    for (var i = 0, _t; i < len; i++) {\n      _t = z * utils$1.Tvalues[i] + z;\n      sum += utils$1.Cvalues[i] * utils$1.arcfn(_t, derivativeFn);\n    }\n\n    return z * sum;\n  },\n  map: function map(v, ds, de, ts, te) {\n    var d1 = de - ds,\n        d2 = te - ts,\n        v2 = v - ds,\n        r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function lerp(r, v1, v2) {\n    var ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n\n    return ret;\n  },\n  pointToString: function pointToString(p) {\n    var s = p.x + \"/\" + p.y;\n\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n\n    return s;\n  },\n  pointsToString: function pointsToString(points) {\n    return \"[\" + points.map(utils$1.pointToString).join(\", \") + \"]\";\n  },\n  copy: function copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function angle(o, v1, v2) {\n    var dx1 = v1.x - o.x,\n        dy1 = v1.y - o.y,\n        dx2 = v2.x - o.x,\n        dy2 = v2.y - o.y,\n        cross = dx1 * dy2 - dy1 * dx2,\n        dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  // round as string, to avoid rounding errors\n  round: function round(v, d) {\n    var s = \"\" + v;\n    var pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function dist(p1, p2) {\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n    return sqrt$1(dx * dx + dy * dy);\n  },\n  closest: function closest(LUT, point) {\n    var mdist = pow(2, 63),\n        mpos,\n        d;\n    LUT.forEach(function (p, idx) {\n      d = utils$1.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return {\n      mdist: mdist,\n      mpos: mpos\n    };\n  },\n  abcratio: function abcratio(t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    var bottom = pow(t, n) + pow(1 - t, n),\n        top = bottom - 1;\n    return abs$1(top / bottom);\n  },\n  projectionratio: function projectionratio(t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    var top = pow(1 - t, n),\n        bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n  lli8: function lli8(x1, y1, x2, y2, x3, y3, x4, y4) {\n    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n    if (d == 0) {\n      return false;\n    }\n\n    return {\n      x: nx / d,\n      y: ny / d\n    };\n  },\n  lli4: function lli4(p1, p2, p3, p4) {\n    var x1 = p1.x,\n        y1 = p1.y,\n        x2 = p2.x,\n        y2 = p2.y,\n        x3 = p3.x,\n        y3 = p3.y,\n        x4 = p4.x,\n        y4 = p4.y;\n    return utils$1.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function lli(v1, v2) {\n    return utils$1.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function makeline(p1, p2) {\n    var x1 = p1.x,\n        y1 = p1.y,\n        x2 = p2.x,\n        y2 = p2.y,\n        dx = (x2 - x1) / 3,\n        dy = (y2 - y1) / 3;\n    return new Bezier(x1, y1, x1 + dx, y1 + dy, x1 + 2 * dx, y1 + 2 * dy, x2, y2);\n  },\n  findbbox: function findbbox(sections) {\n    var mx = nMax,\n        my = nMax,\n        MX = nMin,\n        MY = nMin;\n    sections.forEach(function (s) {\n      var bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: {\n        min: mx,\n        mid: (mx + MX) / 2,\n        max: MX,\n        size: MX - mx\n      },\n      y: {\n        min: my,\n        mid: (my + MY) / 2,\n        max: MY,\n        size: MY - my\n      }\n    };\n  },\n  shapeintersections: function shapeintersections(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils$1.bboxoverlap(bbox1, bbox2)) return [];\n    var intersections = [];\n    var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        var iss = l1.intersects(l2, curveIntersectionThreshold);\n\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function makeshape(forward, back, curveIntersectionThreshold) {\n    var bpl = back.points.length;\n    var fpl = forward.points.length;\n    var start = utils$1.makeline(back.points[bpl - 1], forward.points[0]);\n    var end = utils$1.makeline(forward.points[fpl - 1], back.points[0]);\n    var shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils$1.findbbox([start, forward, back, end])\n    };\n\n    shape.intersections = function (s2) {\n      return utils$1.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n\n    return shape;\n  },\n  getminmax: function getminmax(curve, d, list) {\n    if (!list) return {\n      min: 0,\n      max: 0\n    };\n    var min = nMax,\n        max = nMin,\n        t,\n        c;\n\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n\n    for (var i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n\n      if (c[d] < min) {\n        min = c[d];\n      }\n\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n\n    return {\n      min: min,\n      mid: (min + max) / 2,\n      max: max,\n      size: max - min\n    };\n  },\n  align: function align(points, line) {\n    var tx = line.p1.x,\n        ty = line.p1.y,\n        a = -atan2(line.p2.y - ty, line.p2.x - tx),\n        d = function d(v) {\n      return {\n        x: (v.x - tx) * cos$1(a) - (v.y - ty) * sin$1(a),\n        y: (v.x - tx) * sin$1(a) + (v.y - ty) * cos$1(a)\n      };\n    };\n\n    return points.map(d);\n  },\n  roots: function roots(points, line) {\n    line = line || {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 1,\n        y: 0\n      }\n    };\n    var order = points.length - 1;\n    var aligned = utils$1.align(points, line);\n\n    var reduce = function reduce(t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      var _a = aligned[0].y,\n          _b = aligned[1].y,\n          _c = aligned[2].y,\n          _d = _a - 2 * _b + _c;\n\n      if (_d !== 0) {\n        var m1 = -sqrt$1(_b * _b - _a * _c),\n            m2 = -_a + _b,\n            _v = -(m1 + m2) / _d,\n            v2 = -(-m1 + m2) / _d;\n\n        return [_v, v2].filter(reduce);\n      } else if (_b !== _c && _d === 0) {\n        return [(2 * _b - _c) / (2 * _b - 2 * _c)].filter(reduce);\n      }\n\n      return [];\n    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n\n\n    var pa = aligned[0].y,\n        pb = aligned[1].y,\n        pc = aligned[2].y,\n        pd = aligned[3].y;\n    var d = -pa + 3 * pb - 3 * pc + pd,\n        a = 3 * pa - 6 * pb + 3 * pc,\n        b = -3 * pa + 3 * pb,\n        c = pa;\n\n    if (utils$1.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils$1.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils$1.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        } // linear solution:\n\n\n        return [-c / b].filter(reduce);\n      } // quadratic solution:\n\n\n      var _q = sqrt$1(b * b - 4 * a * c),\n          a2 = 2 * a;\n\n      return [(_q - b) / a2, (-b - _q) / a2].filter(reduce);\n    } // at this point, we know we need a cubic solution:\n\n\n    a /= d;\n    b /= d;\n    c /= d;\n    var p = (3 * b - a * a) / 3,\n        p3 = p / 3,\n        q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n        q2 = q / 2,\n        discriminant = q2 * q2 + p3 * p3 * p3;\n    var u1, v1, x1, x2, x3;\n\n    if (discriminant < 0) {\n      var mp3 = -p / 3,\n          mp33 = mp3 * mp3 * mp3,\n          r = sqrt$1(mp33),\n          _t2 = -q / (2 * r),\n          cosphi = _t2 < -1 ? -1 : _t2 > 1 ? 1 : _t2,\n          phi = acos$1(cosphi),\n          crtr = crt(r),\n          t1 = 2 * crtr;\n\n      x1 = t1 * cos$1(phi / 3) - a / 3;\n      x2 = t1 * cos$1((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos$1((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      var sd = sqrt$1(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function droots(p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      var a = p[0],\n          b = p[1],\n          c = p[2],\n          d = a - 2 * b + c;\n\n      if (d !== 0) {\n        var m1 = -sqrt$1(b * b - a * c),\n            m2 = -a + b,\n            v1 = -(m1 + m2) / d,\n            v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n\n      return [];\n    } // linear roots are even easier\n\n\n    if (p.length === 2) {\n      var _a2 = p[0],\n          _b2 = p[1];\n\n      if (_a2 !== _b2) {\n        return [_a2 / (_a2 - _b2)];\n      }\n\n      return [];\n    }\n\n    return [];\n  },\n  curvature: function curvature(t, d1, d2, _3d, kOnly) {\n    var num,\n        dnm,\n        adk,\n        dk,\n        k = 0,\n        r = 0; //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    var d = utils$1.compute(t, d1);\n    var dd = utils$1.compute(t, d2);\n    var qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt$1(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return {\n        k: 0,\n        r: 0\n      };\n    }\n\n    k = num / dnm;\n    r = dnm / num; // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      var pk = utils$1.curvature(t - 0.001, d1, d2, _3d, true).k;\n      var nk = utils$1.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;\n    }\n\n    return {\n      k: k,\n      r: r,\n      dk: dk,\n      adk: adk\n    };\n  },\n  inflections: function inflections(points) {\n    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    var p = utils$1.align(points, {\n      p1: points[0],\n      p2: points.slice(-1)[0]\n    }),\n        a = p[2].x * p[1].y,\n        b = p[3].x * p[1].y,\n        c = p[1].x * p[2].y,\n        d = p[3].x * p[2].y,\n        v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n        v2 = 18 * (3 * a - b - 3 * c),\n        v3 = 18 * (c - a);\n\n    if (utils$1.approximately(v1, 0)) {\n      if (!utils$1.approximately(v2, 0)) {\n        var _t3 = -v3 / v2;\n\n        if (0 <= _t3 && _t3 <= 1) return [_t3];\n      }\n\n      return [];\n    }\n\n    var trm = v2 * v2 - 4 * v1 * v3,\n        sq = Math.sqrt(trm),\n        d2 = 2 * v1;\n    if (utils$1.approximately(d2, 0)) return [];\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function bboxoverlap(b1, b2) {\n    var dims = [\"x\", \"y\"],\n        len = dims.length;\n\n    for (var i = 0, dim, l, _t4, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      _t4 = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs$1(l - _t4) >= d) return false;\n    }\n\n    return true;\n  },\n  expandbox: function expandbox(bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function pairiteration(c1, c2, curveIntersectionThreshold) {\n    var c1b = c1.bbox(),\n        c2b = c2.bbox(),\n        r = 100000,\n        threshold = curveIntersectionThreshold || 0.5;\n\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];\n    }\n\n    var cc1 = c1.split(0.5),\n        cc2 = c2.split(0.5),\n        pairs = [{\n      left: cc1.left,\n      right: cc2.left\n    }, {\n      left: cc1.left,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.left\n    }];\n    pairs = pairs.filter(function (pair) {\n      return utils$1.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    var results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(utils$1.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function getccenter(p1, p2, p3) {\n    var dx1 = p2.x - p1.x,\n        dy1 = p2.y - p1.y,\n        dx2 = p3.x - p2.x,\n        dy2 = p3.y - p2.y,\n        dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart),\n        dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart),\n        dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart),\n        dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart),\n        // chord midpoints\n    mx1 = (p1.x + p2.x) / 2,\n        my1 = (p1.y + p2.y) / 2,\n        mx2 = (p2.x + p3.x) / 2,\n        my2 = (p2.y + p3.y) / 2,\n        // midpoint offsets\n    mx1n = mx1 + dx1p,\n        my1n = my1 + dy1p,\n        mx2n = mx2 + dx2p,\n        my2n = my2 + dy2p,\n        // intersection of these lines:\n    arc = utils$1.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n        r = utils$1.dist(arc, p1); // arc start/end values, over mid point:\n\n    var s = atan2(p1.y - arc.y, p1.x - arc.x),\n        m = atan2(p2.y - arc.y, p2.x - arc.x),\n        e = atan2(p3.y - arc.y, p3.x - arc.x),\n        _; // determine arc direction (cw/ccw correction)\n\n\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    } // assign and done.\n\n\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function numberSort(a, b) {\n    return a - b;\n  }\n};\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\n\nvar PolyBezier = /*#__PURE__*/function () {\n  function PolyBezier(curves) {\n    _classCallCheck(this, PolyBezier);\n\n    this.curves = [];\n    this._3d = false;\n\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  _createClass(PolyBezier, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[\" + this.curves.map(function (curve) {\n        return utils$1.pointsToString(curve.points);\n      }).join(\", \") + \"]\";\n    }\n  }, {\n    key: \"addCurve\",\n    value: function addCurve(curve) {\n      this.curves.push(curve);\n      this._3d = this._3d || curve._3d;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.curves.map(function (v) {\n        return v.length();\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(idx) {\n      return this.curves[idx];\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var c = this.curves;\n      var bbox = c[0].bbox();\n\n      for (var i = 1; i < c.length; i++) {\n        utils$1.expandbox(bbox, c[i].bbox());\n      }\n\n      return bbox;\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(d) {\n      var offset = [];\n      this.curves.forEach(function (v) {\n        offset.push.apply(offset, _toConsumableArray(v.offset(d)));\n      });\n      return new PolyBezier(offset);\n    }\n  }]);\n\n  return PolyBezier;\n}();\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\n\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max,\n    cos = Math.cos,\n    sin = Math.sin,\n    acos = Math.acos,\n    sqrt = Math.sqrt;\nvar pi = Math.PI; // a zero coordinate, which is surprisingly useful\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(coords) {\n    _classCallCheck(this, Bezier);\n\n    var args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    var coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      var newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    var higher = false;\n    var len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    var _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    var points = this.points = [];\n\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    var order = this.order = points.length - 1;\n    var dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n    var aligned = utils$1.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    this._linear = !aligned.some(function (p) {\n      return abs(p.y) > 0.0001;\n    });\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  _createClass(Bezier, [{\n    key: \"getUtils\",\n    value: function getUtils() {\n      return Bezier.getUtils();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return utils$1.pointsToString(this.points);\n    }\n  }, {\n    key: \"toSVG\",\n    value: function toSVG() {\n      if (this._3d) return false;\n      var p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n      for (var i = 1, last = p.length; i < last; i++) {\n        s.push(p[i].x);\n        s.push(p[i].y);\n      }\n\n      return s.join(\" \");\n    }\n  }, {\n    key: \"setRatios\",\n    value: function setRatios(ratios) {\n      if (ratios.length !== this.points.length) {\n        throw new Error(\"incorrect number of ratio values\");\n      }\n\n      this.ratios = ratios;\n      this._lut = []; //  invalidate any precomputed LUT\n    }\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      var print = this.coordDigest();\n\n      if (print !== this._print) {\n        this._print = print;\n        this.update();\n      }\n    }\n  }, {\n    key: \"coordDigest\",\n    value: function coordDigest() {\n      return this.points.map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      }).join(\"\");\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // invalidate any precomputed LUT\n      this._lut = [];\n      this.dpoints = utils$1.derive(this.points, this._3d);\n      this.computedirection();\n    }\n  }, {\n    key: \"computedirection\",\n    value: function computedirection() {\n      var points = this.points;\n      var angle = utils$1.angle(points[0], points[this.order], points[1]);\n      this.clockwise = angle > 0;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return utils$1.length(this.derivative.bind(this));\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC(t, B) {\n      B = B || this.get(t);\n      var S = this.points[0];\n      var E = this.points[this.order];\n      return Bezier.getABC(this.order, S, B, E, t);\n    }\n  }, {\n    key: \"getLUT\",\n    value: function getLUT(steps) {\n      this.verify();\n      steps = steps || 100;\n\n      if (this._lut.length === steps) {\n        return this._lut;\n      }\n\n      this._lut = []; // We want a range from 0 to 1 inclusive, so\n      // we decrement and then use <= rather than <:\n\n      steps--;\n\n      for (var i = 0, p, _t5; i < steps; i++) {\n        _t5 = i / (steps - 1);\n        p = this.compute(_t5);\n        p.t = _t5;\n\n        this._lut.push(p);\n      }\n\n      return this._lut;\n    }\n  }, {\n    key: \"on\",\n    value: function on(point, error) {\n      error = error || 5;\n      var lut = this.getLUT(),\n          hits = [];\n\n      for (var i = 0, c, _t6 = 0; i < lut.length; i++) {\n        c = lut[i];\n\n        if (utils$1.dist(c, point) < error) {\n          hits.push(c);\n          _t6 += i / lut.length;\n        }\n      }\n\n      if (!hits.length) return false;\n      return t /= hits.length;\n    }\n  }, {\n    key: \"project\",\n    value: function project(point) {\n      // step 1: coarse check\n      var LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils$1.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n      var mdist = closest.mdist,\n          t = t1,\n          ft = t,\n          p;\n      mdist += 1;\n\n      for (var d; t < t2 + step; t += step) {\n        p = this.compute(t);\n        d = utils$1.dist(point, p);\n\n        if (d < mdist) {\n          mdist = d;\n          ft = t;\n        }\n      }\n\n      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n      p = this.compute(ft);\n      p.t = ft;\n      p.d = mdist;\n      return p;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.compute(t);\n    }\n  }, {\n    key: \"point\",\n    value: function point(idx) {\n      return this.points[idx];\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(t) {\n      if (this.ratios) {\n        return utils$1.computeWithRatios(t, this.points, this.ratios, this._3d);\n      }\n\n      return utils$1.compute(t, this.points, this._3d, this.ratios);\n    }\n  }, {\n    key: \"raise\",\n    value: function raise() {\n      var p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n      for (var i = 1, _pi, pim; i < k; i++) {\n        _pi = p[i];\n        pim = p[i - 1];\n        np[i] = {\n          x: (k - i) / k * _pi.x + i / k * pim.x,\n          y: (k - i) / k * _pi.y + i / k * pim.y\n        };\n      }\n\n      np[k] = p[k - 1];\n      return new Bezier(np);\n    }\n  }, {\n    key: \"derivative\",\n    value: function derivative(t) {\n      return utils$1.compute(t, this.dpoints[0], this._3d);\n    }\n  }, {\n    key: \"dderivative\",\n    value: function dderivative(t) {\n      return utils$1.compute(t, this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"align\",\n    value: function align() {\n      var p = this.points;\n      return new Bezier(utils$1.align(p, {\n        p1: p[0],\n        p2: p[p.length - 1]\n      }));\n    }\n  }, {\n    key: \"curvature\",\n    value: function curvature(t) {\n      return utils$1.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"inflections\",\n    value: function inflections() {\n      return utils$1.inflections(this.points);\n    }\n  }, {\n    key: \"normal\",\n    value: function normal(t) {\n      return this._3d ? this.__normal3(t) : this.__normal2(t);\n    }\n  }, {\n    key: \"__normal2\",\n    value: function __normal2(t) {\n      var d = this.derivative(t);\n      var q = sqrt(d.x * d.x + d.y * d.y);\n      return {\n        x: -d.y / q,\n        y: d.x / q\n      };\n    }\n  }, {\n    key: \"__normal3\",\n    value: function __normal3(t) {\n      // see http://stackoverflow.com/questions/25453159\n      var r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n      r1.x /= q1;\n      r1.y /= q1;\n      r1.z /= q1;\n      r2.x /= q2;\n      r2.y /= q2;\n      r2.z /= q2; // cross product\n\n      var c = {\n        x: r2.y * r1.z - r2.z * r1.y,\n        y: r2.z * r1.x - r2.x * r1.z,\n        z: r2.x * r1.y - r2.y * r1.x\n      };\n      var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n      c.x /= m;\n      c.y /= m;\n      c.z /= m; // rotation matrix\n\n      var R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n      var n = {\n        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n      };\n      return n;\n    }\n  }, {\n    key: \"hull\",\n    value: function hull(t) {\n      var p = this.points,\n          _p = [],\n          q = [],\n          idx = 0;\n      q[idx++] = p[0];\n      q[idx++] = p[1];\n      q[idx++] = p[2];\n\n      if (this.order === 3) {\n        q[idx++] = p[3];\n      } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n      while (p.length > 1) {\n        _p = [];\n\n        for (var i = 0, pt, l = p.length - 1; i < l; i++) {\n          pt = utils$1.lerp(t, p[i], p[i + 1]);\n          q[idx++] = pt;\n\n          _p.push(pt);\n        }\n\n        p = _p;\n      }\n\n      return q;\n    }\n  }, {\n    key: \"split\",\n    value: function split(t1, t2) {\n      // shortcuts\n      if (t1 === 0 && !!t2) {\n        return this.split(t2).left;\n      }\n\n      if (t2 === 1) {\n        return this.split(t1).right;\n      } // no shortcut: use \"de Casteljau\" iteration.\n\n\n      var q = this.hull(t1);\n      var result = {\n        left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n        right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n        span: q\n      }; // make sure we bind _t1/_t2 information!\n\n      result.left._t1 = utils$1.map(0, 0, 1, this._t1, this._t2);\n      result.left._t2 = utils$1.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t1 = utils$1.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t2 = utils$1.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n      if (!t2) {\n        return result;\n      } // if we have a t2, split again:\n\n\n      t2 = utils$1.map(t2, t1, 1, 0, 1);\n      return result.right.split(t2).left;\n    }\n  }, {\n    key: \"extrema\",\n    value: function extrema() {\n      var result = {};\n      var roots = [];\n      this.dims.forEach(function (dim) {\n        var mfn = function mfn(v) {\n          return v[dim];\n        };\n\n        var p = this.dpoints[0].map(mfn);\n        result[dim] = utils$1.droots(p);\n\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils$1.droots(p));\n        }\n\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils$1.numberSort));\n      }.bind(this));\n      result.values = roots.sort(utils$1.numberSort).filter(function (v, idx) {\n        return roots.indexOf(v) === idx;\n      });\n      return result;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var extrema = this.extrema(),\n          result = {};\n      this.dims.forEach(function (d) {\n        result[d] = utils$1.getminmax(this, d, extrema[d]);\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(curve) {\n      var lbbox = this.bbox(),\n          tbbox = curve.bbox();\n      return utils$1.bboxoverlap(lbbox, tbbox);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(t, d) {\n      if (typeof d !== \"undefined\") {\n        var c = this.get(t),\n            n = this.normal(t);\n        var ret = {\n          c: c,\n          n: n,\n          x: c.x + n.x * d,\n          y: c.y + n.y * d\n        };\n\n        if (this._3d) {\n          ret.z = c.z + n.z * d;\n        }\n\n        return ret;\n      }\n\n      if (this._linear) {\n        var nv = this.normal(0),\n            coords = this.points.map(function (p) {\n          var ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y\n          };\n\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n\n          return ret;\n        });\n        return [new Bezier(coords)];\n      }\n\n      return this.reduce().map(function (s) {\n        if (s._linear) {\n          return s.offset(t)[0];\n        }\n\n        return s.scale(t);\n      });\n    }\n  }, {\n    key: \"simple\",\n    value: function simple() {\n      if (this.order === 3) {\n        var a1 = utils$1.angle(this.points[0], this.points[3], this.points[1]);\n        var a2 = utils$1.angle(this.points[0], this.points[3], this.points[2]);\n        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n      }\n\n      var n1 = this.normal(0);\n      var n2 = this.normal(1);\n      var s = n1.x * n2.x + n1.y * n2.y;\n\n      if (this._3d) {\n        s += n1.z * n2.z;\n      }\n\n      return abs(acos(s)) < pi / 3;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce() {\n      // TODO: examine these var types in more detail...\n      var i,\n          t1 = 0,\n          t2 = 0,\n          step = 0.01,\n          segment,\n          pass1 = [],\n          pass2 = []; // first pass: split on extrema\n\n      var extrema = this.extrema().values;\n\n      if (extrema.indexOf(0) === -1) {\n        extrema = [0].concat(extrema);\n      }\n\n      if (extrema.indexOf(1) === -1) {\n        extrema.push(1);\n      }\n\n      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n        t2 = extrema[i];\n        segment = this.split(t1, t2);\n        segment._t1 = t1;\n        segment._t2 = t2;\n        pass1.push(segment);\n        t1 = t2;\n      } // second pass: further reduce these segments to simple segments\n\n\n      pass1.forEach(function (p1) {\n        t1 = 0;\n        t2 = 0;\n\n        while (t2 <= 1) {\n          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n            segment = p1.split(t1, t2);\n\n            if (!segment.simple()) {\n              t2 -= step;\n\n              if (abs(t1 - t2) < step) {\n                // we can never form a reduction\n                return [];\n              }\n\n              segment = p1.split(t1, t2);\n              segment._t1 = utils$1.map(t1, 0, 1, p1._t1, p1._t2);\n              segment._t2 = utils$1.map(t2, 0, 1, p1._t1, p1._t2);\n              pass2.push(segment);\n              t1 = t2;\n              break;\n            }\n          }\n        }\n\n        if (t1 < 1) {\n          segment = p1.split(t1, 1);\n          segment._t1 = utils$1.map(t1, 0, 1, p1._t1, p1._t2);\n          segment._t2 = p1._t2;\n          pass2.push(segment);\n        }\n      });\n      return pass2;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(d) {\n      var _this = this;\n\n      var order = this.order;\n      var distanceFn = false;\n\n      if (typeof d === \"function\") {\n        distanceFn = d;\n      }\n\n      if (distanceFn && order === 2) {\n        return this.raise().scale(distanceFn);\n      } // TODO: add special handling for degenerate (=linear) curves.\n\n\n      var clockwise = this.clockwise;\n      var r1 = distanceFn ? distanceFn(0) : d;\n      var r2 = distanceFn ? distanceFn(1) : d;\n      var v = [this.offset(0, 10), this.offset(1, 10)];\n      var points = this.points;\n      var np = [];\n      var o = utils$1.lli4(v[0], v[0].c, v[1], v[1].c);\n\n      if (!o) {\n        throw new Error(\"cannot scale this curve. Try reducing it first.\");\n      } // move all points by distance 'd' wrt the origin 'o'\n      // move end points by fixed distance along normal.\n\n\n      [0, 1].forEach(function (t) {\n        var p = np[t * order] = utils$1.copy(points[t * order]);\n        p.x += (t ? r2 : r1) * v[t].n.x;\n        p.y += (t ? r2 : r1) * v[t].n.y;\n      });\n\n      if (!distanceFn) {\n        // move control points to lie on the intersection of the offset\n        // derivative vector, and the origin-through-control vector\n        [0, 1].forEach(function (t) {\n          if (order === 2 && !!t) return;\n          var p = np[t * order];\n\n          var d = _this.derivative(t);\n\n          var p2 = {\n            x: p.x + d.x,\n            y: p.y + d.y\n          };\n          np[t + 1] = utils$1.lli4(p, p2, o, points[t + 1]);\n        });\n        return new Bezier(np);\n      } // move control points by \"however much necessary to\n      // ensure the correct tangent to endpoint\".\n\n\n      [0, 1].forEach(function (t) {\n        if (order === 2 && !!t) return;\n        var p = points[t + 1];\n        var ov = {\n          x: p.x - o.x,\n          y: p.y - o.y\n        };\n        var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n        if (distanceFn && !clockwise) rc = -rc;\n        var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n        ov.x /= m;\n        ov.y /= m;\n        np[t + 1] = {\n          x: p.x + rc * ov.x,\n          y: p.y + rc * ov.y\n        };\n      });\n      return new Bezier(np);\n    }\n  }, {\n    key: \"outline\",\n    value: function outline(d1, d2, d3, d4) {\n      d2 = typeof d2 === \"undefined\" ? d1 : d2;\n      var reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n      var bcurves = [],\n          p,\n          alen = 0,\n          tlen = this.length();\n      var graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n      function linearDistanceFunction(s, e, tlen, alen, slen) {\n        return function (v) {\n          var f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n          return utils$1.map(v, 0, 1, s + f1 * d, s + f2 * d);\n        };\n      } // form curve oulines\n\n\n      reduced.forEach(function (segment) {\n        var slen = segment.length();\n\n        if (graduated) {\n          fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n          bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n        } else {\n          fcurves.push(segment.scale(d1));\n          bcurves.push(segment.scale(-d2));\n        }\n\n        alen += slen;\n      }); // reverse the \"return\" outline\n\n      bcurves = bcurves.map(function (s) {\n        p = s.points;\n\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n\n        return s;\n      }).reverse(); // form the endcaps as lines\n\n      var fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils$1.makeline(bs, fs),\n          le = utils$1.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n      segments.length;\n      return new PolyBezier(segments);\n    }\n  }, {\n    key: \"outlineshapes\",\n    value: function outlineshapes(d1, d2, curveIntersectionThreshold) {\n      d2 = d2 || d1;\n      var outline = this.outline(d1, d2).curves;\n      var shapes = [];\n\n      for (var i = 1, len = outline.length; i < len / 2; i++) {\n        var shape = utils$1.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n        shape.startcap.virtual = i > 1;\n        shape.endcap.virtual = i < len / 2 - 1;\n        shapes.push(shape);\n      }\n\n      return shapes;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(curve, curveIntersectionThreshold) {\n      if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n      if (curve.p1 && curve.p2) {\n        return this.lineIntersects(curve);\n      }\n\n      if (curve instanceof Bezier) {\n        curve = curve.reduce();\n      }\n\n      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n    }\n  }, {\n    key: \"lineIntersects\",\n    value: function lineIntersects(line) {\n      var _this2 = this;\n\n      var mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n      return utils$1.roots(this.points, line).filter(function (t) {\n        var p = _this2.get(t);\n\n        return utils$1.between(p.x, mx, MX) && utils$1.between(p.y, my, MY);\n      });\n    }\n  }, {\n    key: \"selfintersects\",\n    value: function selfintersects(curveIntersectionThreshold) {\n      // \"simple\" curves cannot intersect with their direct\n      // neighbour, so for each segment X we check whether\n      // it intersects [0:x-2][x+2:last].\n      var reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n      for (var i = 0, result, left, right; i < len; i++) {\n        left = reduced.slice(i, i + 1);\n        right = reduced.slice(i + 2);\n        result = this.curveintersects(left, right, curveIntersectionThreshold);\n        results.push.apply(results, _toConsumableArray(result));\n      }\n\n      return results;\n    }\n  }, {\n    key: \"curveintersects\",\n    value: function curveintersects(c1, c2, curveIntersectionThreshold) {\n      var pairs = []; // step 1: pair off any overlapping segments\n\n      c1.forEach(function (l) {\n        c2.forEach(function (r) {\n          if (l.overlaps(r)) {\n            pairs.push({\n              left: l,\n              right: r\n            });\n          }\n        });\n      }); // step 2: for each pairing, run through the convergence algorithm.\n\n      var intersections = [];\n      pairs.forEach(function (pair) {\n        var result = utils$1.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n        if (result.length > 0) {\n          intersections = intersections.concat(result);\n        }\n      });\n      return intersections;\n    }\n  }, {\n    key: \"arcs\",\n    value: function arcs(errorThreshold) {\n      errorThreshold = errorThreshold || 0.5;\n      return this._iterate(errorThreshold, []);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(pc, np1, s, e) {\n      var q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils$1.dist(pc, np1),\n          d1 = utils$1.dist(pc, c1),\n          d2 = utils$1.dist(pc, c2);\n      return abs(d1 - ref) + abs(d2 - ref);\n    }\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(errorThreshold, circles) {\n      var t_s = 0,\n          t_e = 1,\n          safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n      do {\n        safety = 0; // step 1: start with the maximum possible arc\n\n        t_e = 1; // points:\n\n        var np1 = this.get(t_s),\n            np2 = void 0,\n            np3 = void 0,\n            arc = void 0,\n            prev_arc = void 0; // booleans:\n\n        var curr_good = false,\n            prev_good = false,\n            done = void 0; // numbers:\n\n        var t_m = t_e,\n            prev_e = 1; // step 2: find the best possible arc\n\n        do {\n          prev_good = curr_good;\n          prev_arc = arc;\n          t_m = (t_s + t_e) / 2;\n          np2 = this.get(t_m);\n          np3 = this.get(t_e);\n          arc = utils$1.getccenter(np1, np2, np3); //also save the t values\n\n          arc.interval = {\n            start: t_s,\n            end: t_e\n          };\n\n          var error = this._error(arc, np1, t_s, t_e);\n\n          curr_good = error <= errorThreshold;\n          done = prev_good && !curr_good;\n          if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n          if (curr_good) {\n            // if e is already at max, then we're done for this arc.\n            if (t_e >= 1) {\n              // make sure we cap at t=1\n              arc.interval.end = prev_e = 1;\n              prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n              // the arc's end angle is correct with respect to the bezier end point.\n\n              if (t_e > 1) {\n                var d = {\n                  x: arc.x + arc.r * cos(arc.e),\n                  y: arc.y + arc.r * sin(arc.e)\n                };\n                arc.e += utils$1.angle({\n                  x: arc.x,\n                  y: arc.y\n                }, d, this.get(1));\n              }\n\n              break;\n            } // if not, move it up by half the iteration distance\n\n\n            t_e = t_e + (t_e - t_s) / 2;\n          } else {\n            // this is a bad arc: we need to move 'e' down to find a good arc\n            t_e = t_m;\n          }\n        } while (!done && safety++ < 100);\n\n        if (safety >= 100) {\n          break;\n        } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n        prev_arc = prev_arc ? prev_arc : arc;\n        circles.push(prev_arc);\n        t_s = prev_e;\n      } while (t_e < 1);\n\n      return circles;\n    }\n  }], [{\n    key: \"quadraticFromPoints\",\n    value: function quadraticFromPoints(p1, p2, p3, t) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      } // shortcuts, although they're really dumb\n\n\n      if (t === 0) {\n        return new Bezier(p2, p2, p3);\n      }\n\n      if (t === 1) {\n        return new Bezier(p1, p2, p2);\n      } // real fitting.\n\n\n      var abc = Bezier.getABC(2, p1, p2, p3, t);\n      return new Bezier(p1, abc.A, p3);\n    }\n  }, {\n    key: \"cubicFromPoints\",\n    value: function cubicFromPoints(S, B, E, t, d1) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      }\n\n      var abc = Bezier.getABC(3, S, B, E, t);\n\n      if (typeof d1 === \"undefined\") {\n        d1 = utils$1.dist(B, abc.C);\n      }\n\n      var d2 = d1 * (1 - t) / t;\n      var selen = utils$1.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n      var e1 = {\n        x: B.x - bx1,\n        y: B.y - by1\n      },\n          e2 = {\n        x: B.x + bx2,\n        y: B.y + by2\n      },\n          A = abc.A,\n          v1 = {\n        x: A.x + (e1.x - A.x) / (1 - t),\n        y: A.y + (e1.y - A.y) / (1 - t)\n      },\n          v2 = {\n        x: A.x + (e2.x - A.x) / t,\n        y: A.y + (e2.y - A.y) / t\n      },\n          nc1 = {\n        x: S.x + (v1.x - S.x) / t,\n        y: S.y + (v1.y - S.y) / t\n      },\n          nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t)\n      }; // ...done\n\n      return new Bezier(S, nc1, nc2, E);\n    }\n  }, {\n    key: \"getUtils\",\n    value: function getUtils() {\n      return utils$1;\n    }\n  }, {\n    key: \"PolyBezier\",\n    get: function get() {\n      return PolyBezier;\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC() {\n      var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var S = arguments.length > 1 ? arguments[1] : undefined;\n      var B = arguments.length > 2 ? arguments[2] : undefined;\n      var E = arguments.length > 3 ? arguments[3] : undefined;\n      var t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n      var u = utils$1.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y\n      },\n          s = utils$1.abcratio(t, order),\n          A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s\n      };\n      return {\n        A: A,\n        B: B,\n        C: C,\n        S: S,\n        E: E\n      };\n    }\n  }]);\n\n  return Bezier;\n}();\n\nfunction Path() {\n  var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  this.render = true;\n  this.topLeft = false;\n  this.bottomRight = false;\n  this.attributes = new Attributes();\n  this.ops = [];\n  Object.defineProperty(this, 'debug', {\n    value: debug,\n    configurable: true\n  });\n}\n/** Adds the raise method for a path not created through the proxy **/\n\n\nPath.prototype.withRaise = function () {\n  var raise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  if (raise) Object.defineProperty(this, 'raise', {\n    value: raise\n  });\n  return this;\n};\n/** Chainable way to set the render property */\n\n\nPath.prototype.setRender = function () {\n  var render = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  if (render) this.render = true;else this.render = false;\n  if (this.debug) this.raise.debug('Setting `Path.render` to ' + (render ? '`true`' : '`false`'));\n  return this;\n};\n/** Adds a move operation to Point to */\n\n\nPath.prototype.move = function (to) {\n  if (this.debug && to instanceof Point !== true) this.raise.warning('Called `Path.rotate(to)` but `to` is not a `Point` object');\n  this.ops.push({\n    type: 'move',\n    to: to\n  });\n  return this;\n};\n/** Adds a line operation to Point to */\n\n\nPath.prototype.line = function (to) {\n  if (this.debug && to instanceof Point !== true) this.raise.warning('Called `Path.line(to)` but `to` is not a `Point` object');\n  this.ops.push({\n    type: 'line',\n    to: to\n  });\n  return this;\n};\n/** Adds a curve operation via cp1 & cp2 to Point to */\n\n\nPath.prototype.curve = function (cp1, cp2, to) {\n  if (this.debug) {\n    if (to instanceof Point !== true) this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `to` is not a `Point` object');\n    if (cp1 instanceof Point !== true) this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `cp1` is not a `Point` object');\n    if (cp2 instanceof Point !== true) this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `cp2` is not a `Point` object');\n  }\n\n  this.ops.push({\n    type: 'curve',\n    cp1: cp1,\n    cp2: cp2,\n    to: to\n  });\n  return this;\n};\n/** Adds a curve operation without cp1 via cp2 to Point to */\n\n\nPath.prototype._curve = function (cp2, to) {\n  if (this.debug) {\n    if (to instanceof Point !== true) this.raise.warning('Called `Path._curve(cp2, to)` but `to` is not a `Point` object');\n    if (cp2 instanceof Point !== true) this.raise.warning('Called `Path._curve(cp2, to)` but `cp2` is not a `Point` object');\n  }\n\n  var cp1 = this.ops.slice(-1).pop().to;\n  this.ops.push({\n    type: 'curve',\n    cp1: cp1,\n    cp2: cp2,\n    to: to\n  });\n  return this;\n};\n/** Adds a curve operation via cp1 with no cp2 to Point to */\n\n\nPath.prototype.curve_ = function (cp1, to) {\n  if (this.debug) {\n    if (to instanceof Point !== true) this.raise.warning('Called `Path.curve_(cp1, to)` but `to` is not a `Point` object');\n    if (cp1 instanceof Point !== true) this.raise.warning('Called `Path.curve_(cp1, to)` but `cp2` is not a `Point` object');\n  }\n\n  var cp2 = to.copy();\n  this.ops.push({\n    type: 'curve',\n    cp1: cp1,\n    cp2: cp2,\n    to: to\n  });\n  return this;\n};\n/** Adds a close operation */\n\n\nPath.prototype.close = function () {\n  this.ops.push({\n    type: 'close'\n  });\n  return this;\n};\n/** Adds a noop operation */\n\n\nPath.prototype.noop = function () {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  this.ops.push({\n    type: 'noop',\n    id: id\n  });\n  return this;\n};\n/** Replace a noop operation with the ops from path */\n\n\nPath.prototype.insop = function (noopId, path) {\n  if (this.debug) {\n    if (!noopId) this.raise.warning('Called `Path.insop(noopId, path)` but `noopId` is undefined or false');\n    if (path instanceof Path !== true) this.raise.warning('Called `Path.insop(noopId, path) but `path` is not a `Path` object');\n  }\n\n  var newPath = this.clone();\n\n  for (var i in newPath.ops) {\n    if (newPath.ops[i].type === 'noop' && newPath.ops[i].id === noopId) {\n      newPath.ops = newPath.ops.slice(0, i).concat(path.ops).concat(newPath.ops.slice(Number(i) + 1));\n    }\n  }\n\n  return newPath;\n};\n/** Adds an attribute. This is here to make this call chainable in assignment */\n\n\nPath.prototype.attr = function (name, value) {\n  var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (this.debug) {\n    if (!name) this.raise.warning('Called `Path.attr(name, value, overwrite=false)` but `name` is undefined or false');\n    if (typeof value === 'undefined') this.raise.warning('Called `Path.attr(name, value, overwrite=false)` but `value` is undefined');\n    if (overwrite) this.raise.debug(\"Overwriting `Path.attribute.\".concat(name, \"` with \").concat(value, \" (was: \").concat(this.attributes.get(name), \")\"));\n  }\n\n  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);\n  return this;\n};\n/** Returns SVG pathstring for this path */\n\n\nPath.prototype.asPathstring = function () {\n  var d = '';\n\n  var _iterator = _createForOfIteratorHelper(this.ops),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var op = _step.value;\n\n      switch (op.type) {\n        case 'move':\n          d += \"M \".concat(round(op.to.x), \",\").concat(round(op.to.y));\n          break;\n\n        case 'line':\n          d += \" L \".concat(round(op.to.x), \",\").concat(round(op.to.y));\n          break;\n\n        case 'curve':\n          d += \" C \".concat(round(op.cp1.x), \",\").concat(round(op.cp1.y), \" \").concat(round(op.cp2.x), \",\").concat(round(op.cp2.y), \" \").concat(round(op.to.x), \",\").concat(round(op.to.y));\n          break;\n\n        case 'close':\n          d += ' z';\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return d;\n};\n/** Returns offset of this path as a new path */\n\n\nPath.prototype.offset = function (distance) {\n  if (typeof distance !== 'number') this.raise.error('Called `Path.offset(distance)` but `distance` is not a number');\n  return pathOffset(this, distance, this.raise);\n};\n/** Returns the length of this path */\n\n\nPath.prototype.length = function () {\n  var current, start;\n  var length = 0;\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n\n    if (op.type === 'move') {\n      start = op.to;\n    } else if (op.type === 'line') {\n      length += current.dist(op.to);\n    } else if (op.type === 'curve') {\n      length += new Bezier({\n        x: current.x,\n        y: current.y\n      }, {\n        x: op.cp1.x,\n        y: op.cp1.y\n      }, {\n        x: op.cp2.x,\n        y: op.cp2.y\n      }, {\n        x: op.to.x,\n        y: op.to.y\n      }).length();\n    } else if (op.type === 'close') {\n      length += current.dist(start);\n    }\n\n    if (op.to) current = op.to;\n  }\n\n  return length;\n};\n/** Returns the startpoint of the path */\n\n\nPath.prototype.start = function () {\n  if (this.ops.length < 1 || typeof this.ops[0].to === 'undefined') this.raise.error('Called `Path.start()` but this path has no drawing operations');\n  return this.ops[0].to;\n};\n/** Returns the endpoint of the path */\n\n\nPath.prototype.end = function () {\n  if (this.ops.length < 1) this.raise.error('Called `Path.end()` but this path has no drawing operations');\n  var op = this.ops[this.ops.length - 1];\n  if (op.type === 'close') return this.start();else return op.to;\n};\n/** Finds the bounding box of a path */\n\n\nPath.prototype.boundary = function () {\n  if (this.topLeft) return this; // Cached\n\n  var current;\n  var topLeft = new Point(Infinity, Infinity);\n  var bottomRight = new Point(-Infinity, -Infinity);\n  var edges = [];\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n\n    if (op.type === 'move' || op.type === 'line') {\n      if (op.to.x < topLeft.x) {\n        topLeft.x = op.to.x;\n        edges['leftOp'] = i;\n      }\n\n      if (op.to.y < topLeft.y) {\n        topLeft.y = op.to.y;\n        edges['topOp'] = i;\n      }\n\n      if (op.to.x > bottomRight.x) {\n        bottomRight.x = op.to.x;\n        edges['rightOp'] = i;\n      }\n\n      if (op.to.y > bottomRight.y) {\n        bottomRight.y = op.to.y;\n        edges['bottomOp'] = i;\n      }\n    } else if (op.type === 'curve') {\n      var bb = new Bezier({\n        x: current.x,\n        y: current.y\n      }, {\n        x: op.cp1.x,\n        y: op.cp1.y\n      }, {\n        x: op.cp2.x,\n        y: op.cp2.y\n      }, {\n        x: op.to.x,\n        y: op.to.y\n      }).bbox();\n\n      if (bb.x.min < topLeft.x) {\n        topLeft.x = bb.x.min;\n        edges['leftOp'] = i;\n      }\n\n      if (bb.y.min < topLeft.y) {\n        topLeft.y = bb.y.min;\n        edges['topOp'] = i;\n      }\n\n      if (bb.x.max > bottomRight.x) {\n        bottomRight.x = bb.x.max;\n        edges['rightOp'] = i;\n      }\n\n      if (bb.y.max > bottomRight.y) {\n        bottomRight.y = bb.y.max;\n        edges['bottomOp'] = i;\n      }\n    }\n\n    if (op.to) current = op.to;\n  }\n\n  this.topLeft = topLeft;\n  this.bottomRight = bottomRight;\n\n  for (var _i = 0, _arr = ['top', 'left', 'bottom', 'right']; _i < _arr.length; _i++) {\n    var side = _arr[_i];\n    var s = side + 'Op';\n    this[s] = this.ops[edges[s]];\n    this[s].from = this[s].type === 'move' ? this[s].to : this.ops[edges[s] - 1].to;\n  }\n\n  return this;\n};\n/** Returns a deep copy of this */\n\n\nPath.prototype.clone = function () {\n  var clone = new Path(this.debug).withRaise(this.raise).setRender(this.render);\n  if (this.topLeft) clone.topLeft = this.topLeft.clone();else clone.topLeft = false;\n  if (this.bottomRight) clone.bottomRight = this.bottomRight.clone();else clone.bottomRight = false;\n  clone.attributes = this.attributes.clone();\n  clone.ops = [];\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n    clone.ops[i] = {\n      type: op.type\n    };\n\n    if (op.type === 'move' || op.type === 'line') {\n      clone.ops[i].to = op.to.clone();\n    } else if (op.type === 'curve') {\n      clone.ops[i].to = op.to.clone();\n      clone.ops[i].cp1 = op.cp1.clone();\n      clone.ops[i].cp2 = op.cp2.clone();\n    } else if (op.type === 'noop') {\n      clone.ops[i].id = op.id;\n    }\n  }\n\n  return clone;\n};\n/** Joins this with that path, closes them if wanted */\n\n\nPath.prototype.join = function (that) {\n  var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (that instanceof Path !== true) this.raise.error('Called `Path.join(that)` but `that` is not a `Path` object');\n  return joinPaths([this, that], closed, this.raise);\n};\n/** Offsets a path by distance */\n\n\nfunction pathOffset(path, distance, raise) {\n  var offset = [];\n  var current;\n  var closed = false;\n\n  for (var i in path.ops) {\n    var op = path.ops[i];\n\n    if (op.type === 'line') {\n      var segment = offsetLine(current, op.to, distance, path.debug, path.raise);\n      if (segment) offset.push(segment);\n    } else if (op.type === 'curve') {\n      // We need to avoid a control point sitting on top of start or end\n      // because that will break the offset in bezier-js\n      var cp1 = void 0,\n          cp2 = void 0;\n\n      if (current.sitsRoughlyOn(op.cp1)) {\n        cp1 = new Path(path.debug).withRaise(path.raise).move(current).curve(op.cp1, op.cp2, op.to).shiftAlong(2);\n      } else cp1 = op.cp1;\n\n      if (op.cp2.sitsRoughlyOn(op.to)) {\n        cp2 = new Path(path.debug).withRaise(path.raise).move(op.to).curve(op.cp2, op.cp1, current).shiftAlong(2);\n      } else cp2 = op.cp2;\n\n      var b = new Bezier({\n        x: current.x,\n        y: current.y\n      }, {\n        x: cp1.x,\n        y: cp1.y\n      }, {\n        x: cp2.x,\n        y: cp2.y\n      }, {\n        x: op.to.x,\n        y: op.to.y\n      });\n\n      var _iterator2 = _createForOfIteratorHelper(b.offset(distance)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var bezier = _step2.value;\n          offset.push(asPath(bezier, path.debug, path.raise));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (op.type === 'close') closed = true;\n\n    if (op.to) current = op.to;\n  }\n\n  return joinPaths(offset, closed, raise);\n}\n/** Offsets a line by distance */\n\n\nfunction offsetLine(from, to, distance) {\n  var debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var raise = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  if (from.x === to.x && from.y === to.y) return false;\n  var angle = from.angle(to) - 90;\n  return new Path(debug).withRaise(raise).move(from.shift(angle, distance)).line(to.shift(angle, distance));\n}\n/** Converts a bezier-js instance to a path */\n\n\nfunction asPath(bezier) {\n  var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var raise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return new Path(debug).withRaise(raise).move(new Point(bezier.points[0].x, bezier.points[0].y)).curve(new Point(bezier.points[1].x, bezier.points[1].y), new Point(bezier.points[2].x, bezier.points[2].y), new Point(bezier.points[3].x, bezier.points[3].y));\n}\n/** Joins path segments together into one path */\n\n\nfunction joinPaths(paths) {\n  var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var raise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var joint = new Path(paths[0].debug).withRaise(paths[0].raise).move(paths[0].ops[0].to);\n  var current;\n\n  var _iterator3 = _createForOfIteratorHelper(paths),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var p = _step3.value;\n\n      var _iterator4 = _createForOfIteratorHelper(p.ops),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var op = _step4.value;\n\n          if (op.type === 'curve') {\n            joint.curve(op.cp1, op.cp2, op.to);\n          } else if (op.type !== 'close') {\n            // We're using sitsRoughlyOn here to avoid miniscule line segments\n            if (current && !op.to.sitsRoughlyOn(current)) joint.line(op.to);\n          } else {\n            var err = 'Cannot join a closed path with another';\n            joint.raise.error(err);\n            throw new Error(err);\n          }\n\n          if (op.to) current = op.to;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (closed) joint.close();\n  return joint;\n}\n/** Returns a point that lies at distance along this */\n\n\nPath.prototype.shiftAlong = function (distance) {\n  var stepsPerMm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n  if (typeof distance !== 'number') this.raise.error('Called `Path.shiftAlong(distance)` but `distance` is not a number');\n  var len = 0;\n  var current;\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n\n    if (op.type === 'line') {\n      var thisLen = op.to.dist(current);\n      if (Math.abs(len + thisLen - distance) < 0.1) return op.to;\n      if (len + thisLen > distance) return current.shiftTowards(op.to, distance - len);\n      len += thisLen;\n    } else if (op.type === 'curve') {\n      var bezier = new Bezier({\n        x: current.x,\n        y: current.y\n      }, {\n        x: op.cp1.x,\n        y: op.cp1.y\n      }, {\n        x: op.cp2.x,\n        y: op.cp2.y\n      }, {\n        x: op.to.x,\n        y: op.to.y\n      });\n\n      var _thisLen = bezier.length();\n\n      if (Math.abs(len + _thisLen - distance) < 0.1) return op.to;\n      if (len + _thisLen > distance) return shiftAlongBezier(distance - len, bezier, _thisLen * stepsPerMm);\n      len += _thisLen;\n    }\n\n    current = op.to;\n  }\n\n  this.raise.error(\"Called `Path.shiftAlong(distance)` with a `distance` of `\".concat(distance, \"` but `Path.length()` is only `\").concat(this.length(), \"`\"));\n};\n/** Returns a point that lies at fraction along this */\n\n\nPath.prototype.shiftFractionAlong = function (fraction) {\n  var stepsPerMm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n  if (typeof fraction !== 'number') this.raise.error('Called `Path.shiftFractionAlong(fraction)` but `fraction` is not a number');\n  return this.shiftAlong(this.length() * fraction, stepsPerMm);\n};\n/** Returns a point that lies at distance along bezier */\n\n\nfunction shiftAlongBezier(distance, bezier) {\n  var steps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var previous, next, t, thisLen;\n  var len = 0;\n\n  for (var i = 0; i <= steps; i++) {\n    t = i / steps;\n    next = bezier.get(t);\n    next = new Point(next.x, next.y);\n\n    if (i > 0) {\n      thisLen = next.dist(previous);\n      if (len + thisLen > distance) return next;else len += thisLen;\n    }\n\n    previous = next;\n  }\n}\n/** Returns a point at the top edge of a bounding box of this */\n\n\nPath.prototype.bbox = function () {\n  var bbs = [];\n  var current;\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n\n    if (op.type === 'line') {\n      bbs.push(lineBoundingBox({\n        from: current,\n        to: op.to\n      }));\n    } else if (op.type === 'curve') {\n      bbs.push(curveBoundingBox(new Bezier({\n        x: current.x,\n        y: current.y\n      }, {\n        x: op.cp1.x,\n        y: op.cp1.y\n      }, {\n        x: op.cp2.x,\n        y: op.cp2.y\n      }, {\n        x: op.to.x,\n        y: op.to.y\n      })));\n    }\n\n    if (op.to) current = op.to;\n  }\n\n  return bbbbox(bbs);\n};\n\nfunction lineBoundingBox(line) {\n  var from = line.from;\n  var to = line.to;\n\n  if (from.x === to.x) {\n    if (from.y < to.y) return {\n      topLeft: from,\n      bottomRight: to\n    };else return {\n      topLeft: to,\n      bottomRight: from\n    };\n  } else if (from.y === to.y) {\n    if (from.x < to.x) return {\n      topLeft: from,\n      bottomRight: to\n    };else return {\n      topLeft: to,\n      bottomRight: from\n    };\n  } else if (from.x < to.x) {\n    if (from.y < to.y) return {\n      topLeft: from,\n      bottomRight: to\n    };else return {\n      topLeft: new Point(from.x, to.y),\n      bottomRight: new Point(to.x, from.y)\n    };\n  } else if (from.x > to.x) {\n    if (from.y < to.y) return {\n      topLeft: new Point(to.x, from.y),\n      bottomRight: new Point(from.x, to.y)\n    };else return {\n      topLeft: new Point(to.x, to.y),\n      bottomRight: new Point(from.x, from.y)\n    };\n  }\n}\n\nfunction curveBoundingBox(curve) {\n  var bb = curve.bbox();\n  return {\n    topLeft: new Point(bb.x.min, bb.y.min),\n    bottomRight: new Point(bb.x.max, bb.y.max)\n  };\n}\n\nfunction bbbbox(boxes) {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  var _iterator5 = _createForOfIteratorHelper(boxes),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var box = _step5.value;\n      if (box.topLeft.x < minX) minX = box.topLeft.x;\n      if (box.topLeft.y < minY) minY = box.topLeft.y;\n      if (box.bottomRight.x > maxX) maxX = box.bottomRight.x;\n      if (box.bottomRight.y > maxY) maxY = box.bottomRight.y;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return {\n    topLeft: new Point(minX, minY),\n    bottomRight: new Point(maxX, maxY)\n  };\n}\n/** Returns a reversed version of this */\n\n\nPath.prototype.reverse = function () {\n  var sections = [];\n  var current;\n  var closed = false;\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n\n    if (op.type === 'line') {\n      if (!op.to.sitsOn(current)) sections.push(new Path(this.debug).withRaise(this.raise).move(op.to).line(current));\n    } else if (op.type === 'curve') {\n      sections.push(new Path(this.debug).withRaise(this.raise).move(op.to).curve(op.cp2, op.cp1, current));\n    } else if (op.type === 'close') {\n      closed = true;\n    }\n\n    if (op.to) current = op.to;\n  }\n\n  var rev = new Path(this.debug).withRaise(this.raise).move(current);\n\n  var _iterator6 = _createForOfIteratorHelper(sections.reverse()),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var section = _step6.value;\n      rev.ops.push(section.ops[1]);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  if (closed) rev.close();\n  return rev;\n};\n/** Returns the point at an edge of this path */\n\n\nPath.prototype.edge = function (side) {\n  this.boundary();\n  if (side === 'topLeft') return this.topLeft;else if (side === 'bottomRight') return this.bottomRight;else if (side === 'topRight') return new Point(this.bottomRight.x, this.topLeft.y);else if (side === 'bottomLeft') return new Point(this.topLeft.x, this.bottomRight.y);else {\n    var s = side + 'Op';\n    if (this[s].type === 'move') return this[s].to;else if (this[s].type === 'line') {\n      if (side === 'top') {\n        if (this.topOp.to.y < this.topOp.from.y) return this.topOp.to;else return this.topOp.from;\n      } else if (side === 'left') {\n        if (this.leftOp.to.x < this.leftOp.from.x) return this.leftOp.to;else return this.leftOp.from;\n      } else if (side === 'bottom') {\n        if (this.bottomOp.to.y > this.bottomOp.from.y) return this.bottomOp.to;else return this.bottomOp.from;\n      } else if (side === 'right') {\n        if (this.rightOp.to.x > this.rightOp.from.x) return this.rightOp.to;else return this.rightOp.from;\n      }\n    } else if (this[s].type === 'curve') {\n      var curve = edgeCurveAsBezier(this[s]);\n      return curveEdge(curve, side);\n    }\n  }\n  this.raise.error(\"Unable to find `Path.edge(side)` for side \".concat(side));\n};\n\nfunction edgeCurveAsBezier(op) {\n  return new Bezier({\n    x: op.from.x,\n    y: op.from.y\n  }, {\n    x: op.cp1.x,\n    y: op.cp1.y\n  }, {\n    x: op.cp2.x,\n    y: op.cp2.y\n  }, {\n    x: op.to.x,\n    y: op.to.y\n  });\n}\n/** Divides a path into atomic paths */\n\n\nPath.prototype.divide = function () {\n  var paths = [];\n  var current, start;\n\n  for (var i in this.ops) {\n    var op = this.ops[i];\n\n    if (op.type === 'move') {\n      start = op.to;\n    } else if (op.type === 'line') {\n      if (!op.to.sitsRoughlyOn(current)) paths.push(new Path(this.debug).withRaise(this.raise).move(current).line(op.to));\n    } else if (op.type === 'curve') {\n      paths.push(new Path(this.debug).withRaise(this.raise).move(current).curve(op.cp1, op.cp2, op.to));\n    } else if (op.type === 'close') {\n      paths.push(new Path(this.debug).withRaise(this.raise).move(current).line(start));\n    }\n\n    if (op.to) current = op.to;\n  }\n\n  return paths;\n};\n/** Finds intersections between this path and an X value */\n\n\nPath.prototype.intersectsX = function (x) {\n  if (typeof x !== 'number') this.raise.error('Called `Path.intersectsX(x)` but `x` is not a number');\n  return this.intersectsAxis(x, 'x');\n};\n/** Finds intersections between this path and an Y value */\n\n\nPath.prototype.intersectsY = function (y) {\n  if (typeof y !== 'number') this.raise.error('Called `Path.intersectsX(y)` but `y` is not a number');\n  return this.intersectsAxis(y, 'y');\n};\n/** Finds intersections between this path and a X or Y value */\n\n\nPath.prototype.intersectsAxis = function () {\n  var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var mode = arguments.length > 1 ? arguments[1] : undefined;\n  var intersections = [];\n  var lineStart = mode === 'x' ? new Point(val, -100000) : new Point(-10000, val);\n  var lineEnd = mode === 'x' ? new Point(val, 100000) : new Point(100000, val);\n\n  var _iterator7 = _createForOfIteratorHelper(this.divide()),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var path = _step7.value;\n\n      if (path.ops[1].type === 'line') {\n        addIntersectionsToArray(linesIntersect(path.ops[0].to, path.ops[1].to, lineStart, lineEnd), intersections);\n      } else if (path.ops[1].type === 'curve') {\n        addIntersectionsToArray(lineIntersectsCurve(lineStart, lineEnd, path.ops[0].to, path.ops[1].cp1, path.ops[1].cp2, path.ops[1].to), intersections);\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return intersections;\n};\n/** Finds intersections between this path and another path */\n\n\nPath.prototype.intersects = function (path) {\n  if (this === path) this.raise.error('You called Path.intersects(path)` but `path` and `this` are the same object');\n  var intersections = [];\n\n  var _iterator8 = _createForOfIteratorHelper(this.divide()),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var pathA = _step8.value;\n\n      var _iterator9 = _createForOfIteratorHelper(path.divide()),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var pathB = _step9.value;\n\n          if (pathA.ops[1].type === 'line') {\n            if (pathB.ops[1].type === 'line') {\n              addIntersectionsToArray(linesIntersect(pathA.ops[0].to, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].to), intersections);\n            } else if (pathB.ops[1].type === 'curve') {\n              addIntersectionsToArray(lineIntersectsCurve(pathA.ops[0].to, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].cp1, pathB.ops[1].cp2, pathB.ops[1].to), intersections);\n            }\n          } else if (pathA.ops[1].type === 'curve') {\n            if (pathB.ops[1].type === 'line') {\n              addIntersectionsToArray(lineIntersectsCurve(pathB.ops[0].to, pathB.ops[1].to, pathA.ops[0].to, pathA.ops[1].cp1, pathA.ops[1].cp2, pathA.ops[1].to), intersections);\n            } else if (pathB.ops[1].type === 'curve') {\n              addIntersectionsToArray(curvesIntersect(pathA.ops[0].to, pathA.ops[1].cp1, pathA.ops[1].cp2, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].cp1, pathB.ops[1].cp2, pathB.ops[1].to), intersections);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return intersections;\n};\n\nfunction addIntersectionsToArray(candidates, intersections) {\n  if (!candidates) return;\n\n  if (typeof candidates === 'object') {\n    if (typeof candidates.x === 'number') intersections.push(candidates);else {\n      var _iterator10 = _createForOfIteratorHelper(candidates),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var candidate = _step10.value;\n          intersections.push(candidate);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }\n}\n/** Splits path on point, and retuns both halves */\n\n\nPath.prototype.split = function (point) {\n  if (point instanceof Point !== true) this.raise.error('Called `Path.split(point)` but `point` is not a `Point` object');\n  var divided = this.divide();\n  var firstHalf = false;\n  var secondHalf = false;\n\n  for (var _pi2 = 0; _pi2 < divided.length; _pi2++) {\n    var path = divided[_pi2];\n\n    if (path.ops[1].type === 'line') {\n      if (pointOnLine(path.ops[0].to, path.ops[1].to, point)) {\n        firstHalf = divided.slice(0, _pi2);\n        firstHalf.push(new Path(this.debug).withRaise(this.raise).move(path.ops[0].to).line(point));\n        _pi2++;\n        secondHalf = divided.slice(_pi2);\n        secondHalf.unshift(new Path(this.debug).withRaise(this.raise).move(point).line(path.ops[1].to));\n      }\n    } else if (path.ops[1].type === 'curve') {\n      var _t7 = pointOnCurve(path.ops[0].to, path.ops[1].cp1, path.ops[1].cp2, path.ops[1].to, point);\n\n      if (_t7 !== false) {\n        var curve = new Bezier({\n          x: path.ops[0].to.x,\n          y: path.ops[0].to.y\n        }, {\n          x: path.ops[1].cp1.x,\n          y: path.ops[1].cp1.y\n        }, {\n          x: path.ops[1].cp2.x,\n          y: path.ops[1].cp2.y\n        }, {\n          x: path.ops[1].to.x,\n          y: path.ops[1].to.y\n        });\n        var split = curve.split(_t7);\n        firstHalf = divided.slice(0, _pi2);\n        firstHalf.push(new Path(this.debug).withRaise(this.raise).move(new Point(split.left.points[0].x, split.left.points[0].y)).curve(new Point(split.left.points[1].x, split.left.points[1].y), new Point(split.left.points[2].x, split.left.points[2].y), new Point(split.left.points[3].x, split.left.points[3].y)));\n        _pi2++;\n        secondHalf = divided.slice(_pi2);\n        secondHalf.unshift(new Path(this.debug).withRaise(this.raise).move(new Point(split.right.points[0].x, split.right.points[0].y)).curve(new Point(split.right.points[1].x, split.right.points[1].y), new Point(split.right.points[2].x, split.right.points[2].y), new Point(split.right.points[3].x, split.right.points[3].y)));\n      }\n    }\n  }\n\n  if (firstHalf) firstHalf = joinPaths(firstHalf, false, this.raise);\n  if (secondHalf) secondHalf = joinPaths(secondHalf, false, this.raise);\n  return [firstHalf, secondHalf];\n};\n/** Removes self-intersections (overlap) from the path */\n\n\nPath.prototype.trim = function () {\n  var chunks = this.divide();\n\n  for (var i = 0; i < chunks.length; i++) {\n    var firstCandidate = parseInt(i) + 2;\n    var lastCandidate = parseInt(chunks.length) - 1;\n\n    for (var j = firstCandidate; j < lastCandidate; j++) {\n      var intersections = chunks[i].intersects(chunks[j]);\n\n      if (intersections.length > 0) {\n        var intersection = intersections.pop();\n        var trimmedStart = chunks.slice(0, i);\n        var trimmedEnd = chunks.slice(parseInt(j) + 1);\n        var glue = new Path(this.debug).withRaise(this.raise);\n        var first = true;\n\n        for (var _i2 = 0, _arr2 = [i, j]; _i2 < _arr2.length; _i2++) {\n          var k = _arr2[_i2];\n          var ops = chunks[k].ops;\n\n          if (ops[1].type === 'line') {\n            glue.line(intersection);\n          } else if (ops[1].type === 'curve') {\n            // handle curve\n            var curve = new Bezier({\n              x: ops[0].to.x,\n              y: ops[0].to.y\n            }, {\n              x: ops[1].cp1.x,\n              y: ops[1].cp1.y\n            }, {\n              x: ops[1].cp2.x,\n              y: ops[1].cp2.y\n            }, {\n              x: ops[1].to.x,\n              y: ops[1].to.y\n            });\n\n            var _t8 = pointOnCurve(ops[0].to, ops[1].cp1, ops[1].cp2, ops[1].to, intersection);\n\n            var split = curve.split(_t8);\n            var side = void 0;\n            if (first) side = split.left;else side = split.right;\n            glue.curve(new Point(side.points[1].x, side.points[1].y), new Point(side.points[2].x, side.points[2].y), new Point(side.points[3].x, side.points[3].y));\n          }\n\n          first = false;\n        }\n\n        var joint = void 0;\n        if (trimmedStart.length > 0) joint = joinPaths(trimmedStart, false, this.raise).join(glue);else joint = glue;\n        if (trimmedEnd.length > 0) joint = joint.join(joinPaths(trimmedEnd, false, this.raise));\n        return joint.trim();\n      }\n    }\n  }\n\n  return this;\n};\n/** Applies a path translate transform */\n\n\nPath.prototype.translate = function (x, y) {\n  if (this.debug) {\n    if (typeof x !== 'number') this.raise.warning('Called `Path.translate(x, y)` but `x` is not a number');\n    if (typeof y !== 'number') this.raise.warning('Called `Path.translate(x, y)` but `y` is not a number');\n  }\n\n  var clone = this.clone();\n\n  var _iterator11 = _createForOfIteratorHelper(clone.ops),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var op = _step11.value;\n\n      if (op.type !== 'close') {\n        op.to = op.to.translate(x, y);\n      }\n\n      if (op.type === 'curve') {\n        op.cp1 = op.cp1.translate(x, y);\n        op.cp2 = op.cp2.translate(x, y);\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  return clone;\n};\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n/** Checks for a valid coordinate value **/\n\n\nfunction isCoord(value) {\n  return value === value // NaN does not equal itself\n  ? typeof value === 'number' : false;\n}\n/** Returns internal hook name for a macro */\n\n\nfunction macroName(name) {\n  return \"_macro_\".concat(name);\n}\n/** Find intersection of two (endless) lines */\n\n\nfunction beamsIntersect(a1, a2, b1, b2) {\n  var slopeA = a1.slope(a2);\n  var slopeB = b1.slope(b2);\n  if (slopeA === slopeB) return false; // Parallel lines\n\n  if (a1.x === a2.x) return new Point(a1.x, slopeB * a1.x + (b1.y - slopeB * b1.x)); // Vertical line A\n  else if (b1.x === b2.x) return new Point(b1.x, slopeA * b1.x + (a1.y - slopeA * a1.x)); // Vertical line B\n    else {\n        // Swap points if line A or B goes from right to left\n        if (a1.x > a2.x) a1 = a2.copy();\n        if (b1.x > b2.x) b1 = b2.copy(); // Find y intercept\n\n        var iA = a1.y - slopeA * a1.x;\n        var iB = b1.y - slopeB * b1.x; // Find intersection\n\n        var x = (iB - iA) / (slopeA - slopeB);\n        var y = slopeA * x + iA;\n        return new Point(x, y);\n      }\n}\n/** Find intersection of two line segments */\n\n\nfunction linesIntersect(a1, a2, b1, b2) {\n  var p = beamsIntersect(a1, a2, b1, b2);\n  if (!p) return false;\n  var lenA = a1.dist(a2);\n  var lenB = b1.dist(b2);\n  var lenC = a1.dist(p) + p.dist(a2);\n  var lenD = b1.dist(p) + p.dist(b2);\n  if (Math.round(lenA) == Math.round(lenC) && Math.round(lenB) == Math.round(lenD)) return p;else return false;\n}\n/** Finds out whether a point lies on an endless line */\n\n\nfunction pointOnBeam(from, to, check) {\n  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e6;\n  if (from.sitsOn(check)) return true;\n  if (to.sitsOn(check)) return true;\n  var cross = check.dx(from) * to.dy(from) - check.dy(from) * to.dx(from);\n  if (Math.abs(Math.round(cross * precision) / precision) === 0) return true;else return false;\n}\n/** Finds out whether a point lies on a line segment */\n\n\nfunction pointOnLine(from, to, check) {\n  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e6;\n  if (!pointOnBeam(from, to, check, precision)) return false;\n  var lenA = from.dist(to);\n  var lenB = from.dist(check) + check.dist(to);\n  if (Math.round(lenA) == Math.round(lenB)) return true;else return false;\n}\n/** Finds out whether a point lies on a curve */\n\n\nfunction pointOnCurve(start, cp1, cp2, end, check) {\n  if (start.sitsOn(check)) return true;\n  if (end.sitsOn(check)) return true;\n  var curve = new Bezier({\n    x: start.x,\n    y: start.y\n  }, {\n    x: cp1.x,\n    y: cp1.y\n  }, {\n    x: cp2.x,\n    y: cp2.y\n  }, {\n    x: end.x,\n    y: end.y\n  });\n  var intersections = curve.intersects({\n    p1: {\n      x: check.x - 1,\n      y: check.y\n    },\n    p2: {\n      x: check.x + 1,\n      y: check.y\n    }\n  });\n\n  if (intersections.length === 0) {\n    // Handle edge case of a curve that's a perfect horizontal line\n    intersections = curve.intersects({\n      p1: {\n        x: check.x,\n        y: check.y - 1\n      },\n      p2: {\n        x: check.x,\n        y: check.y + 1\n      }\n    });\n  }\n\n  if (intersections.length > 0) return intersections.shift();else return false;\n}\n/** Splits a curve on a point */\n\n\nfunction splitCurve(start, cp1, cp2, end, split) {\n  var _Path$move$curve$spli = new Path().move(start).curve(cp1, cp2, end).split(split),\n      _Path$move$curve$spli2 = _slicedToArray(_Path$move$curve$spli, 2),\n      c1 = _Path$move$curve$spli2[0],\n      c2 = _Path$move$curve$spli2[1];\n\n  return [{\n    start: c1.ops[0].to,\n    cp1: c1.ops[1].cp1,\n    cp2: c1.ops[1].cp2,\n    end: c1.ops[1].to\n  }, {\n    start: c2.ops[0].to,\n    cp1: c2.ops[1].cp1,\n    cp2: c2.ops[1].cp2,\n    end: c2.ops[1].to\n  }];\n}\n/** Find where an (endless) line intersects with a certain X-value */\n\n\nfunction beamIntersectsX(from, to, x) {\n  if (from.x === to.x) return false; // Vertical line\n\n  var top = new Point(x, -10);\n  var bottom = new Point(x, 10);\n  return beamsIntersect(from, to, top, bottom);\n}\n/** Find where an (endless) line intersects with a certain Y-value */\n\n\nfunction beamIntersectsY(from, to, y) {\n  if (from.y === to.y) return false; // Horizontal line\n\n  var left = new Point(-10, y);\n  var right = new Point(10, y);\n  return beamsIntersect(from, to, left, right);\n}\n/** Convert value in mm to cm or imperial units */\n\n\nfunction units(value) {\n  var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'metric';\n  if (to === 'imperial') return round(value / 25.4) + '&quot;';else return round(value / 10) + 'cm';\n}\n/** Find where a curve intersects with line */\n\n\nfunction lineIntersectsCurve(start, end, from, cp1, cp2, to) {\n  var intersections = [];\n  var bz = new Bezier({\n    x: from.x,\n    y: from.y\n  }, {\n    x: cp1.x,\n    y: cp1.y\n  }, {\n    x: cp2.x,\n    y: cp2.y\n  }, {\n    x: to.x,\n    y: to.y\n  });\n  var line = {\n    p1: {\n      x: start.x,\n      y: start.y\n    },\n    p2: {\n      x: end.x,\n      y: end.y\n    }\n  };\n\n  var _iterator12 = _createForOfIteratorHelper(bz.intersects(line)),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var _t9 = _step12.value;\n      var isect = bz.get(_t9);\n      intersections.push(new Point(isect.x, isect.y));\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  if (intersections.length === 0) return false;else if (intersections.length === 1) return intersections[0];else return intersections;\n}\n/** Find where a curve intersects with a given X-value */\n\n\nfunction curveIntersectsX(from, cp1, cp2, to, x) {\n  var start = new Point(x, -10000);\n  var end = new Point(x, 10000);\n  return lineIntersectsCurve(start, end, from, cp1, cp2, to);\n}\n/** Find where a curve intersects with a given Y-value */\n\n\nfunction curveIntersectsY(from, cp1, cp2, to, y) {\n  var start = new Point(-10000, y);\n  var end = new Point(10000, y);\n  return lineIntersectsCurve(start, end, from, cp1, cp2, to);\n}\n/** Find where a curve intersects with another curve */\n\n\nfunction curvesIntersect(fromA, cp1A, cp2A, toA, fromB, cp1B, cp2B, toB) {\n  var precision = 0.005; // See https://github.com/Pomax/bezierjs/issues/99\n\n  var intersections = [];\n  var curveA = new Bezier({\n    x: fromA.x,\n    y: fromA.y\n  }, {\n    x: cp1A.x,\n    y: cp1A.y\n  }, {\n    x: cp2A.x,\n    y: cp2A.y\n  }, {\n    x: toA.x,\n    y: toA.y\n  });\n  var curveB = new Bezier({\n    x: fromB.x,\n    y: fromB.y\n  }, {\n    x: cp1B.x,\n    y: cp1B.y\n  }, {\n    x: cp2B.x,\n    y: cp2B.y\n  }, {\n    x: toB.x,\n    y: toB.y\n  });\n\n  var _iterator13 = _createForOfIteratorHelper(curveA.intersects(curveB, precision)),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var tvalues = _step13.value;\n      var intersection = curveA.get(tvalues.substr(0, tvalues.indexOf('/')));\n      intersections.push(new Point(intersection.x, intersection.y));\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  if (intersections.length === 0) return false;else if (intersections.length === 1) return intersections.shift();else {\n    var unique = [];\n\n    var _iterator14 = _createForOfIteratorHelper(intersections),\n        _step14;\n\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var i = _step14.value;\n        var dupe = false;\n\n        var _iterator15 = _createForOfIteratorHelper(unique),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var u = _step15.value;\n            if (i.sitsRoughlyOn(u)) dupe = true;\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n\n        if (!dupe) unique.push(i);\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n\n    return unique;\n  }\n}\n/** Find the intersections between two circles */\n\n\nfunction circlesIntersect(c1, r1, c2, r2) {\n  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'x';\n  var dx = c1.dx(c2);\n  var dy = c1.dy(c2);\n  var dist = c1.dist(c2); // Check for edge cases\n\n  if (dist > parseFloat(r1) + parseFloat(r2)) return false; // Circles do not intersect\n\n  if (dist < parseFloat(r2) - parseFloat(r1)) return false; // One circle is contained in the other\n\n  if (dist === 0 && r1 === r2) return false; // Two circles are identical\n\n  var chorddistance = (Math.pow(r1, 2) - Math.pow(r2, 2) + Math.pow(dist, 2)) / (2 * dist);\n  var halfchordlength = Math.sqrt(Math.pow(r1, 2) - Math.pow(chorddistance, 2));\n  var chordmidpointx = c1.x + chorddistance * dx / dist;\n  var chordmidpointy = c1.y + chorddistance * dy / dist;\n  var i1 = new Point(chordmidpointx + halfchordlength * dy / dist, chordmidpointy - halfchordlength * dx / dist);\n  var i2 = new Point(chordmidpointx - halfchordlength * dy / dist, chordmidpointy + halfchordlength * dx / dist);\n  if (sort === 'x' && i1.x <= i2.x || sort === 'y' && i1.y <= i2.y) return [i1, i2];else return [i2, i1];\n}\n/** Find the intersections between a beam and a circle */\n\n\nfunction beamIntersectsCircle(c, r, p1, p2) {\n  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'x';\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  var A = Math.pow(dx, 2) + Math.pow(dy, 2);\n  var B = 2 * (dx * (p1.x - c.x) + dy * (p1.y - c.y));\n  var C = Math.pow(p1.x - c.x, 2) + Math.pow(p1.y - c.y, 2) - Math.pow(r, 2);\n  var det = Math.pow(B, 2) - 4 * A * C;\n  if (A <= 0.0000001 || det < 0) return false; // No real solutions\n  else if (det === 0) {\n      // One solution\n      var _t10 = -1 * B / (2 * A);\n\n      var i1 = new Point(p1.x + _t10 * dx, p1.y + _t10 * dy);\n      return [i1];\n    } else {\n      // Two solutions\n      var _t11 = (-1 * B + Math.sqrt(det)) / (2 * A);\n\n      var _i3 = new Point(p1.x + _t11 * dx, p1.y + _t11 * dy);\n\n      _t11 = (-1 * B - Math.sqrt(det)) / (2 * A);\n      var i2 = new Point(p1.x + _t11 * dx, p1.y + _t11 * dy);\n      if (sort === 'x' && _i3.x <= i2.x || sort === 'y' && _i3.y <= i2.y) return [_i3, i2];else return [i2, _i3];\n    }\n}\n/** Find the intersections between a line and a circle */\n\n\nfunction lineIntersectsCircle(c, r, p1, p2) {\n  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'x';\n  var intersections = beamIntersectsCircle(c, r, p1, p2, sort);\n  if (intersections === false) return false;else {\n    if (intersections.length === 1) {\n      if (pointOnLine(p1, p2, intersections[0])) return intersections;else return false;\n    } else {\n      var i1 = intersections[0];\n      var i2 = intersections[1];\n      if (!pointOnLine(p1, p2, i1, 5) && !pointOnLine(p1, p2, i2, 5)) return false;else if (pointOnLine(p1, p2, i1, 5) && pointOnLine(p1, p2, i2, 5)) {\n        if (sort === 'x' && i1.x <= i2.x || sort === 'y' && i1.y <= i2.y) return [i1, i2];else return [i2, i1];\n      } else if (pointOnLine(p1, p2, i1, 5)) return [i1];else if (pointOnLine(p1, p2, i2, 5)) return [i2];\n    }\n  }\n}\n\nfunction curveEdge(curve, edge) {\n  var steps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n  var x = Infinity;\n  var y = Infinity;\n  var p;\n  if (edge === 'bottom') y = -Infinity;\n  if (edge === 'right') x = -Infinity;\n\n  for (var i = 0; i < steps; i++) {\n    p = curve.get(i / steps);\n\n    if (edge === 'top' && p.y < y || edge === 'bottom' && p.y > y || edge === 'right' && p.x > x || edge === 'left' && p.x < x) {\n      x = p.x;\n      y = p.y;\n    }\n  }\n\n  return new Point(x, y);\n}\n/**\n * Calculates scale factor based on stretch factor\n *\n * The way people measure stretch intuitively is\n * different from the way we handle stretch in code.\n * When people say '25% stretch' they mean that\n * 10cm fabric should get stretched to 12.5cm fabric.\n * In our code, that means we need to scale things by 80%.\n *\n * This method does that calculation.\n */\n\n\nfunction stretchToScale(stretch) {\n  return 1 / (1 + parseFloat(stretch));\n}\n\nfunction round(value) {\n  return Math.round(value * 1e2) / 1e2;\n}\n\nfunction sampleStyle(run, runs) {\n  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return styles && Array.isArray(styles) && styles.length > 0 ? styles[run % styles.length] : \"stroke: hsl(\".concat((run - 1) * (330 / runs), \", 100%, 35%);\");\n}\n\nfunction deg2rad(degrees) {\n  return degrees * (Math.PI / 180);\n}\n\nfunction rad2deg(radians) {\n  return radians / Math.PI * 180;\n} // Export bezier-js so plugins can use it\n\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  capitalize: capitalize,\n  isCoord: isCoord,\n  macroName: macroName,\n  beamsIntersect: beamsIntersect,\n  linesIntersect: linesIntersect,\n  pointOnBeam: pointOnBeam,\n  pointOnLine: pointOnLine,\n  pointOnCurve: pointOnCurve,\n  splitCurve: splitCurve,\n  beamIntersectsX: beamIntersectsX,\n  beamIntersectsY: beamIntersectsY,\n  units: units,\n  lineIntersectsCurve: lineIntersectsCurve,\n  curveIntersectsX: curveIntersectsX,\n  curveIntersectsY: curveIntersectsY,\n  curvesIntersect: curvesIntersect,\n  circlesIntersect: circlesIntersect,\n  beamIntersectsCircle: beamIntersectsCircle,\n  lineIntersectsCircle: lineIntersectsCircle,\n  curveEdge: curveEdge,\n  stretchToScale: stretchToScale,\n  round: round,\n  sampleStyle: sampleStyle,\n  deg2rad: deg2rad,\n  rad2deg: rad2deg,\n  Bezier: Bezier\n});\n\nfunction Snippet(def, anchor) {\n  var debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  this.def = def;\n  this.anchor = anchor;\n  this.attributes = new Attributes();\n  Object.defineProperty(this, 'debug', {\n    value: debug,\n    configurable: true\n  });\n  return this;\n}\n/** Adds the raise method for a snippet not created through the proxy **/\n\n\nSnippet.prototype.withRaise = function () {\n  var raise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  if (raise) Object.defineProperty(this, 'raise', {\n    value: raise\n  });\n  return this;\n};\n/** Adds an attribute. This is here to make this call chainable in assignment */\n\n\nSnippet.prototype.attr = function (name, value) {\n  var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);\n  return this;\n};\n/** Returns a deep copy of this */\n\n\nSnippet.prototype.clone = function () {\n  var clone = new Snippet(this.def, this.anchor.clone(), this.debug).withRaise(this.raise);\n  clone.attributes = this.attributes.clone();\n  return clone;\n};\n\nfunction Hooks() {\n  return {\n    preDraft: [],\n    postDraft: [],\n    preSample: [],\n    postSample: [],\n    preRender: [],\n    postRender: [],\n    insertText: []\n  };\n}\n\nfunction Part() {\n  this.attributes = new Attributes();\n  this.points = {};\n  this.paths = {};\n  this.snippets = {};\n  this.freeId = 0;\n  this.topLeft = false;\n  this.bottomRight = false;\n  this.width = false;\n  this.height = false;\n  this.render = true;\n  this.utils = utils;\n  this.Point = Point;\n  this.Path = Path;\n  this.Snippet = Snippet;\n  this.hooks = new Hooks(); // Hooks container\n\n  return this;\n}\n\nPart.prototype.macroClosure = function (args) {\n  var self = this;\n\n  var method = function method(key, args) {\n    var macro = macroName(key);\n    if (typeof self[macro] === 'function') self[macro](args);\n  };\n\n  return method;\n};\n\nPart.prototype.runHooks = function (hookName) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (data === false) data = this;\n  var hooks = this.hooks[hookName];\n\n  if (hooks && hooks.length > 0) {\n    var _iterator16 = _createForOfIteratorHelper(hooks),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var hook = _step16.value;\n        hook.method(data, hook.data);\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n};\n/** Returns an unused ID */\n\n\nPart.prototype.getId = function () {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  this.freeId += 1;\n  return prefix + this.freeId;\n};\n/** Returns a value formatted for units provided in settings */\n\n\nPart.prototype.unitsClosure = function (value) {\n  var self = this;\n\n  var method = function method(value) {\n    if (self.context.settings.debug && typeof value !== 'number') self.context.raise.debug(\"Calling `units(value)` but `value` is not a number (`\".concat(typeof value, \"`)\"));\n    return units(value, self.context.settings.units);\n  };\n\n  return method;\n};\n/** Calculates the part's bounding box and sets it */\n\n\nPart.prototype.boundary = function () {\n  if (this.topLeft) return this; // Cached\n\n  var topLeft = new Point(Infinity, Infinity);\n  var bottomRight = new Point(-Infinity, -Infinity);\n\n  for (var key in this.paths) {\n    try {\n      var path = this.paths[key].boundary();\n\n      if (path.render) {\n        if (path.topLeft.x < topLeft.x) topLeft.x = path.topLeft.x;\n        if (path.topLeft.y < topLeft.y) topLeft.y = path.topLeft.y;\n        if (path.bottomRight.x > bottomRight.x) bottomRight.x = path.bottomRight.x;\n        if (path.bottomRight.y > bottomRight.y) bottomRight.y = path.bottomRight.y;\n      }\n    } catch (err) {\n      this.context.raise.error(\"Could not calculate boundary of `paths.\".concat(key, \"`\"));\n      this.context.raise.debug(\"Since `paths.\".concat(key, \"` has no boundary, neither does `parts.\").concat(this.name, \"`. Ejecting part\"));\n      return false;\n    }\n  }\n\n  for (var _key in this.points) {\n    var point = this.points[_key];\n    var radius = point.attributes.get('data-circle');\n\n    if (radius) {\n      radius = parseFloat(radius);\n      if (point.x - radius < topLeft.x) topLeft.x = point.x - radius;\n      if (point.y - radius < topLeft.y) topLeft.y = point.y - radius;\n      if (point.x + radius > bottomRight.x) bottomRight.x = point.x + radius;\n      if (point.y + radius > bottomRight.y) bottomRight.y = point.y + radius;\n    }\n  } // Fix infinity if part has no paths\n\n\n  if (topLeft.x === Infinity) topLeft.x = 0;\n  if (topLeft.y === Infinity) topLeft.y = 0;\n  if (bottomRight.x === -Infinity) bottomRight.x = 0;\n  if (bottomRight.y === -Infinity) bottomRight.y = 0; // Add margin\n\n  var margin = this.context.settings.margin;\n  if (this.context.settings.paperless && margin < 10) margin = 10;\n  this.topLeft = new Point(topLeft.x - margin, topLeft.y - margin);\n  this.bottomRight = new Point(bottomRight.x + margin, bottomRight.y + margin);\n  this.width = this.bottomRight.x - this.topLeft.x;\n  this.height = this.bottomRight.y - this.topLeft.y;\n  return this;\n};\n/** Stacks part so that its top left corner is in (0,0) */\n\n\nPart.prototype.stack = function () {\n  if (this.topLeft !== false) return this;else this.boundary();\n  if (this.topLeft.x == 0 && this.topLeft.y == 0) return this;else this.attr('transform', \"translate(\".concat(this.topLeft.x * -1, \", \").concat(this.topLeft.y * -1, \")\"));\n  return this;\n};\n/** Adds an attribute. This is here to make this call chainable in assignment */\n\n\nPart.prototype.attr = function (name, value) {\n  var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);\n  return this;\n};\n/** Copies point/path/snippet data from part orig into this */\n\n\nPart.prototype.inject = function (orig) {\n  var findBasePoint = function findBasePoint(p) {\n    for (var i in orig.points) {\n      if (orig.points[i] === p) return i;\n    }\n\n    return false;\n  };\n\n  for (var i in orig.points) {\n    this.points[i] = orig.points[i].clone();\n  }\n\n  for (var _i4 in orig.paths) {\n    this.paths[_i4] = orig.paths[_i4].clone(); // Keep link between points and path ops where possible\n\n    for (var j in orig.paths[_i4].ops) {\n      var op = orig.paths[_i4].ops[j];\n\n      if (op.type !== 'close') {\n        var toPoint = findBasePoint(op.to);\n        if (toPoint) this.paths[_i4].ops[j].to = this.points[toPoint];\n      }\n\n      if (op.type === 'curve') {\n        var cp1Point = findBasePoint(op.cp1);\n        if (cp1Point) this.paths[_i4].ops[j].cp1 = this.points[cp1Point];\n        var cp2Point = findBasePoint(op.cp2);\n        if (cp2Point) this.paths[_i4].ops[j].cp2 = this.points[cp2Point];\n      }\n    }\n  }\n\n  for (var _i5 in orig.snippets) {\n    this.snippets[_i5] = orig.snippets[_i5].clone();\n  }\n\n  return this;\n};\n\nPart.prototype.units = function (input) {\n  return units(input, this.context.settings.units);\n};\n/** Returns an object with shorthand access for pattern design */\n\n\nPart.prototype.shorthand = function () {\n  var complete = this.context.settings.complete ? true : false;\n  var paperless = this.context.settings.paperless === true ? true : false;\n  var sa = this.context.settings.complete ? this.context.settings.sa || 0 : 0;\n  var shorthand = {\n    sa: sa,\n    store: this.context.store,\n    macro: this.macroClosure(),\n    units: this.unitsClosure(),\n    utils: utils,\n    complete: complete,\n    paperless: paperless,\n    events: this.context.events,\n    raise: this.context.raise\n  };\n\n  if (this.context.settings.debug) {\n    // We'll need this\n    var self = this; // Wrap the Point constructor so objects can raise events\n\n    shorthand.Point = function (x, y) {\n      Point.apply(this, [x, y, true]);\n      Object.defineProperty(this, 'raise', {\n        value: self.context.raise\n      });\n    };\n\n    shorthand.Point.prototype = Object.create(Point.prototype); // Wrap the Path constructor so objects can raise events\n\n    shorthand.Path = function () {\n      Path.apply(this, [true]);\n      Object.defineProperty(this, 'raise', {\n        value: self.context.raise\n      });\n    };\n\n    shorthand.Path.prototype = Object.create(Path.prototype); // Wrap the Snippet constructor so objects can raise events\n\n    shorthand.Snippet = function (def, anchor) {\n      Snippet.apply(this, [def, anchor, true]);\n      Snippet.apply(this, arguments);\n      Object.defineProperty(this, 'raise', {\n        value: self.context.raise\n      });\n    };\n\n    shorthand.Snippet.prototype = Object.create(Snippet.prototype); // Proxy the points object\n\n    var pointsProxy = {\n      get: function get() {\n        return Reflect.get.apply(Reflect, arguments);\n      },\n      set: function set(points, name, value) {\n        // Constructor checks\n        if (value instanceof Point !== true) self.context.raise.warning(\"`points.\".concat(name, \"` was set with a value that is not a `Point` object\"));\n        if (value.x == null || !isCoord(value.x)) self.context.raise.warning(\"`points.\".concat(name, \"` was set with a `x` parameter that is not a `number`\"));\n        if (value.y == null || !isCoord(value.y)) self.context.raise.warning(\"`points.\".concat(name, \"` was set with a `y` parameter that is not a `number`\"));\n\n        try {\n          value.name = name;\n        } catch (err) {\n          self.context.raise.warning(\"Could not set `name` property on `points.\".concat(name, \"`\"));\n        }\n\n        return self.points[name] = value;\n      }\n    };\n    shorthand.points = new Proxy(this.points || {}, pointsProxy); // Proxy the paths object\n\n    var pathsProxy = {\n      get: function get() {\n        return Reflect.get.apply(Reflect, arguments);\n      },\n      set: function set(paths, name, value) {\n        // Constructor checks\n        if (value instanceof Path !== true) self.context.raise.warning(\"`paths.\".concat(name, \"` was set with a value that is not a `Path` object\"));\n\n        try {\n          value.name = name;\n        } catch (err) {\n          self.context.raise.warning(\"Could not set `name` property on `paths.\".concat(name, \"`\"));\n        }\n\n        return self.paths[name] = value;\n      }\n    };\n    shorthand.paths = new Proxy(this.paths || {}, pathsProxy); // Proxy the snippets object\n\n    var snippetsProxy = {\n      get: function get(target, prop, receiver) {\n        return Reflect.get.apply(Reflect, arguments);\n      },\n      set: function set(snippets, name, value) {\n        // Constructor checks\n        if (value instanceof Snippet !== true) self.context.raise.warning(\"`snippets.\".concat(name, \"` was set with a value that is not a `Snippet` object\"));\n        if (typeof value.def !== 'string') self.context.raise.warning(\"`snippets.\".concat(name, \"` was set with a `def` parameter that is not a `string`\"));\n        if (value.anchor instanceof Point !== true) self.context.raise.warning(\"`snippets.\".concat(name, \"` was set with an `anchor` parameter that is not a `Point`\"));\n\n        try {\n          value.name = name;\n        } catch (err) {\n          self.context.raise.warning(\"Could not set `name` property on `snippets.\".concat(name, \"`\"));\n        }\n\n        return self.snippets[name] = value;\n      }\n    };\n    shorthand.snippets = new Proxy(this.snippets || {}, snippetsProxy); // Proxy the measurements object\n\n    var measurementsProxy = {\n      get: function get(measurements, name) {\n        if (typeof measurements[name] === 'undefined') self.context.raise.warning(\"Tried to access `measurements.\".concat(name, \"` but it is `undefined`\"));\n        return Reflect.get.apply(Reflect, arguments);\n      },\n      set: function set(measurements, name, value) {\n        return self.context.settings.measurements[name] = value;\n      }\n    };\n    shorthand.measurements = new Proxy(this.context.settings.measurements || {}, measurementsProxy); // Proxy the options object\n\n    var optionsProxy = {\n      get: function get(options, name) {\n        if (typeof options[name] === 'undefined') self.context.raise.warning(\"Tried to access `options.\".concat(name, \"` but it is `undefined`\"));\n        return Reflect.get.apply(Reflect, arguments);\n      },\n      set: function set(options, name, value) {\n        return self.context.settings.options[name] = value;\n      }\n    };\n    shorthand.options = new Proxy(this.context.settings.options || {}, optionsProxy);\n  } else {\n    shorthand.Point = Point;\n    shorthand.Path = Path;\n    shorthand.Snippet = Snippet;\n    shorthand.points = this.points || {};\n    shorthand.paths = this.paths || {};\n    shorthand.snippets = this.snippets || {};\n    shorthand.measurements = this.context.settings.measurements || {};\n    shorthand.options = this.context.settings.options || {};\n  }\n\n  return shorthand;\n};\n\nvar version = \"2.17.0\";\n\nfunction Svg(pattern) {\n  this.openGroups = [];\n  this.layout = {};\n  this.freeId = 0;\n  this.body = '';\n  this.style = '';\n  this.script = '';\n  this.defs = '';\n  this.pattern = pattern; // Needed to expose pattern to hooks\n\n  this.prefix = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>';\n  this.attributes = new Attributes();\n  this.attributes.add('xmlns', 'http://www.w3.org/2000/svg');\n  this.attributes.add('xmlns:svg', 'http://www.w3.org/2000/svg');\n  this.attributes.add('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n  this.attributes.add('xml:lang', pattern.settings.locale);\n  this.attributes.add('xmlns:freesewing', 'http://freesewing.org/namespaces/freesewing');\n  this.attributes.add('freesewing', version);\n}\n\nSvg.prototype.runHooks = function (hookName) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (data === false) data = this;\n  var hooks = this.hooks[hookName];\n\n  if (hooks.length > 0) {\n    var _iterator17 = _createForOfIteratorHelper(hooks),\n        _step17;\n\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var hook = _step17.value;\n        hook.method(data, hook.data);\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  }\n};\n/** Runs insertText hooks */\n\n\nSvg.prototype.insertText = function (text) {\n  if (this.hooks.insertText.length > 0) {\n    var _iterator18 = _createForOfIteratorHelper(this.hooks.insertText),\n        _step18;\n\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var hook = _step18.value;\n        text = hook.method(this.pattern.settings.locale, text, hook.data);\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  }\n\n  return text;\n};\n/** Renders a draft object as SVG */\n\n\nSvg.prototype.render = function (pattern) {\n  this.idPrefix = pattern.settings.idPrefix;\n  this.runHooks('preRender');\n\n  if (!pattern.settings.embed) {\n    this.attributes.add('width', round(pattern.width) + 'mm');\n    this.attributes.add('height', round(pattern.height) + 'mm');\n  }\n\n  this.attributes.add('viewBox', \"0 0 \".concat(pattern.width, \" \").concat(pattern.height));\n  this.head = this.renderHead();\n  this.tail = this.renderTail();\n  this.svg = '';\n  this.layout = {}; // Reset layout\n\n  for (var partId in pattern.parts) {\n    var part = pattern.parts[partId];\n\n    if (part.render) {\n      var partSvg = this.renderPart(part);\n      this.layout[partId] = {\n        svg: partSvg,\n        transform: part.attributes.getAsArray('transform')\n      };\n      this.svg += this.openGroup(\"\".concat(this.idPrefix, \"part-\").concat(partId), part.attributes);\n      this.svg += partSvg;\n      this.svg += this.closeGroup();\n    }\n  }\n\n  this.svg = this.prefix + this.renderSvgTag() + this.head + this.svg + this.tail;\n  this.runHooks('postRender');\n  return this.svg;\n};\n/** Renders SVG head section */\n\n\nSvg.prototype.renderHead = function () {\n  var svg = this.renderStyle();\n  svg += this.renderScript();\n  svg += this.renderDefs();\n  svg += this.openGroup(this.idPrefix + 'container');\n  return svg;\n};\n/** Renders SVG closing section */\n\n\nSvg.prototype.renderTail = function () {\n  var svg = '';\n  svg += this.closeGroup();\n  svg += this.nl() + '</svg>';\n  return svg;\n};\n/** Returns SVG code for the opening SVG tag */\n\n\nSvg.prototype.renderSvgTag = function () {\n  var svg = '<svg';\n  this.indent();\n  svg += this.nl() + this.attributes.render();\n  this.outdent();\n  svg += this.nl() + '>' + this.nl();\n  return svg;\n};\n/** Returns SVG code for the style block */\n\n\nSvg.prototype.renderStyle = function () {\n  var svg = '<style type=\"text/css\"> <![CDATA[ ';\n  this.indent();\n  svg += this.nl() + this.style;\n  this.outdent();\n  svg += this.nl() + ']]>' + this.nl() + '</style>' + this.nl();\n  return svg;\n};\n/** Returns SVG code for the script block */\n\n\nSvg.prototype.renderScript = function () {\n  var svg = '<script type=\"text/javascript\"> <![CDATA[';\n  this.indent();\n  svg += this.nl() + this.script;\n  this.outdent();\n  svg += this.nl() + ']]>' + this.nl() + '</script>' + this.nl();\n  return svg;\n};\n/** Returns SVG code for the defs block */\n\n\nSvg.prototype.renderDefs = function () {\n  var svg = '<defs>';\n  this.indent();\n  svg += this.nl() + this.defs;\n  this.outdent();\n  svg += this.nl() + '</defs>' + this.nl();\n  return svg;\n};\n/** Returns SVG code for a Part object */\n\n\nSvg.prototype.renderPart = function (part) {\n  var svg = '';\n\n  for (var key in part.paths) {\n    var path = part.paths[key];\n    if (path.render) svg += this.renderPath(path);\n  }\n\n  for (var _key2 in part.points) {\n    if (part.points[_key2].attributes.get('data-text')) {\n      svg += this.renderText(part.points[_key2]);\n    }\n\n    if (part.points[_key2].attributes.get('data-circle')) {\n      svg += this.renderCircle(part.points[_key2]);\n    }\n  }\n\n  for (var _key3 in part.snippets) {\n    var snippet = part.snippets[_key3];\n    svg += this.renderSnippet(snippet, part);\n  }\n\n  return svg;\n};\n/** Returns SVG code for a Path object */\n\n\nSvg.prototype.renderPath = function (path) {\n  if (!path.attributes.get('id')) path.attributes.add('id', this.idPrefix + this.getId());\n  path.attributes.set('d', path.asPathstring());\n  return \"\".concat(this.nl(), \"<path \").concat(path.attributes.render(), \" />\").concat(this.renderPathText(path));\n};\n\nSvg.prototype.renderPathText = function (path) {\n  var text = path.attributes.get('data-text');\n  if (!text) return '';else this.text = this.insertText(text);\n  var attributes = path.attributes.renderIfPrefixIs('data-text-'); // Sadly aligning text along a patch can't be done in CSS only\n\n  var offset = '';\n  var align = path.attributes.get('data-text-class');\n  if (align && align.indexOf('center') > -1) offset = ' startOffset=\"50%\" ';else if (align && align.indexOf('right') > -1) offset = ' startOffset=\"100%\" ';\n  var svg = this.nl() + '<text>';\n  this.indent();\n  svg += \"<textPath xlink:href=\\\"#\".concat(path.attributes.get('id'), \"\\\" \").concat(offset, \"><tspan \").concat(attributes, \">\").concat(this.escapeText(this.text), \"</tspan></textPath>\");\n  this.outdent();\n  svg += this.nl() + '</text>';\n  return svg;\n};\n\nSvg.prototype.renderText = function (point) {\n  var text = point.attributes.getAsArray('data-text');\n\n  if (text !== false) {\n    var joint = '';\n\n    var _iterator19 = _createForOfIteratorHelper(text),\n        _step19;\n\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var string = _step19.value;\n        this.text = this.insertText(string);\n        joint += this.text + ' ';\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n\n    this.text = this.insertText(joint);\n  }\n\n  point.attributes.set('data-text-x', round(point.x));\n  point.attributes.set('data-text-y', round(point.y));\n  var lineHeight = point.attributes.get('data-text-lineheight') || 12;\n  point.attributes.remove('data-text-lineheight');\n  var svg = \"\".concat(this.nl(), \"<text \").concat(point.attributes.renderIfPrefixIs('data-text-'), \">\");\n  this.indent(); // Multi-line text?\n\n  if (this.text.indexOf('\\n') !== -1) {\n    var lines = this.text.split('\\n');\n    svg += \"<tspan>\".concat(lines.shift(), \"</tspan>\");\n\n    var _iterator20 = _createForOfIteratorHelper(lines),\n        _step20;\n\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var line = _step20.value;\n        svg += \"<tspan x=\\\"\".concat(round(point.x), \"\\\" dy=\\\"\").concat(lineHeight, \"\\\">\").concat(line, \"</tspan>\");\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n  } else {\n    svg += \"<tspan>\".concat(this.escapeText(this.text), \"</tspan>\");\n  }\n\n  this.outdent();\n  svg += this.nl() + '</text>';\n  return svg;\n};\n\nSvg.prototype.escapeText = function (text) {\n  return text.replace('\"', '&#8220;');\n};\n\nSvg.prototype.renderCircle = function (point) {\n  return \"<circle cx=\\\"\".concat(round(point.x), \"\\\" cy=\\\"\").concat(round(point.y), \"\\\" r=\\\"\").concat(point.attributes.get('data-circle'), \"\\\" \").concat(point.attributes.renderIfPrefixIs('data-circle-'), \"></circle>\");\n};\n/** Returns SVG code for a snippet */\n\n\nSvg.prototype.renderSnippet = function (snippet, part) {\n  var x = round(snippet.anchor.x);\n  var y = round(snippet.anchor.y);\n  var scale = snippet.attributes.get('data-scale');\n\n  if (scale) {\n    snippet.attributes.add('transform', \"translate(\".concat(x, \", \").concat(y, \")\"));\n    snippet.attributes.add('transform', \"scale(\".concat(scale, \")\"));\n    snippet.attributes.add('transform', \"translate(\".concat(x * -1, \", \").concat(y * -1, \")\"));\n  }\n\n  var rotate = snippet.attributes.get('data-rotate');\n\n  if (rotate) {\n    snippet.attributes.add('transform', \"rotate(\".concat(rotate, \", \").concat(x, \", \").concat(y, \")\"));\n  }\n\n  var svg = this.nl();\n  svg += \"<use x=\\\"\".concat(x, \"\\\" y=\\\"\").concat(y, \"\\\" \");\n  svg += \"xlink:href=\\\"#\".concat(snippet.def, \"\\\" \").concat(snippet.attributes.render(), \">\");\n  svg += '</use>';\n  return svg;\n};\n/** Returns SVG code to open a group */\n\n\nSvg.prototype.openGroup = function (id) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var svg = this.nl() + this.nl();\n  svg += \"<!-- Start of group #\".concat(id, \" -->\");\n  svg += this.nl();\n  svg += \"<g id=\\\"\".concat(id, \"\\\"\");\n  if (attributes) svg += \" \".concat(attributes.render());\n  svg += '>';\n  this.indent();\n  this.openGroups.push(id);\n  return svg;\n};\n/** Returns SVG code to close a group */\n\n\nSvg.prototype.closeGroup = function () {\n  this.outdent();\n  return \"\".concat(this.nl(), \"</g>\").concat(this.nl(), \"<!-- end of group #\").concat(this.openGroups.pop(), \" -->\");\n};\n/** Returns a linebreak + identation */\n\n\nSvg.prototype.nl = function () {\n  return '\\n' + this.tab();\n};\n/** Returns indentation */\n\n\nSvg.prototype.tab = function () {\n  var space = '';\n\n  for (var i = 0; i < this.tabs; i++) {\n    space += '  ';\n  }\n\n  return space;\n};\n/** Increases indentation by 1 */\n\n\nSvg.prototype.indent = function () {\n  this.tabs += 1;\n};\n/** Decreases indentation by 1 */\n\n\nSvg.prototype.outdent = function () {\n  this.tabs -= 1;\n};\n/** Returns an unused ID */\n\n\nSvg.prototype.getId = function () {\n  this.freeId += 1;\n  return '' + this.freeId;\n};\n/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/\n\n\nvar GrowingPacker$1 = function GrowingPacker$1() {};\n\nGrowingPacker$1.prototype = {\n  fit: function fit(blocks) {\n    var n,\n        node,\n        block,\n        len = blocks.length,\n        fit;\n    var width = len > 0 ? blocks[0].width : 0;\n    var height = len > 0 ? blocks[0].height : 0;\n    this.root = {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height\n    };\n\n    for (n = 0; n < len; n++) {\n      block = blocks[n];\n\n      if (node = this.findNode(this.root, block.width, block.height)) {\n        fit = this.splitNode(node, block.width, block.height);\n        block.x = fit.x;\n        block.y = fit.y;\n      } else {\n        fit = this.growNode(block.width, block.height);\n        block.x = fit.x;\n        block.y = fit.y;\n      }\n    }\n  },\n  findNode: function findNode(root, width, height) {\n    if (root.used) return this.findNode(root.right, width, height) || this.findNode(root.down, width, height);else if (width <= root.width && height <= root.height) return root;else return null;\n  },\n  splitNode: function splitNode(node, width, height) {\n    node.used = true;\n    node.down = {\n      x: node.x,\n      y: node.y + height,\n      width: node.width,\n      height: node.height - height\n    };\n    node.right = {\n      x: node.x + width,\n      y: node.y,\n      width: node.width - width,\n      height: height\n    };\n    return node;\n  },\n  growNode: function growNode(width, height) {\n    var canGrowDown = width <= this.root.width;\n    var canGrowRight = height <= this.root.height;\n    var shouldGrowRight = canGrowRight && this.root.height >= this.root.width + width; // attempt to keep square-ish by growing right when height is much greater than width\n\n    var shouldGrowDown = canGrowDown && this.root.width >= this.root.height + height; // attempt to keep square-ish by growing down  when width  is much greater than height\n\n    if (shouldGrowRight) return this.growRight(width, height);else if (shouldGrowDown) return this.growDown(width, height);else if (canGrowRight) return this.growRight(width, height);else if (canGrowDown) return this.growDown(width, height);else return null; // need to ensure sensible root starting size to avoid this happening\n  },\n  growRight: function growRight(width, height) {\n    this.root = {\n      used: true,\n      x: 0,\n      y: 0,\n      width: this.root.width + width,\n      height: this.root.height,\n      down: this.root,\n      right: {\n        x: this.root.width,\n        y: 0,\n        width: width,\n        height: this.root.height\n      }\n    };\n    var node;\n    if (node = this.findNode(this.root, width, height)) return this.splitNode(node, width, height);else return null;\n  },\n  growDown: function growDown(width, height) {\n    this.root = {\n      used: true,\n      x: 0,\n      y: 0,\n      width: this.root.width,\n      height: this.root.height + height,\n      down: {\n        x: 0,\n        y: this.root.height,\n        width: this.root.width,\n        height: height\n      },\n      right: this.root\n    };\n    var node;\n    if (node = this.findNode(this.root, width, height)) return this.splitNode(node, width, height);else return null;\n  }\n};\nvar packer_growing = GrowingPacker$1;\nvar GrowingPacker = packer_growing;\n\nvar binPack = function binPack(items, options) {\n  options = options || {};\n  var packer = new GrowingPacker();\n  var inPlace = options.inPlace || false; // Clone the items.\n\n  var newItems = items.map(function (item) {\n    return inPlace ? item : {\n      width: item.width,\n      height: item.height,\n      item: item\n    };\n  });\n  newItems = newItems.sort(function (a, b) {\n    // TODO: check that each actually HAS a width and a height.\n    // Sort based on the size (area) of each block.\n    return b.width * b.height - a.width * a.height;\n  });\n  packer.fit(newItems);\n  var w = newItems.reduce(function (curr, item) {\n    return Math.max(curr, item.x + item.width);\n  }, 0);\n  var h = newItems.reduce(function (curr, item) {\n    return Math.max(curr, item.y + item.height);\n  }, 0);\n  var ret = {\n    width: w,\n    height: h\n  };\n\n  if (!inPlace) {\n    ret.items = newItems;\n  }\n\n  return ret;\n};\n\nfunction Store(raise) {\n  this.data = new Map();\n  this.raise = raise;\n}\n/** Sets a value under index key */\n\n\nStore.prototype.set = function (key, value) {\n  this.data.set(key, value);\n};\n/** Sets a value under index key */\n\n\nStore.prototype.setIfUnset = function (key, value) {\n  if (!this.data.has(key)) this.data.set(key, value);\n};\n/** Gets a value under index key */\n\n\nStore.prototype.get = function (key) {\n  if (!this.data.has(key)) this.raise.warning(\"Tried to access `\".concat(key, \"` in the `store` but it is not set\"));\n  return this.data.get(key);\n};\n\nfunction Pattern() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    options: {}\n  };\n  // Events store and raise methods\n  this.events = {\n    info: [],\n    warning: [],\n    error: [],\n    debug: []\n  };\n  var events = this.events;\n  this.raise = {\n    info: function info(data) {\n      events.info.push(data);\n    },\n    warning: function warning(data) {\n      events.warning.push(data);\n    },\n    error: function error(data) {\n      events.error.push(data);\n    },\n    debug: function debug(data) {\n      events.debug.push(data);\n    }\n  };\n  this.raise.debug(\"New `@freesewing/\".concat(config.name, \":\").concat(config.version, \"` pattern using `@freesewing/core:\").concat(version, \"`\"));\n  this.config = config; // Pattern configuration\n\n  this.width = 0; // Will be set after render\n\n  this.height = 0; // Will be set after render\n\n  this.is = ''; // Will be set when drafting/sampling\n\n  this.debug = true; // Will be set when applying settings\n\n  this.store = new Store(this.raise); // Store for sharing data across parts\n\n  this.parts = {}; // Parts container\n\n  this.hooks = new Hooks(); // Hooks container\n\n  this.Point = Point; // Point constructor\n\n  this.Path = Path; // Path constructor\n\n  this.Snippet = Snippet; // Snippet constructor\n\n  this.Attributes = Attributes; // Attributes constructor\n  // Default settings\n\n  this.settings = {\n    complete: true,\n    idPrefix: 'fs-',\n    locale: 'en',\n    units: 'metric',\n    margin: 2,\n    layout: true,\n    debug: true,\n    options: {}\n  };\n  if (typeof this.config.dependencies === 'undefined') this.config.dependencies = {};\n  if (typeof this.config.inject === 'undefined') this.config.inject = {};\n  if (typeof this.config.hide === 'undefined') this.config.hide = [];\n  this.config.resolvedDependencies = this.resolveDependencies(this.config.dependencies);\n  this.config.draftOrder = this.draftOrder(this.config.resolvedDependencies); // Convert options\n\n  for (var i in config.options) {\n    var option = config.options[i];\n\n    if (typeof option === 'object') {\n      if (typeof option.pct !== 'undefined') this.settings.options[i] = option.pct / 100;else if (typeof option.mm !== 'undefined') this.settings.options[i] = option.mm;else if (typeof option.deg !== 'undefined') this.settings.options[i] = option.deg;else if (typeof option.count !== 'undefined') this.settings.options[i] = option.count;else if (typeof option.bool !== 'undefined') this.settings.options[i] = option.bool;else if (typeof option.dflt !== 'undefined') this.settings.options[i] = option.dflt;else {\n        var err = 'Unknown option type: ' + JSON.stringify(option);\n        this.raise.error(err);\n        throw new Error(err);\n      }\n    } else {\n      this.settings.options[i] = option;\n    }\n  } // Macros\n\n\n  this.macros = {}; // Context object to add to Part closure\n\n  var context = {\n    parts: this.parts,\n    config: this.config,\n    settings: this.settings,\n    store: this.store,\n    macros: this.macros,\n    events: this.events,\n    raise: this.raise\n  }; // Part closure\n\n  this.Part = function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var part = new Part();\n    part.context = context;\n\n    for (var macro in context.macros) {\n      part[macroName(macro)] = context.macros[macro];\n    }\n\n    if (name) part.name = name;\n    return part;\n  };\n} // Merges settings object with this.settings\n\n\nPattern.prototype.apply = function (settings) {\n  if (typeof settings !== 'object') {\n    this.raise.warning('Pattern initialized without any settings');\n    return this;\n  }\n\n  for (var _i6 = 0, _Object$keys = Object.keys(settings); _i6 < _Object$keys.length; _i6++) {\n    var key = _Object$keys[_i6];\n\n    if (Array.isArray(settings[key])) {\n      if (Array.isArray(this.settings[key])) {\n        var _iterator21 = _createForOfIteratorHelper(settings[key]),\n            _step21;\n\n        try {\n          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n            var entry = _step21.value;\n            this.settings[key].push(entry);\n          }\n        } catch (err) {\n          _iterator21.e(err);\n        } finally {\n          _iterator21.f();\n        }\n      } else this.settings[key] = settings[key];\n    } else if (typeof settings[key] === 'object') {\n      this.settings[key] = _objectSpread(_objectSpread({}, this.settings[key]), settings[key]);\n    } else this.settings[key] = settings[key];\n  }\n\n  if (!this.settings.debug) this.debug = false;\n  return this;\n};\n\nPattern.prototype.runHooks = function (hookName) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (data === false) data = this;\n  var hooks = this.hooks[hookName];\n\n  if (hooks.length > 0) {\n    if (this.debug) this.raise.debug(\"Running `\".concat(hookName, \"` hooks\"));\n\n    var _iterator22 = _createForOfIteratorHelper(hooks),\n        _step22;\n\n    try {\n      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n        var hook = _step22.value;\n        hook.method(data, hook.data);\n      }\n    } catch (err) {\n      _iterator22.e(err);\n    } finally {\n      _iterator22.f();\n    }\n  }\n};\n/**\n *  The default draft method with pre- and postDraft hooks\n */\n\n\nPattern.prototype.draft = function () {\n  if (this.is !== 'sample') {\n    this.is = 'draft';\n    if (this.debug) this.raise.debug(\"Drafting pattern\");\n  }\n\n  this.runHooks('preDraft');\n\n  var _iterator23 = _createForOfIteratorHelper(this.config.draftOrder),\n      _step23;\n\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var partName = _step23.value;\n      if (this.debug) this.raise.debug(\"Creating part `\".concat(partName, \"`\"));\n      this.parts[partName] = new this.Part(partName);\n\n      if (typeof this.config.inject[partName] === 'string') {\n        if (this.debug) this.raise.debug(\"Injecting part `\".concat(this.config.inject[partName], \"` into part `\").concat(partName, \"`\"));\n\n        try {\n          this.parts[partName].inject(this.parts[this.config.inject[partName]]);\n        } catch (err) {\n          this.raise.error([\"Could not inject part `\".concat(this.config.inject[partName], \"` into part `\").concat(partName, \"`\"), err]);\n        }\n      }\n\n      if (this.needs(partName)) {\n        var method = 'draft' + capitalize(partName);\n\n        if (typeof this[method] !== 'function') {\n          this.raise.error(\"Method `pattern.\".concat(method, \"` is callable\"));\n          throw new Error('Method \"' + method + '\" on pattern object is not callable');\n        }\n\n        try {\n          this.parts[partName] = this[method](this.parts[partName]);\n        } catch (err) {\n          this.raise.error([\"Unable to draft part `\".concat(partName, \"`\"), err]);\n        }\n\n        if (typeof this.parts[partName] === 'undefined') {\n          this.raise.error(\"Result of `pattern.\".concat(method, \"` was `undefined`. Did you forget to return the `Part` object?\"));\n        }\n\n        try {\n          this.parts[partName].render = this.parts[partName].render === false ? false : this.wants(partName);\n        } catch (err) {\n          this.raise.error([\"Unable to set `render` property on part `\".concat(partName, \"`\"), err]);\n        }\n      } else {\n        if (this.debug) this.raise.debug(\"Part `\".concat(partName, \"` is not needed. Skipping draft and setting render to `false`\"));\n        this.parts[partName].render = false;\n      }\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n\n  this.runHooks('postDraft');\n  return this;\n};\n/**\n * Handles pattern sampling\n */\n\n\nPattern.prototype.sample = function () {\n  if (this.settings.sample.type === 'option') {\n    return this.sampleOption(this.settings.sample.option);\n  } else if (this.settings.sample.type === 'measurement') {\n    return this.sampleMeasurement(this.settings.sample.measurement);\n  } else if (this.settings.sample.type === 'models') {\n    return this.sampleModels(this.settings.sample.models, this.settings.sample.focus || false);\n  }\n};\n\nPattern.prototype.sampleParts = function () {\n  var parts = {};\n  this.settings.complete = false;\n  this.settings.paperless = false;\n  this.draft();\n\n  for (var i in this.parts) {\n    parts[i] = new this.Part();\n    parts[i].render = this.parts[i].render;\n  }\n\n  return parts;\n};\n\nPattern.prototype.sampleRun = function (parts, anchors, run, runs) {\n  var extraClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  this.draft();\n\n  for (var i in this.parts) {\n    var dx = 0;\n    var dy = 0;\n\n    if (this.parts[i].points.anchor) {\n      if (typeof anchors[i] === 'undefined') anchors[i] = this.parts[i].points.anchor;else {\n        if (!anchors[i].sitsOn(this.parts[i].points.anchor)) {\n          dx = this.parts[i].points.anchor.dx(anchors[i]);\n          dy = this.parts[i].points.anchor.dy(anchors[i]);\n        }\n      }\n    }\n\n    for (var j in this.parts[i].paths) {\n      parts[i].paths[j + '_' + run] = this.parts[i].paths[j].clone().attr('style', extraClass === 'sample-focus' ? this.settings.sample ? this.settings.sample.focusStyle || sampleStyle(run, runs) : sampleStyle(run, runs) : sampleStyle(run, runs, this.settings.sample ? this.settings.sample.styles || false : false)).attr('data-sample-run', run).attr('data-sample-runs', runs);\n      if (this.parts[i].points.anchor) parts[i].paths[j + '_' + run] = parts[i].paths[j + '_' + run].translate(dx, dy);\n      if (extraClass !== false) parts[i].paths[j + '_' + run].attributes.add('class', extraClass);\n    }\n  }\n};\n/**\n * Handles option sampling\n */\n\n\nPattern.prototype.sampleOption = function (optionName) {\n  this.is = 'sample';\n  if (this.debug) this.raise.debug(\"Sampling option `\".concat(optionName, \"`\"));\n  this.runHooks('preSample');\n  var step, val;\n  var factor = 1;\n  var anchors = {};\n  var parts = this.sampleParts();\n  var option = this.config.options[optionName];\n\n  if (typeof option.list === 'object') {\n    return this.sampleListOption(optionName);\n  }\n\n  if (typeof option.min === 'undefined' || typeof option.max === 'undefined') {\n    var _min = option * 0.9;\n\n    var _max = option * 1.1;\n\n    option = {\n      min: _min,\n      max: _max\n    };\n  }\n\n  if (typeof option.pct !== 'undefined') factor = 100;\n  val = option.min / factor;\n  step = (option.max / factor - val) / 9;\n\n  for (var run = 1; run < 11; run++) {\n    this.settings.options[optionName] = val;\n    this.sampleRun(parts, anchors, run, 10);\n    val += step;\n  }\n\n  this.parts = parts;\n  this.runHooks('postSample');\n  return this;\n};\n\nPattern.prototype.sampleListOption = function (optionName) {\n  var parts = this.sampleParts();\n  var option = this.config.options[optionName];\n  var anchors = {};\n  var run = 1;\n  var runs = option.list.length;\n\n  var _iterator24 = _createForOfIteratorHelper(option.list),\n      _step24;\n\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var val = _step24.value;\n      this.settings.options[optionName] = val;\n      this.sampleRun(parts, anchors, run, runs);\n      run++;\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n\n  this.parts = parts;\n  return this;\n};\n/**\n * Handles measurement sampling\n */\n\n\nPattern.prototype.sampleMeasurement = function (measurementName) {\n  this.is = 'sample';\n  if (this.debug) this.raise.debug(\"Sampling measurement `\".concat(measurementName, \"`\"));\n  this.runHooks('preSample');\n  var anchors = {};\n  var parts = this.sampleParts();\n  var val = this.settings.measurements[measurementName];\n  if (val === undefined) this.raise.error(\"Cannot sample measurement `\".concat(measurementName, \"` because it's `undefined`\"));\n  var step = val / 50;\n  val = val * 0.9;\n\n  for (var run = 1; run < 11; run++) {\n    this.settings.measurements[measurementName] = val;\n    this.sampleRun(parts, anchors, run, 10);\n    val += step;\n  }\n\n  this.parts = parts;\n  this.runHooks('postSample');\n  return this;\n};\n/**\n * Handles models sampling\n */\n\n\nPattern.prototype.sampleModels = function (models) {\n  var focus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  this.is = 'sample';\n  if (this.debug) this.raise.debug(\"Sampling models\");\n  this.runHooks('preSample');\n  var anchors = {};\n  var parts = this.sampleParts(); // If there's a focus, do it first so it's at the bottom of the SVG\n\n  if (focus) {\n    this.settings.measurements = models[focus];\n    this.sampleRun(parts, anchors, -1, -1, 'sample-focus');\n    delete models[focus];\n  }\n\n  var run = -1;\n  var runs = Object.keys(models).length;\n\n  for (var l in models) {\n    run++;\n    this.settings.measurements = models[l];\n    this.sampleRun(parts, anchors, run, runs);\n  }\n\n  this.parts = parts;\n  this.runHooks('postSample');\n  return this;\n};\n\nPattern.prototype.render = function () {\n  this.svg = new Svg(this);\n  this.svg.hooks = this.hooks;\n  return this.pack().svg.render(this);\n};\n\nPattern.prototype.on = function (hook, method, data) {\n  this.hooks[hook].push({\n    method: method,\n    data: data\n  });\n};\n\nPattern.prototype.use = function (plugin, data) {\n  if (this.debug) this.raise.debug(\"Loaded plugin `\".concat(plugin.name, \":\").concat(plugin.version, \"`\"));\n  if (plugin.hooks) this.loadPluginHooks(plugin, data);\n  if (plugin.macros) this.loadPluginMacros(plugin);\n  return this;\n};\n\nPattern.prototype.useIf = function (plugin, settings) {\n  if (plugin.condition(settings)) {\n    if (this.debug) this.raise.debug(\"Condition met: Loaded plugin `\".concat(plugin.plugin.name, \":\").concat(plugin.plugin.version, \"`\"));\n    this.loadPluginHooks(plugin.plugin, plugin.data);\n  } else {\n    if (this.debug) this.raise.debug(\"Condition not met: Skipped loading plugin `\".concat(plugin.plugin.name, \":\").concat(plugin.plugin.version, \"`\"));\n  }\n\n  return this;\n};\n\nPattern.prototype.loadPluginHooks = function (plugin, data) {\n  for (var _i7 = 0, _Object$keys2 = Object.keys(this.hooks); _i7 < _Object$keys2.length; _i7++) {\n    var hook = _Object$keys2[_i7];\n\n    if (typeof plugin.hooks[hook] === 'function') {\n      this.on(hook, plugin.hooks[hook], data);\n    } else if (Array.isArray(plugin.hooks[hook])) {\n      var _iterator25 = _createForOfIteratorHelper(plugin.hooks[hook]),\n          _step25;\n\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var method = _step25.value;\n          this.on(hook, method, data);\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n  }\n};\n\nPattern.prototype.loadPluginMacros = function (plugin) {\n  for (var macro in plugin.macros) {\n    if (typeof plugin.macros[macro] === 'function') {\n      this.macro(macro, plugin.macros[macro]);\n    }\n  }\n};\n\nPattern.prototype.macro = function (key, method) {\n  this.macros[key] = method;\n};\n/** Packs parts in a 2D space and sets pattern size */\n\n\nPattern.prototype.pack = function () {\n  if (this.events.error.length > 0) {\n    this.raise.warning(\"One or more errors occured. Not packing pattern parts\");\n    return this;\n  }\n\n  var bins = [];\n\n  for (var key in this.parts) {\n    var part = this.parts[key]; // Avoid multiple render calls to cause stacking of transforms\n\n    part.attributes.remove('transform');\n\n    if (part.render) {\n      part.stack();\n      var width = part.bottomRight.x - part.topLeft.x;\n      var height = part.bottomRight.y - part.topLeft.y;\n      if (this.settings.layout === true) bins.push({\n        id: key,\n        width: width,\n        height: height\n      });else {\n        if (this.width < width) this.width = width;\n        if (this.height < height) this.height = height;\n      }\n    }\n  }\n\n  if (this.settings.layout === true) {\n    var size = binPack(bins, {\n      inPlace: true\n    });\n\n    var _iterator26 = _createForOfIteratorHelper(bins),\n        _step26;\n\n    try {\n      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n        var bin = _step26.value;\n        var _part = this.parts[bin.id];\n        if (bin.x !== 0 || bin.y !== 0) _part.attr('transform', \"translate(\".concat(bin.x, \", \").concat(bin.y, \")\"));\n      }\n    } catch (err) {\n      _iterator26.e(err);\n    } finally {\n      _iterator26.f();\n    }\n\n    this.width = size.width;\n    this.height = size.height;\n  } else if (typeof this.settings.layout === 'object') {\n    this.width = this.settings.layout.width;\n    this.height = this.settings.layout.height;\n\n    for (var _i8 = 0, _Object$keys3 = Object.keys(this.settings.layout.parts); _i8 < _Object$keys3.length; _i8++) {\n      var partId = _Object$keys3[_i8];\n      var transforms = this.settings.layout.parts[partId]; // Moving\n\n      if (typeof transforms.move === 'object') {\n        this.parts[partId].attributes.set('transform', 'translate(' + transforms.move.x + ', ' + transforms.move.y + ')');\n      } // Mirrorring\n\n\n      var center = this.parts[partId].topLeft.shiftFractionTowards(this.parts[partId].bottomRight, 0.5);\n      var anchor = {\n        x: 0,\n        y: 0\n      };\n\n      if (transforms.flipX) {\n        var dx = anchor.x - center.x;\n        var transform = \"translate(\".concat(center.x * -1, \", \").concat(center.y * -1, \")\");\n        transform += ' scale(-1, 1)';\n        transform += \" translate(\".concat(center.x * -1 + 2 * dx, \", \").concat(center.y, \")\");\n        this.parts[partId].attributes.add('transform', transform);\n      }\n\n      if (transforms.flipY) {\n        var dy = anchor.y - center.y;\n\n        var _transform = \"translate(\".concat(center.x * -1, \", \").concat(center.y * -1, \")\");\n\n        _transform += ' scale(1, -1)';\n        _transform += \" translate(\".concat(center.x, \", \").concat(center.y * -1 + 2 * dy, \")\");\n        this.parts[partId].attributes.add('transform', _transform);\n      }\n\n      if (transforms.rotate) {\n        var _transform2 = \"rotate(\".concat(transforms.rotate, \", \").concat(center.x - anchor.x, \", \").concat(center.y - anchor.y, \")\");\n\n        this.parts[partId].attributes.add('transform', _transform2);\n      }\n    }\n  }\n\n  return this;\n};\n/** Determines the order to draft parts in, based on dependencies */\n\n\nPattern.prototype.draftOrder = function () {\n  var graph = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.resolveDependencies();\n  var sorted = [];\n  var visited = {};\n  Object.keys(graph).forEach(function visit(name, ancestors) {\n    if (!Array.isArray(ancestors)) ancestors = [];\n    ancestors.push(name);\n    visited[name] = true;\n\n    if (typeof graph[name] !== 'undefined') {\n      graph[name].forEach(function (dep) {\n        if (visited[dep]) return;\n        visit(dep, ancestors.slice(0));\n      });\n    }\n\n    if (sorted.indexOf(name) < 0) sorted.push(name);\n  });\n  return sorted;\n};\n/** Recursively solves part dependencies for a part */\n\n\nPattern.prototype.resolveDependency = function (seen, part) {\n  var graph = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.config.dependencies;\n  var deps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  if (typeof seen[part] === 'undefined') seen[part] = true;\n  if (typeof graph[part] === 'string') graph[part] = [graph[part]];\n\n  if (Array.isArray(graph[part])) {\n    if (graph[part].length === 0) return [];else {\n      if (deps.indexOf(graph[part]) === -1) deps.push.apply(deps, _toConsumableArray(graph[part]));\n\n      var _iterator27 = _createForOfIteratorHelper(graph[part]),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var apart = _step27.value;\n          deps.concat(this.resolveDependency(seen, apart, graph, deps));\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n    }\n  }\n\n  return deps;\n};\n/** Resolves part dependencies into a flat array */\n\n\nPattern.prototype.resolveDependencies = function () {\n  var graph = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.config.dependencies;\n\n  for (var i in this.config.inject) {\n    var dependency = this.config.inject[i];\n    if (typeof this.config.dependencies[i] === 'undefined') this.config.dependencies[i] = dependency;else if (this.config.dependencies[i] !== dependency) {\n      if (typeof this.config.dependencies[i] === 'string') this.config.dependencies[i] = [this.config.dependencies[i], dependency];else if (Array.isArray(this.config.dependencies[i])) {\n        if (this.config.dependencies[i].indexOf(dependency) === -1) this.config.dependencies[i].push(dependency);\n      } else {\n        this.raise.error('Part dependencies should be a string or an array of strings');\n        throw new Error('Part dependencies should be a string or an array of strings');\n      }\n    } // Parts both in the parts and dependencies array trip up the dependency resolver\n\n    if (Array.isArray(this.config.parts)) {\n      var pos = this.config.parts.indexOf(this.config.inject[i]);\n      if (pos !== -1) this.config.parts.splice(pos, 1);\n    }\n  } // Include parts outside the dependency graph\n\n\n  if (Array.isArray(this.config.parts)) {\n    var _iterator28 = _createForOfIteratorHelper(this.config.parts),\n        _step28;\n\n    try {\n      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n        var part = _step28.value;\n        if (typeof this.config.dependencies[part] === 'undefined') this.config.dependencies[part] = [];\n      }\n    } catch (err) {\n      _iterator28.e(err);\n    } finally {\n      _iterator28.f();\n    }\n  }\n\n  var resolved = {};\n  var seen = {};\n\n  for (var _part2 in graph) {\n    resolved[_part2] = this.resolveDependency(seen, _part2, graph);\n  }\n\n  for (var _part3 in seen) {\n    if (typeof resolved[_part3] === 'undefined') resolved[_part3] = [];\n  }\n\n  return resolved;\n};\n/** Determines whether a part is needed\n * This depends on the 'only' setting and the\n * configured dependencies.\n */\n\n\nPattern.prototype.needs = function (partName) {\n  if (typeof this.settings.only === 'undefined' || this.settings.only === false) return true;else if (typeof this.settings.only === 'string') {\n    if (this.settings.only === partName) return true;\n\n    if (Array.isArray(this.config.resolvedDependencies[this.settings.only])) {\n      var _iterator29 = _createForOfIteratorHelper(this.config.resolvedDependencies[this.settings.only]),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var dependency = _step29.value;\n          if (dependency === partName) return true;\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n    }\n  } else if (Array.isArray(this.settings.only)) {\n    var _iterator30 = _createForOfIteratorHelper(this.settings.only),\n        _step30;\n\n    try {\n      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n        var part = _step30.value;\n        if (part === partName) return true;\n\n        var _iterator31 = _createForOfIteratorHelper(this.config.resolvedDependencies[part]),\n            _step31;\n\n        try {\n          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n            var _dependency = _step31.value;\n            if (_dependency === partName) return true;\n          }\n        } catch (err) {\n          _iterator31.e(err);\n        } finally {\n          _iterator31.f();\n        }\n      }\n    } catch (err) {\n      _iterator30.e(err);\n    } finally {\n      _iterator30.f();\n    }\n  }\n  return false;\n};\n/* Checks whether a part is hidden in the config */\n\n\nPattern.prototype.isHidden = function (partName) {\n  if (Array.isArray(this.config.hide)) {\n    if (this.config.hide.indexOf(partName) !== -1) return true;\n  }\n\n  return false;\n};\n/** Determines whether a part is wanted by the user\n * This depends on the 'only' setting\n */\n\n\nPattern.prototype.wants = function (partName) {\n  if (typeof this.settings.only === 'undefined' || this.settings.only === false) {\n    if (this.isHidden(partName)) return false;\n  } else if (typeof this.settings.only === 'string') {\n    if (this.settings.only === partName) return true;\n    return false;\n  } else if (Array.isArray(this.settings.only)) {\n    var _iterator32 = _createForOfIteratorHelper(this.settings.only),\n        _step32;\n\n    try {\n      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n        var part = _step32.value;\n        if (part === partName) return true;\n      }\n    } catch (err) {\n      _iterator32.e(err);\n    } finally {\n      _iterator32.f();\n    }\n\n    return false;\n  }\n\n  return true;\n};\n/** Returns props required to render this pattern through\n *  an external renderer (eg. a React component)\n */\n\n\nPattern.prototype.getRenderProps = function () {\n  // Run pre-render hook\n  var svg = new Svg(this);\n  svg.hooks = this.hooks;\n  svg.runHooks('preRender');\n  this.pack();\n  var props = {\n    svg: svg\n  };\n  props.width = this.width;\n  props.height = this.height;\n  props.settings = this.settings;\n  props.events = {\n    debug: this.events.debug,\n    info: this.events.info,\n    warning: this.events.warning,\n    error: this.events.error\n  };\n  props.parts = {};\n\n  for (var p in this.parts) {\n    if (this.parts[p].render) {\n      props.parts[p] = {\n        paths: this.parts[p].paths,\n        points: this.parts[p].points,\n        snippets: this.parts[p].snippets,\n        attributes: this.parts[p].attributes,\n        height: this.parts[p].height,\n        width: this.parts[p].width,\n        bottomRight: this.parts[p].bottomRight,\n        topLeft: this.parts[p].topLeft\n      };\n    }\n  }\n\n  return props;\n};\n\nfunction Design(config) {\n  var plugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var conditionalPlugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var pattern = function pattern(settings) {\n    Pattern.call(this, config); // Load plugins\n\n    if (Array.isArray(plugins)) {\n      var _iterator33 = _createForOfIteratorHelper(plugins),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var plugin = _step33.value;\n          this.use(plugin);\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n    } else if (plugins) this.use(plugins); // Load conditional plugins\n\n\n    if (Array.isArray(conditionalPlugins)) {\n      var _iterator34 = _createForOfIteratorHelper(conditionalPlugins),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var _plugin = _step34.value;\n          this.useIf(_plugin, settings);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n    } else if (conditionalPlugins.plugin && conditionalPlugins.condition) this.useIf(conditionalPlugins, settings);\n\n    this.apply(settings);\n    return this;\n  }; // Set up inheritance\n\n\n  pattern.prototype = Object.create(Pattern.prototype);\n  pattern.prototype.constructor = pattern; // Make config available without need to instantiate pattern\n\n  pattern.config = config;\n  return pattern;\n}\n\nvar index = {\n  version: version,\n  Design: Design,\n  Pattern: Pattern,\n  Point: Point,\n  Path: Path,\n  Snippet: Snippet,\n  utils: utils,\n  patterns: {},\n  plugins: {}\n};\nexport default index;","map":{"version":3,"sources":["../src/attributes.js","../src/point.js","../../../node_modules/bezier-js/src/utils.js","../../../node_modules/bezier-js/src/poly-bezier.js","../../../node_modules/bezier-js/src/bezier.js","../src/path.js","../src/utils.js","../src/snippet.js","../src/hooks.js","../src/part.js","../src/svg.js","../../../node_modules/bin-pack/packer.growing.js","../../../node_modules/bin-pack/index.js","../src/store.js","../src/pattern.js","../src/design.js","../src/index.js"],"names":["Attributes","svg","key","css","prefix","prefixLen","props","propKey","clone","JSON","debug","Object","value","configurable","Point","raise","radians","degrees","overwrite","that","dx","dy","Math","rad","radius","angle","x","y","p","abs","cos","sin","acos","sqrt","pow","v","pi","tau","quart","epsilon","nMax","Number","nMin","ZERO","z","utils","Tvalues","Cvalues","arcfn","d","derivativeFn","l","compute","t","points","order","mt","ret","mt2","t2","a","b","c","dCpts","i","computeWithRatios","r","f1","f2","f3","f4","derive","dpoints","list","j","dpt","between","m","approximately","precision","length","len","sum","map","d1","de","d2","te","v2","ts","lerp","v1","pointToString","s","pointsToString","copy","dx1","o","dy1","dx2","dy2","cross","dot","atan2","round","pos","parseFloat","dist","p1","p2","closest","mdist","LUT","mpos","abcratio","n","bottom","top","projectionratio","lli8","nx","x1","y1","x3","y3","ny","lli4","x2","y2","p3","x4","p4","y4","lli","makeline","findbbox","mx","my","MX","MY","sections","bbox","min","mid","max","size","shapeintersections","intersections","a1","s1","a2","s2","l1","l2","iss","makeshape","bpl","back","fpl","forward","start","end","shape","startcap","endcap","getminmax","curve","align","tx","line","ty","roots","aligned","reduce","m1","m2","pa","pb","pc","pd","q","q2","discriminant","mp3","mp33","cosphi","phi","crtr","crt","t1","u1","sd","droots","curvature","k","dd","qdsum","num","dnm","pk","nk","dk","adk","inflections","v3","trm","sq","bboxoverlap","dims","dim","b1","b2","expandbox","_bbox","pairiteration","c1b","c1","c2b","c2","threshold","curveIntersectionThreshold","cc1","cc2","pairs","left","right","pair","results","getccenter","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","_","numberSort","constructor","valueOf","toString","addCurve","offset","args","coords","Array","coordlen","newargs","point","higher","arguments","_3d","idx","step","quadraticFromPoints","abc","Bezier","cubicFromPoints","selen","lx","E","S","ly","bx1","by1","bx2","by2","e1","B","e2","A","nc1","nc2","getUtils","PolyBezier","toSVG","last","setRatios","ratios","verify","print","coordDigest","update","computedirection","getABC","u","um","C","getLUT","steps","on","error","lut","hits","project","ft","get","np","pim","derivative","dderivative","normal","__normal2","__normal3","r1","r2","q1","R","hull","_p","pt","split","result","span","extrema","mfn","overlaps","lbbox","tbbox","nv","simple","n1","n2","pass1","pass2","segment","scale","distanceFn","clockwise","ov","rc","outline","reduced","fcurves","bcurves","alen","tlen","graduated","slen","linearDistanceFunction","fs","fe","bs","be","ls","le","segments","outlineshapes","shapes","intersects","lineIntersects","selfintersects","curveintersects","arcs","errorThreshold","_error","ref","_iterate","t_s","t_e","safety","np1","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e","circles","Path","render","to","type","cp1","cp2","id","path","newPath","name","op","pathOffset","current","topLeft","bottomRight","edges","bb","side","closed","joinPaths","offsetLine","asPath","from","bezier","joint","paths","err","stepsPerMm","thisLen","distance","shiftAlongBezier","next","previous","bbs","lineBoundingBox","curveBoundingBox","bbbbox","minX","maxX","minY","maxY","box","rev","section","edgeCurveAsBezier","curveEdge","val","lineStart","mode","lineEnd","addIntersectionsToArray","linesIntersect","lineIntersectsCurve","pathA","pathB","curvesIntersect","candidates","divided","firstHalf","secondHalf","pointOnLine","pointOnCurve","chunks","firstCandidate","parseInt","lastCandidate","intersection","trimmedStart","trimmedEnd","glue","first","ops","string","slopeA","slopeB","iA","iB","beamsIntersect","lenA","lenB","lenC","lenD","check","pointOnBeam","bz","isect","curveA","fromA","cp1A","cp2A","toA","curveB","fromB","cp1B","cp2B","toB","tvalues","unique","dupe","sort","chorddistance","halfchordlength","chordmidpointx","chordmidpointy","i1","i2","det","beamIntersectsCircle","edge","styles","run","Snippet","preDraft","postDraft","preSample","postSample","preRender","postRender","insertText","Part","self","method","macro","data","hooks","hook","margin","findBasePoint","orig","toPoint","cp1Point","cp2Point","complete","paperless","sa","shorthand","store","units","events","pointsProxy","Reflect","set","pathsProxy","snippetsProxy","measurementsProxy","measurements","optionsProxy","options","pattern","Svg","text","width","part","partSvg","transform","idPrefix","snippet","attributes","lineHeight","lines","rotate","def","space","GrowingPacker","fit","blocks","height","block","node","findNode","root","splitNode","growNode","canGrowDown","canGrowRight","shouldGrowRight","shouldGrowDown","growRight","used","down","growDown","module","packer","inPlace","newItems","item","w","h","Store","config","info","warning","version","locale","layout","option","context","parts","settings","macros","macroName","Pattern","capitalize","extraClass","anchors","sampleStyle","factor","runs","focus","models","plugin","bins","pack","bin","partId","transforms","center","anchor","graph","sorted","visited","ancestors","visit","deps","seen","dependency","resolved","snippets","plugins","conditionalPlugins","Design","patterns"],"mappings":"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","sourcesContent":["function Attributes() {\n  this.list = {}\n}\n\n/** Adds an attribute */\nAttributes.prototype.add = function (name, value) {\n  if (typeof this.list[name] === 'undefined') {\n    this.list[name] = []\n  }\n  this.list[name].push(value)\n\n  return this\n}\n\n/** Sets an attribute, overwriting existing value */\nAttributes.prototype.set = function (name, value) {\n  this.list[name] = [value]\n\n  return this\n}\n\n/** Removes an attribute */\nAttributes.prototype.remove = function (name) {\n  delete this.list[name]\n\n  return this\n}\n\n/** Retrieves an attribute */\nAttributes.prototype.get = function (name) {\n  if (typeof this.list[name] === 'undefined') return false\n  else return this.list[name].join(' ')\n}\n\n/** Retrieves an attribute as array*/\nAttributes.prototype.getAsArray = function (name) {\n  if (typeof this.list[name] === 'undefined') return false\n  else return this.list[name]\n}\n\n/** Returns SVG code for attributes */\nAttributes.prototype.render = function () {\n  let svg = ''\n  for (let key in this.list) {\n    svg += ` ${key}=\"${this.list[key].join(' ')}\"`\n  }\n\n  return svg\n}\n\n/** Returns CSS code for attributes */\nAttributes.prototype.renderAsCss = function () {\n  let css = ''\n  for (let key in this.list) {\n    css += ` ${key}:${this.list[key].join(' ')};`\n  }\n\n  return css\n}\n\n/** Returns SVG code for attributes with a fiven prefix\n * typically used for data-text*/\nAttributes.prototype.renderIfPrefixIs = function (prefix = '') {\n  let svg = ''\n  let prefixLen = prefix.length\n  for (let key in this.list) {\n    if (key.substr(0, prefixLen) === prefix) {\n      svg += ` ${key.substr(prefixLen)}=\"${this.list[key].join(' ')}\"`\n    }\n  }\n\n  return svg\n}\n\n/** Returns a props object for attributes with a fiven prefix\n * typically used for data-text*/\nAttributes.prototype.asPropsIfPrefixIs = function (prefix = '') {\n  let props = {}\n  let prefixLen = prefix.length\n  for (let key in this.list) {\n    if (key.substr(0, prefixLen) === prefix) {\n      let propKey = key.substr(prefixLen)\n      if (propKey === 'class') propKey = 'className'\n      props[propKey] = this.get(key)\n    }\n  }\n\n  return props\n}\n\n/** Returns a deep copy of this */\nAttributes.prototype.clone = function () {\n  let clone = new Attributes()\n  clone.list = JSON.parse(JSON.stringify(this.list))\n\n  return clone\n}\n\nexport default Attributes\n","import Attributes from './attributes'\n\nfunction Point(x, y, debug = false) {\n  this.x = x\n  this.y = y\n  this.attributes = new Attributes()\n  Object.defineProperty(this, 'debug', { value: debug, configurable: true })\n}\n\n/** Adds the raise method for a path not created through the proxy **/\nPoint.prototype.withRaise = function (raise = false) {\n  if (raise) Object.defineProperty(this, 'raise', { value: raise })\n\n  return this\n}\n\n/** Debug method to validate point data **/\nPoint.prototype.check = function () {\n  if (typeof this.x !== 'number') this.raise.warning('X value of `Point` is not a number')\n  if (typeof this.y !== 'number') this.raise.warning('Y value of `Point` is not a number')\n}\n\n/** Radians to degrees */\nPoint.prototype.rad2deg = function (radians) {\n  return radians * 57.29577951308232\n}\n\n/** Degrees to radians */\nPoint.prototype.deg2rad = function (degrees) {\n  return degrees / 57.29577951308232\n}\n\n/** Adds an attribute. This is here to make this call chainable in assignment */\nPoint.prototype.attr = function (name, value, overwrite = false) {\n  if (this.debug) this.check()\n  if (overwrite) this.attributes.set(name, value)\n  else this.attributes.add(name, value)\n\n  return this\n}\n\n/** Returns the distance between this point and that point */\nPoint.prototype.dist = function (that) {\n  if (this.debug) {\n    this.check()\n    that.check()\n  }\n  let dx = this.x - that.x\n  let dy = this.y - that.y\n\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2))\n}\n\n/** Returns slope of a line made by this point and that point */\nPoint.prototype.slope = function (that) {\n  if (this.debug) {\n    this.check()\n    that.check()\n  }\n  return (that.y - this.y) / (that.x - this.x)\n}\n\n/** Returns the x-delta between this point and that point */\nPoint.prototype.dx = function (that) {\n  if (this.debug) {\n    this.check()\n    that.check()\n  }\n  return that.x - this.x\n}\n\n/** Returns the y-delta between this point and that point */\nPoint.prototype.dy = function (that) {\n  if (this.debug) {\n    this.check()\n    that.check()\n  }\n  return that.y - this.y\n}\n\n/** Returns the angle between this point and that point */\nPoint.prototype.angle = function (that) {\n  if (this.debug) {\n    this.check()\n    that.check()\n  }\n  let rad = Math.atan2(-1 * this.dy(that), this.dx(that))\n  while (rad < 0) rad += 2 * Math.PI\n\n  return this.rad2deg(rad)\n}\n\n/** Rotate this point deg around that point */\nPoint.prototype.rotate = function (deg, that) {\n  if (this.debug) {\n    this.check()\n    that.check()\n    if (typeof deg !== 'number')\n      this.raise.warning('Called `Point.rotate(deg,that)` but `deg` is not a number')\n    if (that instanceof Point !== true)\n      this.raise.warning('Called `Point.rotate(deg,that)` but `that` is not a `Point` object')\n  }\n  let radius = this.dist(that)\n  let angle = this.angle(that)\n  let x = that.x + radius * Math.cos(this.deg2rad(angle + deg)) * -1\n  let y = that.y + radius * Math.sin(this.deg2rad(angle + deg))\n\n  return new Point(x, y, this.debug).withRaise(this.raise)\n}\n\n/** returns an identical copy of this point */\nPoint.prototype.copy = function () {\n  if (this.debug) this.check()\n  return new Point(this.x, this.y, this.debug).withRaise(this.raise)\n}\n\n/** Mirrors this point around X value of that point */\nPoint.prototype.flipX = function (that = false) {\n  if (this.debug) {\n    this.check()\n    if (that) {\n      if (that instanceof Point !== true)\n        this.raise.warning('Called `Point.rotate(deg,that)` but `that` is not a `Point` object')\n      that.check()\n    }\n  }\n  if (that === false || that.x === 0)\n    return new Point(this.x * -1, this.y, this.debug).withRaise(this.raise)\n  else return new Point(that.x + this.dx(that), this.y, this.debug).withRaise(this.raise)\n}\n\n/** Mirrors this point around Y value of that point */\nPoint.prototype.flipY = function (that = false) {\n  if (this.debug) {\n    this.check()\n    if (that) {\n      if (that instanceof Point !== true)\n        this.raise.warning('Called `Point.flipY(that)` but `that` is not a `Point` object')\n      that.check()\n    }\n  }\n  if (that === false || that.y === 0)\n    return new Point(this.x, this.y * -1, this.debug).withRaise(this.raise)\n  else return new Point(this.x, that.y + this.dy(that), this.debug).withRaise(this.raise)\n}\n\n/** Shifts this point distance in the deg direction */\nPoint.prototype.shift = function (deg, distance) {\n  if (this.debug) {\n    this.check()\n    if (typeof distance !== 'number')\n      this.raise.warning('Called `Point.shift` but `distance` is not a number')\n  }\n  let p = this.copy()\n  p.x += distance\n\n  return p.rotate(deg, this)\n}\n\n/** Shifts this point distance in the direction of that point */\nPoint.prototype.shiftTowards = function (that, distance) {\n  if (this.debug) {\n    if (typeof distance !== 'number')\n      this.raise.warning('Called `Point.shiftTowards` but `distance` is not a number')\n    if (that instanceof Point !== true)\n      this.raise.warning(\n        'Called `Point.shiftTowards(that, distance)` but `that` is not a `Point` object'\n      )\n    this.check()\n    that.check()\n  }\n  if (this.debug) this.check()\n  return this.shift(this.angle(that), distance)\n}\n\n/** Checks whether this has the same coordinates as that */\nPoint.prototype.sitsOn = function (that) {\n  if (this.debug) {\n    if (that instanceof Point !== true)\n      this.raise.warning('Called `Point.sitsOn(that)` but `that` is not a `Point` object')\n    this.check()\n    that.check()\n  }\n  if (this.x === that.x && this.y === that.y) return true\n  else return false\n}\n\n/** Checks whether this has roughly the same coordinates as that */\nPoint.prototype.sitsRoughlyOn = function (that) {\n  if (this.debug) {\n    if (that instanceof Point !== true)\n      this.raise.warning('Called `Point.sitsRoughlyOn(that)` but `that` is not a `Point` object')\n    this.check()\n    that.check()\n  }\n  if (Math.round(this.x) === Math.round(that.x) && Math.round(this.y) === Math.round(that.y))\n    return true\n  else return false\n}\n\n/** Shifts this point fraction of the distance towards that point */\nPoint.prototype.shiftFractionTowards = function (that, fraction) {\n  if (this.debug) {\n    if (that instanceof Point !== true)\n      this.raise.warning(\n        'Called `Point.shiftFractionTowards(that, fraction)` but `that` is not a `Point` object'\n      )\n    if (typeof fraction !== 'number')\n      this.raise.warning('Called `Point.shiftFractionTowards` but `fraction` is not a number')\n    this.check()\n    that.check()\n  }\n  return this.shiftTowards(that, this.dist(that) * fraction)\n}\n\n/** Shifts this point distance beyond that point */\nPoint.prototype.shiftOutwards = function (that, distance) {\n  if (this.debug) {\n    if (that instanceof Point !== true)\n      this.raise.warning(\n        'Called `Point.shiftOutwards(that, distance)` but `that` is not a `Point` object'\n      )\n    if (typeof distance !== 'number')\n      this.raise.warning(\n        'Called `Point.shiftOutwards(that, distance)` but `distance` is not a number'\n      )\n    this.check()\n    that.check()\n  }\n  return this.shiftTowards(that, this.dist(that) + distance)\n}\n\n/** Returns a deep copy of this */\nPoint.prototype.clone = function () {\n  if (this.debug) this.check()\n  let clone = new Point(this.x, this.y, this.debug).withRaise(this.raise)\n  clone.attributes = this.attributes.clone()\n\n  return clone\n}\n\n/** Applies a translate transform */\nPoint.prototype.translate = function (x, y) {\n  if (this.debug) {\n    this.check()\n    if (typeof x !== 'number')\n      this.raise.warning('Called `Point.translate(x,y)` but `x` is not a number')\n    if (typeof y !== 'number')\n      this.raise.warning('Called `Point.translate(x,y)` but `y` is not a number')\n  }\n  let p = this.copy()\n  p.x += x\n  p.y += y\n\n  return p\n}\n\nexport default Point\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    this._linear = !aligned.some((p) => abs(p.y) > 0.0001);\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n    // move all points by distance 'd' wrt the origin 'o'\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === \"undefined\" ? d1 : d2;\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n      slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import Attributes from './attributes'\nimport Point from './point'\nimport { Bezier } from 'bezier-js'\nimport {\n  linesIntersect,\n  lineIntersectsCurve,\n  curvesIntersect,\n  pointOnLine,\n  pointOnCurve,\n  curveEdge,\n  round,\n} from './utils'\n\nfunction Path(debug = false) {\n  this.render = true\n  this.topLeft = false\n  this.bottomRight = false\n  this.attributes = new Attributes()\n  this.ops = []\n  Object.defineProperty(this, 'debug', { value: debug, configurable: true })\n}\n\n/** Adds the raise method for a path not created through the proxy **/\nPath.prototype.withRaise = function (raise = false) {\n  if (raise) Object.defineProperty(this, 'raise', { value: raise })\n\n  return this\n}\n\n/** Chainable way to set the render property */\nPath.prototype.setRender = function (render = true) {\n  if (render) this.render = true\n  else this.render = false\n  if (this.debug) this.raise.debug('Setting `Path.render` to ' + (render ? '`true`' : '`false`'))\n\n  return this\n}\n\n/** Adds a move operation to Point to */\nPath.prototype.move = function (to) {\n  if (this.debug && to instanceof Point !== true)\n    this.raise.warning('Called `Path.rotate(to)` but `to` is not a `Point` object')\n  this.ops.push({ type: 'move', to })\n\n  return this\n}\n\n/** Adds a line operation to Point to */\nPath.prototype.line = function (to) {\n  if (this.debug && to instanceof Point !== true)\n    this.raise.warning('Called `Path.line(to)` but `to` is not a `Point` object')\n  this.ops.push({ type: 'line', to })\n\n  return this\n}\n\n/** Adds a curve operation via cp1 & cp2 to Point to */\nPath.prototype.curve = function (cp1, cp2, to) {\n  if (this.debug) {\n    if (to instanceof Point !== true)\n      this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `to` is not a `Point` object')\n    if (cp1 instanceof Point !== true)\n      this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `cp1` is not a `Point` object')\n    if (cp2 instanceof Point !== true)\n      this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `cp2` is not a `Point` object')\n  }\n  this.ops.push({ type: 'curve', cp1, cp2, to })\n\n  return this\n}\n\n/** Adds a curve operation without cp1 via cp2 to Point to */\nPath.prototype._curve = function (cp2, to) {\n  if (this.debug) {\n    if (to instanceof Point !== true)\n      this.raise.warning('Called `Path._curve(cp2, to)` but `to` is not a `Point` object')\n    if (cp2 instanceof Point !== true)\n      this.raise.warning('Called `Path._curve(cp2, to)` but `cp2` is not a `Point` object')\n  }\n  let cp1 = this.ops.slice(-1).pop().to\n  this.ops.push({ type: 'curve', cp1, cp2, to })\n\n  return this\n}\n\n/** Adds a curve operation via cp1 with no cp2 to Point to */\nPath.prototype.curve_ = function (cp1, to) {\n  if (this.debug) {\n    if (to instanceof Point !== true)\n      this.raise.warning('Called `Path.curve_(cp1, to)` but `to` is not a `Point` object')\n    if (cp1 instanceof Point !== true)\n      this.raise.warning('Called `Path.curve_(cp1, to)` but `cp2` is not a `Point` object')\n  }\n  let cp2 = to.copy()\n  this.ops.push({ type: 'curve', cp1, cp2, to })\n\n  return this\n}\n\n/** Adds a close operation */\nPath.prototype.close = function () {\n  this.ops.push({ type: 'close' })\n\n  return this\n}\n\n/** Adds a noop operation */\nPath.prototype.noop = function (id = false) {\n  this.ops.push({ type: 'noop', id })\n\n  return this\n}\n\n/** Replace a noop operation with the ops from path */\nPath.prototype.insop = function (noopId, path) {\n  if (this.debug) {\n    if (!noopId)\n      this.raise.warning('Called `Path.insop(noopId, path)` but `noopId` is undefined or false')\n    if (path instanceof Path !== true)\n      this.raise.warning('Called `Path.insop(noopId, path) but `path` is not a `Path` object')\n  }\n  let newPath = this.clone()\n  for (let i in newPath.ops) {\n    if (newPath.ops[i].type === 'noop' && newPath.ops[i].id === noopId) {\n      newPath.ops = newPath.ops\n        .slice(0, i)\n        .concat(path.ops)\n        .concat(newPath.ops.slice(Number(i) + 1))\n    }\n  }\n\n  return newPath\n}\n\n/** Adds an attribute. This is here to make this call chainable in assignment */\nPath.prototype.attr = function (name, value, overwrite = false) {\n  if (this.debug) {\n    if (!name)\n      this.raise.warning(\n        'Called `Path.attr(name, value, overwrite=false)` but `name` is undefined or false'\n      )\n    if (typeof value === 'undefined')\n      this.raise.warning(\n        'Called `Path.attr(name, value, overwrite=false)` but `value` is undefined'\n      )\n    if (overwrite)\n      this.raise.debug(\n        `Overwriting \\`Path.attribute.${name}\\` with ${value} (was: ${this.attributes.get(name)})`\n      )\n  }\n  if (overwrite) this.attributes.set(name, value)\n  else this.attributes.add(name, value)\n\n  return this\n}\n\n/** Returns SVG pathstring for this path */\nPath.prototype.asPathstring = function () {\n  let d = ''\n  for (let op of this.ops) {\n    switch (op.type) {\n      case 'move':\n        d += `M ${round(op.to.x)},${round(op.to.y)}`\n        break\n      case 'line':\n        d += ` L ${round(op.to.x)},${round(op.to.y)}`\n        break\n      case 'curve':\n        d += ` C ${round(op.cp1.x)},${round(op.cp1.y)} ${round(op.cp2.x)},${round(\n          op.cp2.y\n        )} ${round(op.to.x)},${round(op.to.y)}`\n        break\n      case 'close':\n        d += ' z'\n        break\n    }\n  }\n\n  return d\n}\n\n/** Returns offset of this path as a new path */\nPath.prototype.offset = function (distance) {\n  if (typeof distance !== 'number')\n    this.raise.error('Called `Path.offset(distance)` but `distance` is not a number')\n  return pathOffset(this, distance, this.raise)\n}\n\n/** Returns the length of this path */\nPath.prototype.length = function () {\n  let current, start\n  let length = 0\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    if (op.type === 'move') {\n      start = op.to\n    } else if (op.type === 'line') {\n      length += current.dist(op.to)\n    } else if (op.type === 'curve') {\n      length += new Bezier(\n        { x: current.x, y: current.y },\n        { x: op.cp1.x, y: op.cp1.y },\n        { x: op.cp2.x, y: op.cp2.y },\n        { x: op.to.x, y: op.to.y }\n      ).length()\n    } else if (op.type === 'close') {\n      length += current.dist(start)\n    }\n    if (op.to) current = op.to\n  }\n\n  return length\n}\n\n/** Returns the startpoint of the path */\nPath.prototype.start = function () {\n  if (this.ops.length < 1 || typeof this.ops[0].to === 'undefined')\n    this.raise.error('Called `Path.start()` but this path has no drawing operations')\n  return this.ops[0].to\n}\n\n/** Returns the endpoint of the path */\nPath.prototype.end = function () {\n  if (this.ops.length < 1)\n    this.raise.error('Called `Path.end()` but this path has no drawing operations')\n  let op = this.ops[this.ops.length - 1]\n\n  if (op.type === 'close') return this.start()\n  else return op.to\n}\n\n/** Finds the bounding box of a path */\nPath.prototype.boundary = function () {\n  if (this.topLeft) return this // Cached\n\n  let current\n  let topLeft = new Point(Infinity, Infinity)\n  let bottomRight = new Point(-Infinity, -Infinity)\n  let edges = []\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    if (op.type === 'move' || op.type === 'line') {\n      if (op.to.x < topLeft.x) {\n        topLeft.x = op.to.x\n        edges['leftOp'] = i\n      }\n      if (op.to.y < topLeft.y) {\n        topLeft.y = op.to.y\n        edges['topOp'] = i\n      }\n      if (op.to.x > bottomRight.x) {\n        bottomRight.x = op.to.x\n        edges['rightOp'] = i\n      }\n      if (op.to.y > bottomRight.y) {\n        bottomRight.y = op.to.y\n        edges['bottomOp'] = i\n      }\n    } else if (op.type === 'curve') {\n      let bb = new Bezier(\n        { x: current.x, y: current.y },\n        { x: op.cp1.x, y: op.cp1.y },\n        { x: op.cp2.x, y: op.cp2.y },\n        { x: op.to.x, y: op.to.y }\n      ).bbox()\n      if (bb.x.min < topLeft.x) {\n        topLeft.x = bb.x.min\n        edges['leftOp'] = i\n      }\n      if (bb.y.min < topLeft.y) {\n        topLeft.y = bb.y.min\n        edges['topOp'] = i\n      }\n      if (bb.x.max > bottomRight.x) {\n        bottomRight.x = bb.x.max\n        edges['rightOp'] = i\n      }\n      if (bb.y.max > bottomRight.y) {\n        bottomRight.y = bb.y.max\n        edges['bottomOp'] = i\n      }\n    }\n    if (op.to) current = op.to\n  }\n\n  this.topLeft = topLeft\n  this.bottomRight = bottomRight\n\n  for (let side of ['top', 'left', 'bottom', 'right']) {\n    let s = side + 'Op'\n    this[s] = this.ops[edges[s]]\n    this[s].from = this[s].type === 'move' ? this[s].to : this.ops[edges[s] - 1].to\n  }\n\n  return this\n}\n\n/** Returns a deep copy of this */\nPath.prototype.clone = function () {\n  let clone = new Path(this.debug).withRaise(this.raise).setRender(this.render)\n  if (this.topLeft) clone.topLeft = this.topLeft.clone()\n  else clone.topLeft = false\n  if (this.bottomRight) clone.bottomRight = this.bottomRight.clone()\n  else clone.bottomRight = false\n  clone.attributes = this.attributes.clone()\n  clone.ops = []\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    clone.ops[i] = { type: op.type }\n    if (op.type === 'move' || op.type === 'line') {\n      clone.ops[i].to = op.to.clone()\n    } else if (op.type === 'curve') {\n      clone.ops[i].to = op.to.clone()\n      clone.ops[i].cp1 = op.cp1.clone()\n      clone.ops[i].cp2 = op.cp2.clone()\n    } else if (op.type === 'noop') {\n      clone.ops[i].id = op.id\n    }\n  }\n\n  return clone\n}\n\n/** Joins this with that path, closes them if wanted */\nPath.prototype.join = function (that, closed = false) {\n  if (that instanceof Path !== true)\n    this.raise.error('Called `Path.join(that)` but `that` is not a `Path` object')\n  return joinPaths([this, that], closed, this.raise)\n}\n\n/** Offsets a path by distance */\nfunction pathOffset(path, distance, raise) {\n  let offset = []\n  let current\n  let start = false\n  let closed = false\n  for (let i in path.ops) {\n    let op = path.ops[i]\n    if (op.type === 'line') {\n      let segment = offsetLine(current, op.to, distance, path.debug, path.raise)\n      if (segment) offset.push(segment)\n    } else if (op.type === 'curve') {\n      // We need to avoid a control point sitting on top of start or end\n      // because that will break the offset in bezier-js\n      let cp1, cp2\n      if (current.sitsRoughlyOn(op.cp1)) {\n        cp1 = new Path(path.debug)\n          .withRaise(path.raise)\n          .move(current)\n          .curve(op.cp1, op.cp2, op.to)\n          .shiftAlong(2)\n      } else cp1 = op.cp1\n      if (op.cp2.sitsRoughlyOn(op.to)) {\n        cp2 = new Path(path.debug)\n          .withRaise(path.raise)\n          .move(op.to)\n          .curve(op.cp2, op.cp1, current)\n          .shiftAlong(2)\n      } else cp2 = op.cp2\n      let b = new Bezier(\n        { x: current.x, y: current.y },\n        { x: cp1.x, y: cp1.y },\n        { x: cp2.x, y: cp2.y },\n        { x: op.to.x, y: op.to.y }\n      )\n      for (let bezier of b.offset(distance)) offset.push(asPath(bezier, path.debug, path.raise))\n    } else if (op.type === 'close') closed = true\n    if (op.to) current = op.to\n    if (!start) start = current\n  }\n\n  return joinPaths(offset, closed, raise)\n}\n\n/** Offsets a line by distance */\nfunction offsetLine(from, to, distance, debug = false, raise = false) {\n  if (from.x === to.x && from.y === to.y) return false\n  let angle = from.angle(to) - 90\n\n  return new Path(debug)\n    .withRaise(raise)\n    .move(from.shift(angle, distance))\n    .line(to.shift(angle, distance))\n}\n\n/** Converts a bezier-js instance to a path */\nfunction asPath(bezier, debug = false, raise = false) {\n  return new Path(debug)\n    .withRaise(raise)\n    .move(new Point(bezier.points[0].x, bezier.points[0].y))\n    .curve(\n      new Point(bezier.points[1].x, bezier.points[1].y),\n      new Point(bezier.points[2].x, bezier.points[2].y),\n      new Point(bezier.points[3].x, bezier.points[3].y)\n    )\n}\n\n/** Joins path segments together into one path */\nfunction joinPaths(paths, closed = false, raise = false) {\n  let joint = new Path(paths[0].debug).withRaise(paths[0].raise).move(paths[0].ops[0].to)\n  let current\n  for (let p of paths) {\n    for (let op of p.ops) {\n      if (op.type === 'curve') {\n        joint.curve(op.cp1, op.cp2, op.to)\n      } else if (op.type !== 'close') {\n        // We're using sitsRoughlyOn here to avoid miniscule line segments\n        if (current && !op.to.sitsRoughlyOn(current)) joint.line(op.to)\n      } else {\n        let err = 'Cannot join a closed path with another'\n        joint.raise.error(err)\n        throw new Error(err)\n      }\n      if (op.to) current = op.to\n    }\n  }\n  if (closed) joint.close()\n\n  return joint\n}\n\n/** Returns a point that lies at distance along this */\nPath.prototype.shiftAlong = function (distance, stepsPerMm = 25) {\n  if (typeof distance !== 'number')\n    this.raise.error('Called `Path.shiftAlong(distance)` but `distance` is not a number')\n  let len = 0\n  let current\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    if (op.type === 'line') {\n      let thisLen = op.to.dist(current)\n      if (Math.abs((len + thisLen) - distance) < 0.1) return op.to\n      if (len + thisLen > distance) return current.shiftTowards(op.to, distance - len)\n      len += thisLen\n    } else if (op.type === 'curve') {\n      let bezier = new Bezier(\n        { x: current.x, y: current.y },\n        { x: op.cp1.x, y: op.cp1.y },\n        { x: op.cp2.x, y: op.cp2.y },\n        { x: op.to.x, y: op.to.y }\n      )\n      let thisLen = bezier.length()\n      if (Math.abs((len + thisLen) - distance) < 0.1) return op.to\n      if (len + thisLen > distance) return shiftAlongBezier(distance - len, bezier, thisLen * stepsPerMm)\n      len += thisLen\n    }\n    current = op.to\n  }\n  this.raise.error(\n    `Called \\`Path.shiftAlong(distance)\\` with a \\`distance\\` of \\`${distance}\\` but \\`Path.length()\\` is only \\`${this.length()}\\``\n  )\n}\n\n/** Returns a point that lies at fraction along this */\nPath.prototype.shiftFractionAlong = function (fraction, stepsPerMm = 25) {\n  if (typeof fraction !== 'number')\n    this.raise.error('Called `Path.shiftFractionAlong(fraction)` but `fraction` is not a number')\n  return this.shiftAlong(this.length() * fraction, stepsPerMm)\n}\n\n/** Returns a point that lies at distance along bezier */\nfunction shiftAlongBezier(distance, bezier, steps = 100) {\n  let previous, next, t, thisLen\n  let len = 0\n  for (let i = 0; i <= steps; i++) {\n    t = i / steps\n    next = bezier.get(t)\n    next = new Point(next.x, next.y)\n    if (i > 0) {\n      thisLen = next.dist(previous)\n      if (len + thisLen > distance) return next\n      else len += thisLen\n    }\n    previous = next\n  }\n}\n\n/** Returns a point at the top edge of a bounding box of this */\nPath.prototype.bbox = function () {\n  let bbs = []\n  let current\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    if (op.type === 'line') {\n      bbs.push(lineBoundingBox({ from: current, to: op.to }))\n    } else if (op.type === 'curve') {\n      bbs.push(\n        curveBoundingBox(\n          new Bezier(\n            { x: current.x, y: current.y },\n            { x: op.cp1.x, y: op.cp1.y },\n            { x: op.cp2.x, y: op.cp2.y },\n            { x: op.to.x, y: op.to.y }\n          )\n        )\n      )\n    }\n    if (op.to) current = op.to\n  }\n\n  return bbbbox(bbs)\n}\n\nfunction lineBoundingBox(line) {\n  let from = line.from\n  let to = line.to\n  if (from.x === to.x) {\n    if (from.y < to.y) return { topLeft: from, bottomRight: to }\n    else return { topLeft: to, bottomRight: from }\n  } else if (from.y === to.y) {\n    if (from.x < to.x) return { topLeft: from, bottomRight: to }\n    else return { topLeft: to, bottomRight: from }\n  } else if (from.x < to.x) {\n    if (from.y < to.y) return { topLeft: from, bottomRight: to }\n    else\n      return {\n        topLeft: new Point(from.x, to.y),\n        bottomRight: new Point(to.x, from.y),\n      }\n  } else if (from.x > to.x) {\n    if (from.y < to.y)\n      return {\n        topLeft: new Point(to.x, from.y),\n        bottomRight: new Point(from.x, to.y),\n      }\n    else\n      return {\n        topLeft: new Point(to.x, to.y),\n        bottomRight: new Point(from.x, from.y),\n      }\n  }\n}\n\nfunction curveBoundingBox(curve) {\n  let bb = curve.bbox()\n\n  return {\n    topLeft: new Point(bb.x.min, bb.y.min),\n    bottomRight: new Point(bb.x.max, bb.y.max),\n  }\n}\n\nfunction bbbbox(boxes) {\n  let minX = Infinity\n  let maxX = -Infinity\n  let minY = Infinity\n  let maxY = -Infinity\n  for (let box of boxes) {\n    if (box.topLeft.x < minX) minX = box.topLeft.x\n    if (box.topLeft.y < minY) minY = box.topLeft.y\n    if (box.bottomRight.x > maxX) maxX = box.bottomRight.x\n    if (box.bottomRight.y > maxY) maxY = box.bottomRight.y\n  }\n\n  return { topLeft: new Point(minX, minY), bottomRight: new Point(maxX, maxY) }\n}\n\n/** Returns a reversed version of this */\nPath.prototype.reverse = function () {\n  let sections = []\n  let current\n  let closed = false\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    if (op.type === 'line') {\n      if (!op.to.sitsOn(current))\n        sections.push(new Path(this.debug).withRaise(this.raise).move(op.to).line(current))\n    } else if (op.type === 'curve') {\n      sections.push(\n        new Path(this.debug).withRaise(this.raise).move(op.to).curve(op.cp2, op.cp1, current)\n      )\n    } else if (op.type === 'close') {\n      closed = true\n    }\n    if (op.to) current = op.to\n  }\n  let rev = new Path(this.debug).withRaise(this.raise).move(current)\n  for (let section of sections.reverse()) rev.ops.push(section.ops[1])\n  if (closed) rev.close()\n\n  return rev\n}\n\n/** Returns the point at an edge of this path */\nPath.prototype.edge = function (side) {\n  this.boundary()\n  if (side === 'topLeft') return this.topLeft\n  else if (side === 'bottomRight') return this.bottomRight\n  else if (side === 'topRight') return new Point(this.bottomRight.x, this.topLeft.y)\n  else if (side === 'bottomLeft') return new Point(this.topLeft.x, this.bottomRight.y)\n  else {\n    let s = side + 'Op'\n    if (this[s].type === 'move') return this[s].to\n    else if (this[s].type === 'line') {\n      if (side === 'top') {\n        if (this.topOp.to.y < this.topOp.from.y) return this.topOp.to\n        else return this.topOp.from\n      } else if (side === 'left') {\n        if (this.leftOp.to.x < this.leftOp.from.x) return this.leftOp.to\n        else return this.leftOp.from\n      } else if (side === 'bottom') {\n        if (this.bottomOp.to.y > this.bottomOp.from.y) return this.bottomOp.to\n        else return this.bottomOp.from\n      } else if (side === 'right') {\n        if (this.rightOp.to.x > this.rightOp.from.x) return this.rightOp.to\n        else return this.rightOp.from\n      }\n    } else if (this[s].type === 'curve') {\n      let curve = edgeCurveAsBezier(this[s])\n      return curveEdge(curve, side)\n    }\n  }\n  this.raise.error(`Unable to find \\`Path.edge(side)\\` for side ${side}`)\n}\n\nfunction edgeCurveAsBezier(op) {\n  return new Bezier(\n    { x: op.from.x, y: op.from.y },\n    { x: op.cp1.x, y: op.cp1.y },\n    { x: op.cp2.x, y: op.cp2.y },\n    { x: op.to.x, y: op.to.y }\n  )\n}\n\n/** Divides a path into atomic paths */\nPath.prototype.divide = function () {\n  let paths = []\n  let current, start\n  for (let i in this.ops) {\n    let op = this.ops[i]\n    if (op.type === 'move') {\n      start = op.to\n    } else if (op.type === 'line') {\n      if (!op.to.sitsRoughlyOn(current))\n        paths.push(new Path(this.debug).withRaise(this.raise).move(current).line(op.to))\n    } else if (op.type === 'curve') {\n      paths.push(\n        new Path(this.debug).withRaise(this.raise).move(current).curve(op.cp1, op.cp2, op.to)\n      )\n    } else if (op.type === 'close') {\n      paths.push(new Path(this.debug).withRaise(this.raise).move(current).line(start))\n    }\n    if (op.to) current = op.to\n  }\n\n  return paths\n}\n\n/** Finds intersections between this path and an X value */\nPath.prototype.intersectsX = function (x) {\n  if (typeof x !== 'number')\n    this.raise.error('Called `Path.intersectsX(x)` but `x` is not a number')\n  return this.intersectsAxis(x, 'x')\n}\n\n/** Finds intersections between this path and an Y value */\nPath.prototype.intersectsY = function (y) {\n  if (typeof y !== 'number')\n    this.raise.error('Called `Path.intersectsX(y)` but `y` is not a number')\n  return this.intersectsAxis(y, 'y')\n}\n\n/** Finds intersections between this path and a X or Y value */\nPath.prototype.intersectsAxis = function (val = false, mode) {\n  let intersections = []\n  let lineStart = mode === 'x' ? new Point(val, -100000) : new Point(-10000, val)\n  let lineEnd = mode === 'x' ? new Point(val, 100000) : new Point(100000, val)\n  for (let path of this.divide()) {\n    if (path.ops[1].type === 'line') {\n      addIntersectionsToArray(\n        linesIntersect(path.ops[0].to, path.ops[1].to, lineStart, lineEnd),\n        intersections\n      )\n    } else if (path.ops[1].type === 'curve') {\n      addIntersectionsToArray(\n        lineIntersectsCurve(\n          lineStart,\n          lineEnd,\n          path.ops[0].to,\n          path.ops[1].cp1,\n          path.ops[1].cp2,\n          path.ops[1].to\n        ),\n        intersections\n      )\n    }\n  }\n\n  return intersections\n}\n\n/** Finds intersections between this path and another path */\nPath.prototype.intersects = function (path) {\n  if (this === path)\n    this.raise.error('You called Path.intersects(path)` but `path` and `this` are the same object')\n  let intersections = []\n  for (let pathA of this.divide()) {\n    for (let pathB of path.divide()) {\n      if (pathA.ops[1].type === 'line') {\n        if (pathB.ops[1].type === 'line') {\n          addIntersectionsToArray(\n            linesIntersect(pathA.ops[0].to, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].to),\n            intersections\n          )\n        } else if (pathB.ops[1].type === 'curve') {\n          addIntersectionsToArray(\n            lineIntersectsCurve(\n              pathA.ops[0].to,\n              pathA.ops[1].to,\n              pathB.ops[0].to,\n              pathB.ops[1].cp1,\n              pathB.ops[1].cp2,\n              pathB.ops[1].to\n            ),\n            intersections\n          )\n        }\n      } else if (pathA.ops[1].type === 'curve') {\n        if (pathB.ops[1].type === 'line') {\n          addIntersectionsToArray(\n            lineIntersectsCurve(\n              pathB.ops[0].to,\n              pathB.ops[1].to,\n              pathA.ops[0].to,\n              pathA.ops[1].cp1,\n              pathA.ops[1].cp2,\n              pathA.ops[1].to\n            ),\n            intersections\n          )\n        } else if (pathB.ops[1].type === 'curve') {\n          addIntersectionsToArray(\n            curvesIntersect(\n              pathA.ops[0].to,\n              pathA.ops[1].cp1,\n              pathA.ops[1].cp2,\n              pathA.ops[1].to,\n              pathB.ops[0].to,\n              pathB.ops[1].cp1,\n              pathB.ops[1].cp2,\n              pathB.ops[1].to\n            ),\n            intersections\n          )\n        }\n      }\n    }\n  }\n\n  return intersections\n}\n\nfunction addIntersectionsToArray(candidates, intersections) {\n  if (!candidates) return\n  if (typeof candidates === 'object') {\n    if (typeof candidates.x === 'number') intersections.push(candidates)\n    else {\n      for (let candidate of candidates) intersections.push(candidate)\n    }\n  }\n}\n\n/** Splits path on point, and retuns both halves */\nPath.prototype.split = function (point) {\n  if (point instanceof Point !== true)\n    this.raise.error('Called `Path.split(point)` but `point` is not a `Point` object')\n  let divided = this.divide()\n  let firstHalf = false\n  let secondHalf = false\n  for (let pi = 0; pi < divided.length; pi++) {\n    let path = divided[pi]\n    if (path.ops[1].type === 'line') {\n      if (pointOnLine(path.ops[0].to, path.ops[1].to, point)) {\n        firstHalf = divided.slice(0, pi)\n        firstHalf.push(new Path(this.debug).withRaise(this.raise).move(path.ops[0].to).line(point))\n        pi++\n        secondHalf = divided.slice(pi)\n        secondHalf.unshift(\n          new Path(this.debug).withRaise(this.raise).move(point).line(path.ops[1].to)\n        )\n      }\n    } else if (path.ops[1].type === 'curve') {\n      let t = pointOnCurve(path.ops[0].to, path.ops[1].cp1, path.ops[1].cp2, path.ops[1].to, point)\n      if (t !== false) {\n        let curve = new Bezier(\n          { x: path.ops[0].to.x, y: path.ops[0].to.y },\n          { x: path.ops[1].cp1.x, y: path.ops[1].cp1.y },\n          { x: path.ops[1].cp2.x, y: path.ops[1].cp2.y },\n          { x: path.ops[1].to.x, y: path.ops[1].to.y }\n        )\n        let split = curve.split(t)\n        firstHalf = divided.slice(0, pi)\n        firstHalf.push(\n          new Path(this.debug)\n            .withRaise(this.raise)\n            .move(new Point(split.left.points[0].x, split.left.points[0].y))\n            .curve(\n              new Point(split.left.points[1].x, split.left.points[1].y),\n              new Point(split.left.points[2].x, split.left.points[2].y),\n              new Point(split.left.points[3].x, split.left.points[3].y)\n            )\n        )\n        pi++\n        secondHalf = divided.slice(pi)\n        secondHalf.unshift(\n          new Path(this.debug)\n            .withRaise(this.raise)\n            .move(new Point(split.right.points[0].x, split.right.points[0].y))\n            .curve(\n              new Point(split.right.points[1].x, split.right.points[1].y),\n              new Point(split.right.points[2].x, split.right.points[2].y),\n              new Point(split.right.points[3].x, split.right.points[3].y)\n            )\n        )\n      }\n    }\n  }\n  if (firstHalf) firstHalf = joinPaths(firstHalf, false, this.raise)\n  if (secondHalf) secondHalf = joinPaths(secondHalf, false, this.raise)\n\n  return [firstHalf, secondHalf]\n}\n\n/** Removes self-intersections (overlap) from the path */\nPath.prototype.trim = function () {\n  let chunks = this.divide()\n  for (let i = 0; i < chunks.length; i++) {\n    let firstCandidate = parseInt(i) + 2\n    let lastCandidate = parseInt(chunks.length) - 1\n    for (let j = firstCandidate; j < lastCandidate; j++) {\n      let intersections = chunks[i].intersects(chunks[j])\n      if (intersections.length > 0) {\n        let intersection = intersections.pop()\n        let trimmedStart = chunks.slice(0, i)\n        let trimmedEnd = chunks.slice(parseInt(j) + 1)\n        let glue = new Path(this.debug).withRaise(this.raise)\n        let first = true\n        for (let k of [i, j]) {\n          let ops = chunks[k].ops\n          if (ops[1].type === 'line') {\n            glue.line(intersection)\n          } else if (ops[1].type === 'curve') {\n            // handle curve\n            let curve = new Bezier(\n              { x: ops[0].to.x, y: ops[0].to.y },\n              { x: ops[1].cp1.x, y: ops[1].cp1.y },\n              { x: ops[1].cp2.x, y: ops[1].cp2.y },\n              { x: ops[1].to.x, y: ops[1].to.y }\n            )\n            let t = pointOnCurve(ops[0].to, ops[1].cp1, ops[1].cp2, ops[1].to, intersection)\n            let split = curve.split(t)\n            let side\n            if (first) side = split.left\n            else side = split.right\n            glue.curve(\n              new Point(side.points[1].x, side.points[1].y),\n              new Point(side.points[2].x, side.points[2].y),\n              new Point(side.points[3].x, side.points[3].y)\n            )\n          }\n          first = false\n        }\n        let joint\n        if (trimmedStart.length > 0) joint = joinPaths(trimmedStart, false, this.raise).join(glue)\n        else joint = glue\n        if (trimmedEnd.length > 0) joint = joint.join(joinPaths(trimmedEnd, false, this.raise))\n\n        return joint.trim()\n      }\n    }\n  }\n\n  return this\n}\n\n/** Applies a path translate transform */\nPath.prototype.translate = function (x, y) {\n  if (this.debug) {\n    if (typeof x !== 'number')\n      this.raise.warning('Called `Path.translate(x, y)` but `x` is not a number')\n    if (typeof y !== 'number')\n      this.raise.warning('Called `Path.translate(x, y)` but `y` is not a number')\n  }\n  let clone = this.clone()\n  for (let op of clone.ops) {\n    if (op.type !== 'close') {\n      op.to = op.to.translate(x, y)\n    }\n    if (op.type === 'curve') {\n      op.cp1 = op.cp1.translate(x, y)\n      op.cp2 = op.cp2.translate(x, y)\n    }\n  }\n\n  return clone\n}\n\nexport default Path\n","import Path from './path'\nimport Point from './point'\nimport { Bezier } from 'bezier-js'\n\nexport function capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\n\n/** Checks for a valid coordinate value **/\nexport function isCoord(value) {\n  return value === value // NaN does not equal itself\n    ? typeof value === 'number'\n    : false\n}\n\n/** Returns internal hook name for a macro */\nexport function macroName(name) {\n  return `_macro_${name}`\n}\n\n/** Find intersection of two (endless) lines */\nexport function beamsIntersect(a1, a2, b1, b2) {\n  let slopeA = a1.slope(a2)\n  let slopeB = b1.slope(b2)\n  if (slopeA === slopeB) return false // Parallel lines\n\n  if (a1.x === a2.x) return new Point(a1.x, slopeB * a1.x + (b1.y - slopeB * b1.x))\n  // Vertical line A\n  else if (b1.x === b2.x) return new Point(b1.x, slopeA * b1.x + (a1.y - slopeA * a1.x))\n  // Vertical line B\n  else {\n    // Swap points if line A or B goes from right to left\n    if (a1.x > a2.x) a1 = a2.copy()\n    if (b1.x > b2.x) b1 = b2.copy()\n    // Find y intercept\n    let iA = a1.y - slopeA * a1.x\n    let iB = b1.y - slopeB * b1.x\n\n    // Find intersection\n    let x = (iB - iA) / (slopeA - slopeB)\n    let y = slopeA * x + iA\n\n    return new Point(x, y)\n  }\n}\n\n/** Find intersection of two line segments */\nexport function linesIntersect(a1, a2, b1, b2) {\n  let p = beamsIntersect(a1, a2, b1, b2)\n  if (!p) return false\n  let lenA = a1.dist(a2)\n  let lenB = b1.dist(b2)\n  let lenC = a1.dist(p) + p.dist(a2)\n  let lenD = b1.dist(p) + p.dist(b2)\n  if (Math.round(lenA) == Math.round(lenC) && Math.round(lenB) == Math.round(lenD)) return p\n  else return false\n}\n\n/** Finds out whether a point lies on an endless line */\nexport function pointOnBeam(from, to, check, precision = 1e6) {\n  if (from.sitsOn(check)) return true\n  if (to.sitsOn(check)) return true\n  let cross = check.dx(from) * to.dy(from) - check.dy(from) * to.dx(from)\n\n  if (Math.abs(Math.round(cross * precision) / precision) === 0) return true\n  else return false\n}\n\n/** Finds out whether a point lies on a line segment */\nexport function pointOnLine(from, to, check, precision = 1e6) {\n  if (!pointOnBeam(from, to, check, precision)) return false\n  let lenA = from.dist(to)\n  let lenB = from.dist(check) + check.dist(to)\n  if (Math.round(lenA) == Math.round(lenB)) return true\n  else return false\n}\n\n/** Finds out whether a point lies on a curve */\nexport function pointOnCurve(start, cp1, cp2, end, check) {\n  if (start.sitsOn(check)) return true\n  if (end.sitsOn(check)) return true\n  let curve = new Bezier(\n    { x: start.x, y: start.y },\n    { x: cp1.x, y: cp1.y },\n    { x: cp2.x, y: cp2.y },\n    { x: end.x, y: end.y }\n  )\n  let intersections = curve.intersects({\n    p1: { x: check.x - 1, y: check.y },\n    p2: { x: check.x + 1, y: check.y },\n  })\n  if (intersections.length === 0) {\n    // Handle edge case of a curve that's a perfect horizontal line\n    intersections = curve.intersects({\n      p1: { x: check.x, y: check.y - 1 },\n      p2: { x: check.x, y: check.y + 1 },\n    })\n  }\n\n  if (intersections.length > 0) return intersections.shift()\n  else return false\n}\n\n/** Splits a curve on a point */\nexport function splitCurve(start, cp1, cp2, end, split) {\n  let [c1, c2] = new Path().move(start).curve(cp1, cp2, end).split(split)\n\n  return [\n    {\n      start: c1.ops[0].to,\n      cp1: c1.ops[1].cp1,\n      cp2: c1.ops[1].cp2,\n      end: c1.ops[1].to,\n    },\n    {\n      start: c2.ops[0].to,\n      cp1: c2.ops[1].cp1,\n      cp2: c2.ops[1].cp2,\n      end: c2.ops[1].to,\n    },\n  ]\n}\n\n/** Find where an (endless) line intersects with a certain X-value */\nexport function beamIntersectsX(from, to, x) {\n  if (from.x === to.x) return false // Vertical line\n  let top = new Point(x, -10)\n  let bottom = new Point(x, 10)\n\n  return beamsIntersect(from, to, top, bottom)\n}\n\n/** Find where an (endless) line intersects with a certain Y-value */\nexport function beamIntersectsY(from, to, y) {\n  if (from.y === to.y) return false // Horizontal line\n  let left = new Point(-10, y)\n  let right = new Point(10, y)\n\n  return beamsIntersect(from, to, left, right)\n}\n\n/** Convert value in mm to cm or imperial units */\nexport function units(value, to = 'metric') {\n  if (to === 'imperial') return round(value / 25.4) + '&quot;'\n  else return round(value / 10) + 'cm'\n}\n\n/** Find where a curve intersects with line */\nexport function lineIntersectsCurve(start, end, from, cp1, cp2, to) {\n  let intersections = []\n  let bz = new Bezier(\n    { x: from.x, y: from.y },\n    { x: cp1.x, y: cp1.y },\n    { x: cp2.x, y: cp2.y },\n    { x: to.x, y: to.y }\n  )\n  let line = {\n    p1: { x: start.x, y: start.y },\n    p2: { x: end.x, y: end.y },\n  }\n  for (let t of bz.intersects(line)) {\n    let isect = bz.get(t)\n    intersections.push(new Point(isect.x, isect.y))\n  }\n\n  if (intersections.length === 0) return false\n  else if (intersections.length === 1) return intersections[0]\n  else return intersections\n}\n\n/** Find where a curve intersects with a given X-value */\nexport function curveIntersectsX(from, cp1, cp2, to, x) {\n  let start = new Point(x, -10000)\n  let end = new Point(x, 10000)\n  return lineIntersectsCurve(start, end, from, cp1, cp2, to)\n}\n\n/** Find where a curve intersects with a given Y-value */\nexport function curveIntersectsY(from, cp1, cp2, to, y) {\n  let start = new Point(-10000, y)\n  let end = new Point(10000, y)\n  return lineIntersectsCurve(start, end, from, cp1, cp2, to)\n}\n\n/** Find where a curve intersects with another curve */\nexport function curvesIntersect(fromA, cp1A, cp2A, toA, fromB, cp1B, cp2B, toB) {\n  let precision = 0.005 // See https://github.com/Pomax/bezierjs/issues/99\n  let intersections = []\n  let curveA = new Bezier(\n    { x: fromA.x, y: fromA.y },\n    { x: cp1A.x, y: cp1A.y },\n    { x: cp2A.x, y: cp2A.y },\n    { x: toA.x, y: toA.y }\n  )\n  let curveB = new Bezier(\n    { x: fromB.x, y: fromB.y },\n    { x: cp1B.x, y: cp1B.y },\n    { x: cp2B.x, y: cp2B.y },\n    { x: toB.x, y: toB.y }\n  )\n\n  for (let tvalues of curveA.intersects(curveB, precision)) {\n    let intersection = curveA.get(tvalues.substr(0, tvalues.indexOf('/')))\n    intersections.push(new Point(intersection.x, intersection.y))\n  }\n\n  if (intersections.length === 0) return false\n  else if (intersections.length === 1) return intersections.shift()\n  else {\n    let unique = []\n    for (let i of intersections) {\n      let dupe = false\n      for (let u of unique) {\n        if (i.sitsRoughlyOn(u)) dupe = true\n      }\n      if (!dupe) unique.push(i)\n    }\n    return unique\n  }\n}\n\n/** Find the intersections between two circles */\nexport function circlesIntersect(c1, r1, c2, r2, sort = 'x') {\n  let dx = c1.dx(c2)\n  let dy = c1.dy(c2)\n  let dist = c1.dist(c2)\n  // Check for edge cases\n  if (dist > parseFloat(r1) + parseFloat(r2)) return false // Circles do not intersect\n  if (dist < parseFloat(r2) - parseFloat(r1)) return false // One circle is contained in the other\n  if (dist === 0 && r1 === r2) return false // Two circles are identical\n  let chorddistance = (Math.pow(r1, 2) - Math.pow(r2, 2) + Math.pow(dist, 2)) / (2 * dist)\n  let halfchordlength = Math.sqrt(Math.pow(r1, 2) - Math.pow(chorddistance, 2))\n  let chordmidpointx = c1.x + (chorddistance * dx) / dist\n  let chordmidpointy = c1.y + (chorddistance * dy) / dist\n  let i1 = new Point(\n    chordmidpointx + (halfchordlength * dy) / dist,\n    chordmidpointy - (halfchordlength * dx) / dist\n  )\n  let i2 = new Point(\n    chordmidpointx - (halfchordlength * dy) / dist,\n    chordmidpointy + (halfchordlength * dx) / dist\n  )\n\n  if ((sort === 'x' && i1.x <= i2.x) || (sort === 'y' && i1.y <= i2.y)) return [i1, i2]\n  else return [i2, i1]\n}\n\n/** Find the intersections between a beam and a circle */\nexport function beamIntersectsCircle(c, r, p1, p2, sort = 'x') {\n  let dx = p2.x - p1.x\n  let dy = p2.y - p1.y\n  let A = Math.pow(dx, 2) + Math.pow(dy, 2)\n  let B = 2 * (dx * (p1.x - c.x) + dy * (p1.y - c.y))\n  let C = Math.pow(p1.x - c.x, 2) + Math.pow(p1.y - c.y, 2) - Math.pow(r, 2)\n\n  let det = Math.pow(B, 2) - 4 * A * C\n\n  if (A <= 0.0000001 || det < 0) return false\n  // No real solutions\n  else if (det === 0) {\n    // One solution\n    let t = (-1 * B) / (2 * A)\n    let i1 = new Point(p1.x + t * dx, p1.y + t * dy)\n    return [i1]\n  } else {\n    // Two solutions\n    let t = (-1 * B + Math.sqrt(det)) / (2 * A)\n    let i1 = new Point(p1.x + t * dx, p1.y + t * dy)\n    t = (-1 * B - Math.sqrt(det)) / (2 * A)\n    let i2 = new Point(p1.x + t * dx, p1.y + t * dy)\n    if ((sort === 'x' && i1.x <= i2.x) || (sort === 'y' && i1.y <= i2.y)) return [i1, i2]\n    else return [i2, i1]\n  }\n}\n/** Find the intersections between a line and a circle */\nexport function lineIntersectsCircle(c, r, p1, p2, sort = 'x') {\n  let intersections = beamIntersectsCircle(c, r, p1, p2, sort)\n  if (intersections === false) return false\n  else {\n    if (intersections.length === 1) {\n      if (pointOnLine(p1, p2, intersections[0])) return intersections\n      else return false\n    } else {\n      let i1 = intersections[0]\n      let i2 = intersections[1]\n      if (!pointOnLine(p1, p2, i1, 5) && !pointOnLine(p1, p2, i2, 5)) return false\n      else if (pointOnLine(p1, p2, i1, 5) && pointOnLine(p1, p2, i2, 5)) {\n        if ((sort === 'x' && i1.x <= i2.x) || (sort === 'y' && i1.y <= i2.y)) return [i1, i2]\n        else return [i2, i1]\n      } else if (pointOnLine(p1, p2, i1, 5)) return [i1]\n      else if (pointOnLine(p1, p2, i2, 5)) return [i2]\n    }\n  }\n}\n\nexport function curveEdge(curve, edge, steps = 500) {\n  let x = Infinity\n  let y = Infinity\n  let p\n  if (edge === 'bottom') y = -Infinity\n  if (edge === 'right') x = -Infinity\n  for (let i = 0; i < steps; i++) {\n    p = curve.get(i / steps)\n    if (\n      (edge === 'top' && p.y < y) ||\n      (edge === 'bottom' && p.y > y) ||\n      (edge === 'right' && p.x > x) ||\n      (edge === 'left' && p.x < x)\n    ) {\n      x = p.x\n      y = p.y\n    }\n  }\n\n  return new Point(x, y)\n}\n\n/**\n * Calculates scale factor based on stretch factor\n *\n * The way people measure stretch intuitively is\n * different from the way we handle stretch in code.\n * When people say '25% stretch' they mean that\n * 10cm fabric should get stretched to 12.5cm fabric.\n * In our code, that means we need to scale things by 80%.\n *\n * This method does that calculation.\n */\nexport function stretchToScale(stretch) {\n  return 1 / (1 + parseFloat(stretch))\n}\n\nexport function round(value) {\n  return Math.round(value * 1e2) / 1e2\n}\n\nexport function sampleStyle(run, runs, styles = false) {\n  return styles && Array.isArray(styles) && styles.length > 0\n    ? styles[run % styles.length]\n    : `stroke: hsl(${(run - 1) * (330 / runs)}, 100%, 35%);`\n}\n\nexport function deg2rad(degrees) {\n  return degrees * (Math.PI / 180)\n}\n\nexport function rad2deg(radians) {\n  return (radians / Math.PI) * 180\n}\n\n// Export bezier-js so plugins can use it\nexport { Bezier }\n","import Attributes from './attributes'\n\nfunction Snippet(def, anchor, debug = false) {\n  this.def = def\n  this.anchor = anchor\n  this.attributes = new Attributes()\n  Object.defineProperty(this, 'debug', { value: debug, configurable: true })\n\n  return this\n}\n\n/** Adds the raise method for a snippet not created through the proxy **/\nSnippet.prototype.withRaise = function (raise = false) {\n  if (raise) Object.defineProperty(this, 'raise', { value: raise })\n\n  return this\n}\n/** Adds an attribute. This is here to make this call chainable in assignment */\nSnippet.prototype.attr = function (name, value, overwrite = false) {\n  if (overwrite) this.attributes.set(name, value)\n  else this.attributes.add(name, value)\n\n  return this\n}\n\n/** Returns a deep copy of this */\nSnippet.prototype.clone = function () {\n  let clone = new Snippet(this.def, this.anchor.clone(), this.debug).withRaise(this.raise)\n  clone.attributes = this.attributes.clone()\n\n  return clone\n}\n\nexport default Snippet\n","export default function Hooks() {\n  return {\n    preDraft: [],\n    postDraft: [],\n    preSample: [],\n    postSample: [],\n    preRender: [],\n    postRender: [],\n    insertText: [],\n  }\n}\n","import * as utils from './utils'\nimport Point from './point'\nimport Path from './path'\nimport Snippet from './snippet'\nimport Attributes from './attributes'\nimport Hooks from './hooks'\n\nfunction Part() {\n  this.attributes = new Attributes()\n  this.points = {}\n  this.paths = {}\n  this.snippets = {}\n  this.freeId = 0\n  this.topLeft = false\n  this.bottomRight = false\n  this.width = false\n  this.height = false\n  this.render = true\n  this.utils = utils\n\n  this.Point = Point\n  this.Path = Path\n  this.Snippet = Snippet\n\n  this.hooks = new Hooks() // Hooks container\n\n  return this\n}\n\nPart.prototype.macroClosure = function (args) {\n  let self = this\n  let method = function (key, args) {\n    let macro = utils.macroName(key)\n    if (typeof self[macro] === 'function') self[macro](args)\n  }\n\n  return method\n}\n\nPart.prototype.runHooks = function (hookName, data = false) {\n  if (data === false) data = this\n  let hooks = this.hooks[hookName]\n  if (hooks && hooks.length > 0) {\n    for (let hook of hooks) {\n      hook.method(data, hook.data)\n    }\n  }\n}\n\n/** Returns an unused ID */\nPart.prototype.getId = function (prefix = '') {\n  this.freeId += 1\n\n  return prefix + this.freeId\n}\n\n/** Returns a value formatted for units provided in settings */\nPart.prototype.unitsClosure = function (value) {\n  let self = this\n  let method = function (value) {\n    if (self.context.settings.debug && typeof value !== 'number')\n      self.context.raise.debug(\n        `Calling \\`units(value)\\` but \\`value\\` is not a number (\\`${typeof value}\\`)`\n      )\n    return utils.units(value, self.context.settings.units)\n  }\n\n  return method\n}\n\n/** Calculates the part's bounding box and sets it */\nPart.prototype.boundary = function () {\n  if (this.topLeft) return this // Cached\n\n  let topLeft = new Point(Infinity, Infinity)\n  let bottomRight = new Point(-Infinity, -Infinity)\n  for (let key in this.paths) {\n    try {\n      let path = this.paths[key].boundary()\n      if (path.render) {\n        if (path.topLeft.x < topLeft.x) topLeft.x = path.topLeft.x\n        if (path.topLeft.y < topLeft.y) topLeft.y = path.topLeft.y\n        if (path.bottomRight.x > bottomRight.x) bottomRight.x = path.bottomRight.x\n        if (path.bottomRight.y > bottomRight.y) bottomRight.y = path.bottomRight.y\n      }\n    } catch (err) {\n      this.context.raise.error(`Could not calculate boundary of \\`paths.${key}\\``)\n      this.context.raise.debug(\n        `Since \\`paths.${key}\\` has no boundary, neither does \\`parts.${this.name}\\`. Ejecting part`\n      )\n      return false\n    }\n  }\n  for (let key in this.points) {\n    let point = this.points[key]\n    let radius = point.attributes.get('data-circle')\n    if (radius) {\n      radius = parseFloat(radius)\n      if (point.x - radius < topLeft.x) topLeft.x = point.x - radius\n      if (point.y - radius < topLeft.y) topLeft.y = point.y - radius\n      if (point.x + radius > bottomRight.x) bottomRight.x = point.x + radius\n      if (point.y + radius > bottomRight.y) bottomRight.y = point.y + radius\n    }\n  }\n  // Fix infinity if part has no paths\n  if (topLeft.x === Infinity) topLeft.x = 0\n  if (topLeft.y === Infinity) topLeft.y = 0\n  if (bottomRight.x === -Infinity) bottomRight.x = 0\n  if (bottomRight.y === -Infinity) bottomRight.y = 0\n  // Add margin\n  let margin = this.context.settings.margin\n  if (this.context.settings.paperless && margin < 10) margin = 10\n  this.topLeft = new Point(topLeft.x - margin, topLeft.y - margin)\n  this.bottomRight = new Point(bottomRight.x + margin, bottomRight.y + margin)\n  this.width = this.bottomRight.x - this.topLeft.x\n  this.height = this.bottomRight.y - this.topLeft.y\n\n  return this\n}\n\n/** Stacks part so that its top left corner is in (0,0) */\nPart.prototype.stack = function () {\n  if (this.topLeft !== false) return this\n  else this.boundary()\n  if (this.topLeft.x == 0 && this.topLeft.y == 0) return this\n  else this.attr('transform', `translate(${this.topLeft.x * -1}, ${this.topLeft.y * -1})`)\n\n  return this\n}\n\n/** Adds an attribute. This is here to make this call chainable in assignment */\nPart.prototype.attr = function (name, value, overwrite = false) {\n  if (overwrite) this.attributes.set(name, value)\n  else this.attributes.add(name, value)\n\n  return this\n}\n\n/** Copies point/path/snippet data from part orig into this */\nPart.prototype.inject = function (orig) {\n  const findBasePoint = (p) => {\n    for (let i in orig.points) {\n      if (orig.points[i] === p) return i\n    }\n\n    return false\n  }\n\n  for (let i in orig.points) this.points[i] = orig.points[i].clone()\n  for (let i in orig.paths) {\n    this.paths[i] = orig.paths[i].clone()\n    // Keep link between points and path ops where possible\n    for (let j in orig.paths[i].ops) {\n      let op = orig.paths[i].ops[j]\n      if (op.type !== 'close') {\n        let toPoint = findBasePoint(op.to)\n        if (toPoint) this.paths[i].ops[j].to = this.points[toPoint]\n      }\n      if (op.type === 'curve') {\n        let cp1Point = findBasePoint(op.cp1)\n        if (cp1Point) this.paths[i].ops[j].cp1 = this.points[cp1Point]\n        let cp2Point = findBasePoint(op.cp2)\n        if (cp2Point) this.paths[i].ops[j].cp2 = this.points[cp2Point]\n      }\n    }\n  }\n  for (let i in orig.snippets) {\n    this.snippets[i] = orig.snippets[i].clone()\n  }\n\n  return this\n}\n\nPart.prototype.units = function (input) {\n  return utils.units(input, this.context.settings.units)\n}\n\n/** Returns an object with shorthand access for pattern design */\nPart.prototype.shorthand = function () {\n  let complete = this.context.settings.complete ? true : false\n  let paperless = this.context.settings.paperless === true ? true : false\n  let sa = this.context.settings.complete ? this.context.settings.sa || 0 : 0\n  const shorthand = {\n    sa,\n    store: this.context.store,\n    macro: this.macroClosure(),\n    units: this.unitsClosure(),\n    utils: utils,\n    complete,\n    paperless,\n    events: this.context.events,\n    raise: this.context.raise,\n  }\n\n  if (this.context.settings.debug) {\n    // We'll need this\n    let self = this\n\n    // Wrap the Point constructor so objects can raise events\n    shorthand.Point = function (x, y) {\n      Point.apply(this, [x, y, true])\n      Object.defineProperty(this, 'raise', { value: self.context.raise })\n    }\n    shorthand.Point.prototype = Object.create(Point.prototype)\n    // Wrap the Path constructor so objects can raise events\n    shorthand.Path = function () {\n      Path.apply(this, [true])\n      Object.defineProperty(this, 'raise', { value: self.context.raise })\n    }\n    shorthand.Path.prototype = Object.create(Path.prototype)\n    // Wrap the Snippet constructor so objects can raise events\n    shorthand.Snippet = function (def, anchor) {\n      Snippet.apply(this, [def, anchor, true])\n      Snippet.apply(this, arguments)\n      Object.defineProperty(this, 'raise', { value: self.context.raise })\n    }\n    shorthand.Snippet.prototype = Object.create(Snippet.prototype)\n\n    // Proxy the points object\n    const pointsProxy = {\n      get: function () {\n        return Reflect.get(...arguments)\n      },\n      set: (points, name, value) => {\n        // Constructor checks\n        if (value instanceof Point !== true)\n          self.context.raise.warning(\n            `\\`points.${name}\\` was set with a value that is not a \\`Point\\` object`\n          )\n        if (value.x == null || !utils.isCoord(value.x))\n          self.context.raise.warning(\n            `\\`points.${name}\\` was set with a \\`x\\` parameter that is not a \\`number\\``\n          )\n        if (value.y == null || !utils.isCoord(value.y))\n          self.context.raise.warning(\n            `\\`points.${name}\\` was set with a \\`y\\` parameter that is not a \\`number\\``\n          )\n        try {\n          value.name = name\n        } catch (err) {\n          self.context.raise.warning(`Could not set \\`name\\` property on \\`points.${name}\\``)\n        }\n        return (self.points[name] = value)\n      },\n    }\n    shorthand.points = new Proxy(this.points || {}, pointsProxy)\n    // Proxy the paths object\n    const pathsProxy = {\n      get: function () {\n        return Reflect.get(...arguments)\n      },\n      set: (paths, name, value) => {\n        // Constructor checks\n        if (value instanceof Path !== true)\n          self.context.raise.warning(\n            `\\`paths.${name}\\` was set with a value that is not a \\`Path\\` object`\n          )\n        try {\n          value.name = name\n        } catch (err) {\n          self.context.raise.warning(`Could not set \\`name\\` property on \\`paths.${name}\\``)\n        }\n        return (self.paths[name] = value)\n      },\n    }\n    shorthand.paths = new Proxy(this.paths || {}, pathsProxy)\n    // Proxy the snippets object\n    const snippetsProxy = {\n      get: function (target, prop, receiver) {\n        return Reflect.get(...arguments)\n      },\n      set: (snippets, name, value) => {\n        // Constructor checks\n        if (value instanceof Snippet !== true)\n          self.context.raise.warning(\n            `\\`snippets.${name}\\` was set with a value that is not a \\`Snippet\\` object`\n          )\n        if (typeof value.def !== 'string')\n          self.context.raise.warning(\n            `\\`snippets.${name}\\` was set with a \\`def\\` parameter that is not a \\`string\\``\n          )\n        if (value.anchor instanceof Point !== true)\n          self.context.raise.warning(\n            `\\`snippets.${name}\\` was set with an \\`anchor\\` parameter that is not a \\`Point\\``\n          )\n        try {\n          value.name = name\n        } catch (err) {\n          self.context.raise.warning(`Could not set \\`name\\` property on \\`snippets.${name}\\``)\n        }\n        return (self.snippets[name] = value)\n      },\n    }\n    shorthand.snippets = new Proxy(this.snippets || {}, snippetsProxy)\n    // Proxy the measurements object\n    const measurementsProxy = {\n      get: function (measurements, name) {\n        if (typeof measurements[name] === 'undefined')\n          self.context.raise.warning(\n            `Tried to access \\`measurements.${name}\\` but it is \\`undefined\\``\n          )\n        return Reflect.get(...arguments)\n      },\n      set: (measurements, name, value) => (self.context.settings.measurements[name] = value),\n    }\n    shorthand.measurements = new Proxy(this.context.settings.measurements || {}, measurementsProxy)\n    // Proxy the options object\n    const optionsProxy = {\n      get: function (options, name) {\n        if (typeof options[name] === 'undefined')\n          self.context.raise.warning(`Tried to access \\`options.${name}\\` but it is \\`undefined\\``)\n        return Reflect.get(...arguments)\n      },\n      set: (options, name, value) => (self.context.settings.options[name] = value),\n    }\n    shorthand.options = new Proxy(this.context.settings.options || {}, optionsProxy)\n  } else {\n    shorthand.Point = Point\n    shorthand.Path = Path\n    shorthand.Snippet = Snippet\n    shorthand.points = this.points || {}\n    shorthand.paths = this.paths || {}\n    shorthand.snippets = this.snippets || {}\n    shorthand.measurements = this.context.settings.measurements || {}\n    shorthand.options = this.context.settings.options || {}\n  }\n\n  return shorthand\n}\n\nexport default Part\n","import Attributes from './attributes'\nimport { round } from './utils'\nimport { version } from '../package.json'\n\nfunction Svg(pattern) {\n  this.openGroups = []\n  this.layout = {}\n  this.freeId = 0\n  this.body = ''\n  this.style = ''\n  this.script = ''\n  this.defs = ''\n  this.pattern = pattern // Needed to expose pattern to hooks\n  this.prefix = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>'\n  this.attributes = new Attributes()\n  this.attributes.add('xmlns', 'http://www.w3.org/2000/svg')\n  this.attributes.add('xmlns:svg', 'http://www.w3.org/2000/svg')\n  this.attributes.add('xmlns:xlink', 'http://www.w3.org/1999/xlink')\n  this.attributes.add('xml:lang', pattern.settings.locale)\n  this.attributes.add('xmlns:freesewing', 'http://freesewing.org/namespaces/freesewing')\n  this.attributes.add('freesewing', version)\n}\n\nSvg.prototype.runHooks = function (hookName, data = false) {\n  if (data === false) data = this\n  let hooks = this.hooks[hookName]\n  if (hooks.length > 0) {\n    for (let hook of hooks) {\n      hook.method(data, hook.data)\n    }\n  }\n}\n\n/** Runs insertText hooks */\nSvg.prototype.insertText = function (text) {\n  if (this.hooks.insertText.length > 0) {\n    for (let hook of this.hooks.insertText)\n      text = hook.method(this.pattern.settings.locale, text, hook.data)\n  }\n\n  return text\n}\n\n/** Renders a draft object as SVG */\nSvg.prototype.render = function (pattern) {\n  this.idPrefix = pattern.settings.idPrefix\n  this.runHooks('preRender')\n  if (!pattern.settings.embed) {\n    this.attributes.add('width', round(pattern.width) + 'mm')\n    this.attributes.add('height', round(pattern.height) + 'mm')\n  }\n  this.attributes.add('viewBox', `0 0 ${pattern.width} ${pattern.height}`)\n  this.head = this.renderHead()\n  this.tail = this.renderTail()\n  this.svg = ''\n  this.layout = {} // Reset layout\n  for (let partId in pattern.parts) {\n    let part = pattern.parts[partId]\n    if (part.render) {\n      let partSvg = this.renderPart(part)\n      this.layout[partId] = {\n        svg: partSvg,\n        transform: part.attributes.getAsArray('transform'),\n      }\n      this.svg += this.openGroup(`${this.idPrefix}part-${partId}`, part.attributes)\n      this.svg += partSvg\n      this.svg += this.closeGroup()\n    }\n  }\n  this.svg = this.prefix + this.renderSvgTag() + this.head + this.svg + this.tail\n  this.runHooks('postRender')\n\n  return this.svg\n}\n\n/** Renders SVG head section */\nSvg.prototype.renderHead = function () {\n  let svg = this.renderStyle()\n  svg += this.renderScript()\n  svg += this.renderDefs()\n  svg += this.openGroup(this.idPrefix + 'container')\n\n  return svg\n}\n\n/** Renders SVG closing section */\nSvg.prototype.renderTail = function () {\n  let svg = ''\n  svg += this.closeGroup()\n  svg += this.nl() + '</svg>'\n\n  return svg\n}\n\n/** Returns SVG code for the opening SVG tag */\nSvg.prototype.renderSvgTag = function () {\n  let svg = '<svg'\n  this.indent()\n  svg += this.nl() + this.attributes.render()\n  this.outdent()\n  svg += this.nl() + '>' + this.nl()\n\n  return svg\n}\n\n/** Returns SVG code for the style block */\nSvg.prototype.renderStyle = function () {\n  let svg = '<style type=\"text/css\"> <![CDATA[ '\n  this.indent()\n  svg += this.nl() + this.style\n  this.outdent()\n  svg += this.nl() + ']]>' + this.nl() + '</style>' + this.nl()\n  return svg\n}\n\n/** Returns SVG code for the script block */\nSvg.prototype.renderScript = function () {\n  let svg = '<script type=\"text/javascript\"> <![CDATA['\n  this.indent()\n  svg += this.nl() + this.script\n  this.outdent()\n  svg += this.nl() + ']]>' + this.nl() + '</script>' + this.nl()\n\n  return svg\n}\n\n/** Returns SVG code for the defs block */\nSvg.prototype.renderDefs = function () {\n  let svg = '<defs>'\n  this.indent()\n  svg += this.nl() + this.defs\n  this.outdent()\n  svg += this.nl() + '</defs>' + this.nl()\n\n  return svg\n}\n\n/** Returns SVG code for a Part object */\nSvg.prototype.renderPart = function (part) {\n  let svg = ''\n  for (let key in part.paths) {\n    let path = part.paths[key]\n    if (path.render) svg += this.renderPath(path)\n  }\n  for (let key in part.points) {\n    if (part.points[key].attributes.get('data-text')) {\n      svg += this.renderText(part.points[key])\n    }\n    if (part.points[key].attributes.get('data-circle')) {\n      svg += this.renderCircle(part.points[key])\n    }\n  }\n  for (let key in part.snippets) {\n    let snippet = part.snippets[key]\n    svg += this.renderSnippet(snippet, part)\n  }\n\n  return svg\n}\n\n/** Returns SVG code for a Path object */\nSvg.prototype.renderPath = function (path) {\n  if (!path.attributes.get('id')) path.attributes.add('id', this.idPrefix + this.getId())\n  path.attributes.set('d', path.asPathstring())\n\n  return `${this.nl()}<path ${path.attributes.render()} />${this.renderPathText(path)}`\n}\n\nSvg.prototype.renderPathText = function (path) {\n  let text = path.attributes.get('data-text')\n  if (!text) return ''\n  else this.text = this.insertText(text)\n  let attributes = path.attributes.renderIfPrefixIs('data-text-')\n  // Sadly aligning text along a patch can't be done in CSS only\n  let offset = ''\n  let align = path.attributes.get('data-text-class')\n  if (align && align.indexOf('center') > -1) offset = ' startOffset=\"50%\" '\n  else if (align && align.indexOf('right') > -1) offset = ' startOffset=\"100%\" '\n  let svg = this.nl() + '<text>'\n  this.indent()\n  svg += `<textPath xlink:href=\"#${path.attributes.get(\n    'id'\n  )}\" ${offset}><tspan ${attributes}>${this.escapeText(this.text)}</tspan></textPath>`\n  this.outdent()\n  svg += this.nl() + '</text>'\n\n  return svg\n}\n\nSvg.prototype.renderText = function (point) {\n  let text = point.attributes.getAsArray('data-text')\n  if (text !== false) {\n    let joint = ''\n    for (let string of text) {\n      this.text = this.insertText(string)\n      joint += this.text + ' '\n    }\n    this.text = this.insertText(joint)\n  }\n  point.attributes.set('data-text-x', round(point.x))\n  point.attributes.set('data-text-y', round(point.y))\n  let lineHeight = point.attributes.get('data-text-lineheight') || 12\n  point.attributes.remove('data-text-lineheight')\n  let svg = `${this.nl()}<text ${point.attributes.renderIfPrefixIs('data-text-')}>`\n  this.indent()\n  // Multi-line text?\n  if (this.text.indexOf('\\n') !== -1) {\n    let lines = this.text.split('\\n')\n    svg += `<tspan>${lines.shift()}</tspan>`\n    for (let line of lines) {\n      svg += `<tspan x=\"${round(point.x)}\" dy=\"${lineHeight}\">${line}</tspan>`\n    }\n  } else {\n    svg += `<tspan>${this.escapeText(this.text)}</tspan>`\n  }\n  this.outdent()\n  svg += this.nl() + '</text>'\n\n  return svg\n}\n\nSvg.prototype.escapeText = function (text) {\n  return text.replace('\"', '&#8220;')\n}\n\nSvg.prototype.renderCircle = function (point) {\n  return `<circle cx=\"${round(point.x)}\" cy=\"${round(point.y)}\" r=\"${point.attributes.get(\n    'data-circle'\n  )}\" ${point.attributes.renderIfPrefixIs('data-circle-')}></circle>`\n}\n\n/** Returns SVG code for a snippet */\nSvg.prototype.renderSnippet = function (snippet, part) {\n  let x = round(snippet.anchor.x)\n  let y = round(snippet.anchor.y)\n  let scale = snippet.attributes.get('data-scale')\n  if (scale) {\n    snippet.attributes.add('transform', `translate(${x}, ${y})`)\n    snippet.attributes.add('transform', `scale(${scale})`)\n    snippet.attributes.add('transform', `translate(${x * -1}, ${y * -1})`)\n  }\n  let rotate = snippet.attributes.get('data-rotate')\n  if (rotate) {\n    snippet.attributes.add('transform', `rotate(${rotate}, ${x}, ${y})`)\n  }\n  let svg = this.nl()\n  svg += `<use x=\"${x}\" y=\"${y}\" `\n  svg += `xlink:href=\"#${snippet.def}\" ${snippet.attributes.render()}>`\n  svg += '</use>'\n\n  return svg\n}\n\n/** Returns SVG code to open a group */\nSvg.prototype.openGroup = function (id, attributes = false) {\n  let svg = this.nl() + this.nl()\n  svg += `<!-- Start of group #${id} -->`\n  svg += this.nl()\n  svg += `<g id=\"${id}\"`\n  if (attributes) svg += ` ${attributes.render()}`\n  svg += '>'\n  this.indent()\n  this.openGroups.push(id)\n\n  return svg\n}\n\n/** Returns SVG code to close a group */\nSvg.prototype.closeGroup = function () {\n  this.outdent()\n\n  return `${this.nl()}</g>${this.nl()}<!-- end of group #${this.openGroups.pop()} -->`\n}\n\n/** Returns a linebreak + identation */\nSvg.prototype.nl = function () {\n  return '\\n' + this.tab()\n}\n\n/** Returns indentation */\nSvg.prototype.tab = function () {\n  let space = ''\n  for (let i = 0; i < this.tabs; i++) {\n    space += '  '\n  }\n\n  return space\n}\n\n/** Increases indentation by 1 */\nSvg.prototype.indent = function () {\n  this.tabs += 1\n}\n\n/** Decreases indentation by 1 */\nSvg.prototype.outdent = function () {\n  this.tabs -= 1\n}\n\n/** Returns an unused ID */\nSvg.prototype.getId = function () {\n  this.freeId += 1\n\n  return '' + this.freeId\n}\n\nexport default Svg\n","/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/\n\nvar GrowingPacker = function() { };\n\nGrowingPacker.prototype = {\n\n\tfit: function(blocks) {\n\t\tvar n, node, block, len = blocks.length, fit;\n\t\tvar width  = len > 0 ? blocks[0].width : 0;\n\t\tvar height = len > 0 ? blocks[0].height : 0;\n\t\tthis.root = { x: 0, y: 0, width: width, height: height };\n\t\tfor (n = 0; n < len ; n++) {\n\t\t\tblock = blocks[n];\n\t\t\tif (node = this.findNode(this.root, block.width, block.height)) {\n\t\t\t\tfit = this.splitNode(node, block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfit = this.growNode(block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t}\n\t},\n\n\tfindNode: function(root, width, height) {\n\t\tif (root.used)\n\t\t\treturn this.findNode(root.right, width, height) || this.findNode(root.down, width, height);\n\t\telse if ((width <= root.width) && (height <= root.height))\n\t\t\treturn root;\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tsplitNode: function(node, width, height) {\n\t\tnode.used = true;\n\t\tnode.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };\n\t\tnode.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };\n\t\treturn node;\n\t},\n\n\tgrowNode: function(width, height) {\n\t\tvar canGrowDown  = (width  <= this.root.width);\n\t\tvar canGrowRight = (height <= this.root.height);\n\n\t\tvar shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width\n\t\tvar shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height\n\n\t\tif (shouldGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (shouldGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse if (canGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (canGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse\n\t\t\treturn null; // need to ensure sensible root starting size to avoid this happening\n\t},\n\n\tgrowRight: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width + width,\n\t\t\theight: this.root.height,\n\t\t\tdown: this.root,\n\t\t\tright: { x: this.root.width, y: 0, width: width, height: this.root.height }\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tgrowDown: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width,\n\t\t\theight: this.root.height + height,\n\t\t\tdown:  { x: 0, y: this.root.height, width: this.root.width, height: height },\n\t\t\tright: this.root\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t}\n\n};\n\nmodule.exports = GrowingPacker;\n\n","\"use strict\";\n\nvar GrowingPacker = require('./packer.growing.js');\n\nmodule.exports = function(items, options) {\n\toptions = options || {};\n\tvar packer = new GrowingPacker();\n\tvar inPlace = options.inPlace || false;\n\n\t// Clone the items.\n\tvar newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });\n\n\tnewItems = newItems.sort(function(a, b) {\n\t\t// TODO: check that each actually HAS a width and a height.\n\t\t// Sort based on the size (area) of each block.\n\t\treturn (b.width * b.height) - (a.width * a.height);\n\t});\n\n\tpacker.fit(newItems);\n\n\tvar w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);\n\tvar h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);\n\n\tvar ret = {\n\t\twidth: w,\n\t\theight: h\n\t};\n\n\tif (!inPlace) {\n\t\tret.items = newItems;\n\t}\n\n\treturn ret;\n};\n","function Store(raise) {\n  this.data = new Map()\n  this.raise = raise\n}\n\n/** Sets a value under index key */\nStore.prototype.set = function (key, value) {\n  this.data.set(key, value)\n}\n\n/** Sets a value under index key */\nStore.prototype.setIfUnset = function (key, value) {\n  if (!this.data.has(key)) this.data.set(key, value)\n}\n\n/** Gets a value under index key */\nStore.prototype.get = function (key) {\n  if (!this.data.has(key))\n    this.raise.warning(`Tried to access \\`${key}\\` in the \\`store\\` but it is not set`)\n  return this.data.get(key)\n}\n\nexport default Store\n","import { macroName, sampleStyle, capitalize } from './utils'\nimport Part from './part'\nimport Point from './point'\nimport Path from './path'\nimport Snippet from './snippet'\nimport Svg from './svg'\nimport pack from 'bin-pack'\nimport Store from './store'\nimport Hooks from './hooks'\nimport Attributes from './attributes'\nimport { version } from '../package.json'\n\nexport default function Pattern(config = { options: {} }) {\n  // Events store and raise methods\n  this.events = {\n    info: [],\n    warning: [],\n    error: [],\n    debug: [],\n  }\n  const events = this.events\n  this.raise = {\n    info: function (data) {\n      events.info.push(data)\n    },\n    warning: function (data) {\n      events.warning.push(data)\n    },\n    error: function (data) {\n      events.error.push(data)\n    },\n    debug: function (data) {\n      events.debug.push(data)\n    },\n  }\n  this.raise.debug(\n    `New \\`@freesewing/${config.name}:${config.version}\\` pattern using \\`@freesewing/core:${version}\\``\n  )\n\n  this.config = config // Pattern configuration\n  this.width = 0 // Will be set after render\n  this.height = 0 // Will be set after render\n  this.is = '' // Will be set when drafting/sampling\n  this.debug = true // Will be set when applying settings\n\n  this.store = new Store(this.raise) // Store for sharing data across parts\n  this.parts = {} // Parts container\n  this.hooks = new Hooks() // Hooks container\n  this.Point = Point // Point constructor\n  this.Path = Path // Path constructor\n  this.Snippet = Snippet // Snippet constructor\n  this.Attributes = Attributes // Attributes constructor\n\n  // Default settings\n  this.settings = {\n    complete: true,\n    idPrefix: 'fs-',\n    locale: 'en',\n    units: 'metric',\n    margin: 2,\n    layout: true,\n    debug: true,\n    options: {},\n  }\n\n  if (typeof this.config.dependencies === 'undefined') this.config.dependencies = {}\n  if (typeof this.config.inject === 'undefined') this.config.inject = {}\n  if (typeof this.config.hide === 'undefined') this.config.hide = []\n  this.config.resolvedDependencies = this.resolveDependencies(this.config.dependencies)\n  this.config.draftOrder = this.draftOrder(this.config.resolvedDependencies)\n\n  // Convert options\n  for (let i in config.options) {\n    let option = config.options[i]\n    if (typeof option === 'object') {\n      if (typeof option.pct !== 'undefined') this.settings.options[i] = option.pct / 100\n      else if (typeof option.mm !== 'undefined') this.settings.options[i] = option.mm\n      else if (typeof option.deg !== 'undefined') this.settings.options[i] = option.deg\n      else if (typeof option.count !== 'undefined') this.settings.options[i] = option.count\n      else if (typeof option.bool !== 'undefined') this.settings.options[i] = option.bool\n      else if (typeof option.dflt !== 'undefined') this.settings.options[i] = option.dflt\n      else {\n        let err = 'Unknown option type: ' + JSON.stringify(option)\n        this.raise.error(err)\n        throw new Error(err)\n      }\n    } else {\n      this.settings.options[i] = option\n    }\n  }\n\n  // Macros\n  this.macros = {}\n\n  // Context object to add to Part closure\n  const context = {\n    parts: this.parts,\n    config: this.config,\n    settings: this.settings,\n    store: this.store,\n    macros: this.macros,\n    events: this.events,\n    raise: this.raise,\n  }\n\n  // Part closure\n  this.Part = function (name = false) {\n    let part = new Part()\n    part.context = context\n    for (let macro in context.macros) {\n      part[macroName(macro)] = context.macros[macro]\n    }\n    if (name) part.name = name\n\n    return part\n  }\n}\n\n// Merges settings object with this.settings\nPattern.prototype.apply = function (settings) {\n  if (typeof settings !== 'object') {\n    this.raise.warning('Pattern initialized without any settings')\n    return this\n  }\n  for (let key of Object.keys(settings)) {\n    if (Array.isArray(settings[key])) {\n      if (Array.isArray(this.settings[key])) {\n        for (let entry of settings[key]) this.settings[key].push(entry)\n      } else this.settings[key] = settings[key]\n    } else if (typeof settings[key] === 'object') {\n      this.settings[key] = {\n        ...this.settings[key],\n        ...settings[key],\n      }\n    } else this.settings[key] = settings[key]\n  }\n  if (!this.settings.debug) this.debug = false\n\n  return this\n}\n\nPattern.prototype.runHooks = function (hookName, data = false) {\n  if (data === false) data = this\n  let hooks = this.hooks[hookName]\n  if (hooks.length > 0) {\n    if (this.debug) this.raise.debug(`Running \\`${hookName}\\` hooks`)\n    for (let hook of hooks) {\n      hook.method(data, hook.data)\n    }\n  }\n}\n\n/**\n *  The default draft method with pre- and postDraft hooks\n */\nPattern.prototype.draft = function () {\n  if (this.is !== 'sample') {\n    this.is = 'draft'\n    if (this.debug) this.raise.debug(`Drafting pattern`)\n  }\n  this.runHooks('preDraft')\n  for (let partName of this.config.draftOrder) {\n    if (this.debug) this.raise.debug(`Creating part \\`${partName}\\``)\n    this.parts[partName] = new this.Part(partName)\n    if (typeof this.config.inject[partName] === 'string') {\n      if (this.debug)\n        this.raise.debug(\n          `Injecting part \\`${this.config.inject[partName]}\\` into part \\`${partName}\\``\n        )\n      try {\n        this.parts[partName].inject(this.parts[this.config.inject[partName]])\n      } catch (err) {\n        this.raise.error([\n          `Could not inject part \\`${this.config.inject[partName]}\\` into part \\`${partName}\\``,\n          err,\n        ])\n      }\n    }\n    if (this.needs(partName)) {\n      let method = 'draft' + capitalize(partName)\n      if (typeof this[method] !== 'function') {\n        this.raise.error(`Method \\`pattern.${method}\\` is callable`)\n        throw new Error('Method \"' + method + '\" on pattern object is not callable')\n      }\n      try {\n        this.parts[partName] = this[method](this.parts[partName])\n      } catch (err) {\n        this.raise.error([`Unable to draft part \\`${partName}\\``, err])\n      }\n      if (typeof this.parts[partName] === 'undefined') {\n        this.raise.error(\n          `Result of \\`pattern.${method}\\` was \\`undefined\\`. Did you forget to return the \\`Part\\` object?`\n        )\n      }\n      try {\n        this.parts[partName].render =\n          this.parts[partName].render === false ? false : this.wants(partName)\n      } catch (err) {\n        this.raise.error([`Unable to set \\`render\\` property on part \\`${partName}\\``, err])\n      }\n    } else {\n      if (this.debug)\n        this.raise.debug(\n          `Part \\`${partName}\\` is not needed. Skipping draft and setting render to \\`false\\``\n        )\n      this.parts[partName].render = false\n    }\n  }\n  this.runHooks('postDraft')\n\n  return this\n}\n\n/**\n * Handles pattern sampling\n */\nPattern.prototype.sample = function () {\n  if (this.settings.sample.type === 'option') {\n    return this.sampleOption(this.settings.sample.option)\n  } else if (this.settings.sample.type === 'measurement') {\n    return this.sampleMeasurement(this.settings.sample.measurement)\n  } else if (this.settings.sample.type === 'models') {\n    return this.sampleModels(this.settings.sample.models, this.settings.sample.focus || false)\n  }\n}\n\nPattern.prototype.sampleParts = function () {\n  let parts = {}\n  this.settings.complete = false\n  this.settings.paperless = false\n  this.draft()\n  for (let i in this.parts) {\n    parts[i] = new this.Part()\n    parts[i].render = this.parts[i].render\n  }\n  return parts\n}\n\nPattern.prototype.sampleRun = function (parts, anchors, run, runs, extraClass = false) {\n  this.draft()\n  for (let i in this.parts) {\n    let anchor = false\n    let dx = 0\n    let dy = 0\n    if (this.parts[i].points.anchor) {\n      if (typeof anchors[i] === 'undefined') anchors[i] = this.parts[i].points.anchor\n      else {\n        if (!anchors[i].sitsOn(this.parts[i].points.anchor)) {\n          dx = this.parts[i].points.anchor.dx(anchors[i])\n          dy = this.parts[i].points.anchor.dy(anchors[i])\n        }\n      }\n    }\n    for (let j in this.parts[i].paths) {\n      parts[i].paths[j + '_' + run] = this.parts[i].paths[j]\n        .clone()\n        .attr(\n          'style',\n          extraClass === 'sample-focus'\n            ? this.settings.sample\n              ? this.settings.sample.focusStyle || sampleStyle(run, runs)\n              : sampleStyle(run, runs)\n            : sampleStyle(\n                run,\n                runs,\n                this.settings.sample ? this.settings.sample.styles || false : false\n              )\n        )\n        .attr('data-sample-run', run)\n        .attr('data-sample-runs', runs)\n      if (this.parts[i].points.anchor)\n        parts[i].paths[j + '_' + run] = parts[i].paths[j + '_' + run].translate(dx, dy)\n      if (extraClass !== false) parts[i].paths[j + '_' + run].attributes.add('class', extraClass)\n    }\n  }\n}\n\n/**\n * Handles option sampling\n */\nPattern.prototype.sampleOption = function (optionName) {\n  this.is = 'sample'\n  if (this.debug) this.raise.debug(`Sampling option \\`${optionName}\\``)\n  this.runHooks('preSample')\n  let step, val\n  let factor = 1\n  let anchors = {}\n  let parts = this.sampleParts()\n  let option = this.config.options[optionName]\n  if (typeof option.list === 'object') {\n    return this.sampleListOption(optionName)\n  }\n  if (typeof option.min === 'undefined' || typeof option.max === 'undefined') {\n    let min = option * 0.9\n    let max = option * 1.1\n    option = { min, max }\n  }\n  if (typeof option.pct !== 'undefined') factor = 100\n  val = option.min / factor\n  step = (option.max / factor - val) / 9\n  for (let run = 1; run < 11; run++) {\n    this.settings.options[optionName] = val\n    this.sampleRun(parts, anchors, run, 10)\n    val += step\n  }\n  this.parts = parts\n  this.runHooks('postSample')\n\n  return this\n}\n\nPattern.prototype.sampleListOption = function (optionName) {\n  let parts = this.sampleParts()\n  let option = this.config.options[optionName]\n  let anchors = {}\n  let run = 1\n  let runs = option.list.length\n  for (let val of option.list) {\n    this.settings.options[optionName] = val\n    this.sampleRun(parts, anchors, run, runs)\n    run++\n  }\n  this.parts = parts\n\n  return this\n}\n\n/**\n * Handles measurement sampling\n */\nPattern.prototype.sampleMeasurement = function (measurementName) {\n  this.is = 'sample'\n  if (this.debug) this.raise.debug(`Sampling measurement \\`${measurementName}\\``)\n  this.runHooks('preSample')\n  let anchors = {}\n  let parts = this.sampleParts()\n  let val = this.settings.measurements[measurementName]\n  if (val === undefined)\n    this.raise.error(`Cannot sample measurement \\`${measurementName}\\` because it's \\`undefined\\``)\n  let step = val / 50\n  val = val * 0.9\n  for (let run = 1; run < 11; run++) {\n    this.settings.measurements[measurementName] = val\n    this.sampleRun(parts, anchors, run, 10)\n    val += step\n  }\n  this.parts = parts\n  this.runHooks('postSample')\n\n  return this\n}\n\n/**\n * Handles models sampling\n */\nPattern.prototype.sampleModels = function (models, focus = false) {\n  this.is = 'sample'\n  if (this.debug) this.raise.debug(`Sampling models`)\n  this.runHooks('preSample')\n  let anchors = {}\n  let parts = this.sampleParts()\n  // If there's a focus, do it first so it's at the bottom of the SVG\n  if (focus) {\n    this.settings.measurements = models[focus]\n    this.sampleRun(parts, anchors, -1, -1, 'sample-focus')\n    delete models[focus]\n  }\n  let run = -1\n  let runs = Object.keys(models).length\n  for (let l in models) {\n    run++\n    this.settings.measurements = models[l]\n    this.sampleRun(parts, anchors, run, runs)\n  }\n  this.parts = parts\n  this.runHooks('postSample')\n\n  return this\n}\n\nPattern.prototype.render = function () {\n  this.svg = new Svg(this)\n  this.svg.hooks = this.hooks\n\n  return this.pack().svg.render(this)\n}\n\nPattern.prototype.on = function (hook, method, data) {\n  this.hooks[hook].push({ method, data })\n}\n\nPattern.prototype.use = function (plugin, data) {\n  if (this.debug) this.raise.debug(`Loaded plugin \\`${plugin.name}:${plugin.version}\\``)\n  if (plugin.hooks) this.loadPluginHooks(plugin, data)\n  if (plugin.macros) this.loadPluginMacros(plugin)\n\n  return this\n}\n\nPattern.prototype.useIf = function (plugin, settings) {\n  if (plugin.condition(settings)) {\n    if (this.debug)\n      this.raise.debug(\n        `Condition met: Loaded plugin \\`${plugin.plugin.name}:${plugin.plugin.version}\\``\n      )\n    this.loadPluginHooks(plugin.plugin, plugin.data)\n  } else {\n    if (this.debug)\n      this.raise.debug(\n        `Condition not met: Skipped loading plugin \\`${plugin.plugin.name}:${plugin.plugin.version}\\``\n      )\n  }\n\n  return this\n}\n\nPattern.prototype.loadPluginHooks = function (plugin, data) {\n  for (let hook of Object.keys(this.hooks)) {\n    if (typeof plugin.hooks[hook] === 'function') {\n      this.on(hook, plugin.hooks[hook], data)\n    } else if (Array.isArray(plugin.hooks[hook])) {\n      for (let method of plugin.hooks[hook]) {\n        this.on(hook, method, data)\n      }\n    }\n  }\n}\n\nPattern.prototype.loadPluginMacros = function (plugin) {\n  for (let macro in plugin.macros) {\n    if (typeof plugin.macros[macro] === 'function') {\n      this.macro(macro, plugin.macros[macro])\n    }\n  }\n}\n\nPattern.prototype.macro = function (key, method) {\n  this.macros[key] = method\n}\n\n/** Packs parts in a 2D space and sets pattern size */\nPattern.prototype.pack = function () {\n  if (this.events.error.length > 0) {\n    this.raise.warning(`One or more errors occured. Not packing pattern parts`)\n    return this\n  }\n  let bins = []\n  for (let key in this.parts) {\n    let part = this.parts[key]\n    // Avoid multiple render calls to cause stacking of transforms\n    part.attributes.remove('transform')\n    if (part.render) {\n      part.stack()\n      let width = part.bottomRight.x - part.topLeft.x\n      let height = part.bottomRight.y - part.topLeft.y\n      if (this.settings.layout === true) bins.push({ id: key, width, height })\n      else {\n        if (this.width < width) this.width = width\n        if (this.height < height) this.height = height\n      }\n    }\n  }\n  if (this.settings.layout === true) {\n    let size = pack(bins, { inPlace: true })\n    for (let bin of bins) {\n      let part = this.parts[bin.id]\n      if (bin.x !== 0 || bin.y !== 0) part.attr('transform', `translate(${bin.x}, ${bin.y})`)\n    }\n    this.width = size.width\n    this.height = size.height\n  } else if (typeof this.settings.layout === 'object') {\n    this.width = this.settings.layout.width\n    this.height = this.settings.layout.height\n    for (let partId of Object.keys(this.settings.layout.parts)) {\n      let transforms = this.settings.layout.parts[partId]\n      // Moving\n      if (typeof transforms.move === 'object') {\n        this.parts[partId].attributes.set(\n          'transform',\n          'translate(' + transforms.move.x + ', ' + transforms.move.y + ')'\n        )\n      }\n      // Mirrorring\n      let center = this.parts[partId].topLeft.shiftFractionTowards(\n        this.parts[partId].bottomRight,\n        0.5\n      )\n      let anchor = { x: 0, y: 0 }\n      if (transforms.flipX) {\n        let dx = anchor.x - center.x\n        let transform = `translate(${center.x * -1}, ${center.y * -1})`\n        transform += ' scale(-1, 1)'\n        transform += ` translate(${center.x * -1 + 2 * dx}, ${center.y})`\n        this.parts[partId].attributes.add('transform', transform)\n      }\n      if (transforms.flipY) {\n        let dy = anchor.y - center.y\n        let transform = `translate(${center.x * -1}, ${center.y * -1})`\n        transform += ' scale(1, -1)'\n        transform += ` translate(${center.x}, ${center.y * -1 + 2 * dy})`\n        this.parts[partId].attributes.add('transform', transform)\n      }\n      if (transforms.rotate) {\n        let transform = `rotate(${transforms.rotate}, ${center.x - anchor.x}, ${\n          center.y - anchor.y\n        })`\n        this.parts[partId].attributes.add('transform', transform)\n      }\n    }\n  }\n\n  return this\n}\n\n/** Determines the order to draft parts in, based on dependencies */\nPattern.prototype.draftOrder = function (graph = this.resolveDependencies()) {\n  let sorted = []\n  let visited = {}\n  Object.keys(graph).forEach(function visit(name, ancestors) {\n    if (!Array.isArray(ancestors)) ancestors = []\n    ancestors.push(name)\n    visited[name] = true\n    if (typeof graph[name] !== 'undefined') {\n      graph[name].forEach(function (dep) {\n        if (visited[dep]) return\n        visit(dep, ancestors.slice(0))\n      })\n    }\n    if (sorted.indexOf(name) < 0) sorted.push(name)\n  })\n\n  return sorted\n}\n\n/** Recursively solves part dependencies for a part */\nPattern.prototype.resolveDependency = function (\n  seen,\n  part,\n  graph = this.config.dependencies,\n  deps = []\n) {\n  if (typeof seen[part] === 'undefined') seen[part] = true\n  if (typeof graph[part] === 'string') graph[part] = [graph[part]]\n  if (Array.isArray(graph[part])) {\n    if (graph[part].length === 0) return []\n    else {\n      if (deps.indexOf(graph[part]) === -1) deps.push(...graph[part])\n      for (let apart of graph[part]) deps.concat(this.resolveDependency(seen, apart, graph, deps))\n    }\n  }\n\n  return deps\n}\n\n/** Resolves part dependencies into a flat array */\nPattern.prototype.resolveDependencies = function (graph = this.config.dependencies) {\n  for (let i in this.config.inject) {\n    let dependency = this.config.inject[i]\n    if (typeof this.config.dependencies[i] === 'undefined') this.config.dependencies[i] = dependency\n    else if (this.config.dependencies[i] !== dependency) {\n      if (typeof this.config.dependencies[i] === 'string')\n        this.config.dependencies[i] = [this.config.dependencies[i], dependency]\n      else if (Array.isArray(this.config.dependencies[i])) {\n        if (this.config.dependencies[i].indexOf(dependency) === -1)\n          this.config.dependencies[i].push(dependency)\n      } else {\n        this.raise.error('Part dependencies should be a string or an array of strings')\n        throw new Error('Part dependencies should be a string or an array of strings')\n      }\n    }\n    // Parts both in the parts and dependencies array trip up the dependency resolver\n    if (Array.isArray(this.config.parts)) {\n      let pos = this.config.parts.indexOf(this.config.inject[i])\n      if (pos !== -1) this.config.parts.splice(pos, 1)\n    }\n  }\n\n  // Include parts outside the dependency graph\n  if (Array.isArray(this.config.parts)) {\n    for (let part of this.config.parts) {\n      if (typeof this.config.dependencies[part] === 'undefined') this.config.dependencies[part] = []\n    }\n  }\n\n  let resolved = {}\n  let seen = {}\n  for (let part in graph) resolved[part] = this.resolveDependency(seen, part, graph)\n  for (let part in seen) if (typeof resolved[part] === 'undefined') resolved[part] = []\n\n  return resolved\n}\n\n/** Determines whether a part is needed\n * This depends on the 'only' setting and the\n * configured dependencies.\n */\nPattern.prototype.needs = function (partName) {\n  if (typeof this.settings.only === 'undefined' || this.settings.only === false) return true\n  else if (typeof this.settings.only === 'string') {\n    if (this.settings.only === partName) return true\n    if (Array.isArray(this.config.resolvedDependencies[this.settings.only])) {\n      for (let dependency of this.config.resolvedDependencies[this.settings.only]) {\n        if (dependency === partName) return true\n      }\n    }\n  } else if (Array.isArray(this.settings.only)) {\n    for (let part of this.settings.only) {\n      if (part === partName) return true\n      for (let dependency of this.config.resolvedDependencies[part]) {\n        if (dependency === partName) return true\n      }\n    }\n  }\n\n  return false\n}\n\n/* Checks whether a part is hidden in the config */\nPattern.prototype.isHidden = function (partName) {\n  if (Array.isArray(this.config.hide)) {\n    if (this.config.hide.indexOf(partName) !== -1) return true\n  }\n\n  return false\n}\n\n/** Determines whether a part is wanted by the user\n * This depends on the 'only' setting\n */\nPattern.prototype.wants = function (partName) {\n  if (typeof this.settings.only === 'undefined' || this.settings.only === false) {\n    if (this.isHidden(partName)) return false\n  } else if (typeof this.settings.only === 'string') {\n    if (this.settings.only === partName) return true\n    return false\n  } else if (Array.isArray(this.settings.only)) {\n    for (let part of this.settings.only) {\n      if (part === partName) return true\n    }\n    return false\n  }\n\n  return true\n}\n\n/** Returns props required to render this pattern through\n *  an external renderer (eg. a React component)\n */\nPattern.prototype.getRenderProps = function () {\n  // Run pre-render hook\n  let svg = new Svg(this)\n  svg.hooks = this.hooks\n  svg.runHooks('preRender')\n\n  this.pack()\n  let props = { svg }\n  props.width = this.width\n  props.height = this.height\n  props.settings = this.settings\n  props.events = {\n    debug: this.events.debug,\n    info: this.events.info,\n    warning: this.events.warning,\n    error: this.events.error,\n  }\n  props.parts = {}\n  for (let p in this.parts) {\n    if (this.parts[p].render) {\n      props.parts[p] = {\n        paths: this.parts[p].paths,\n        points: this.parts[p].points,\n        snippets: this.parts[p].snippets,\n        attributes: this.parts[p].attributes,\n        height: this.parts[p].height,\n        width: this.parts[p].width,\n        bottomRight: this.parts[p].bottomRight,\n        topLeft: this.parts[p].topLeft,\n      }\n    }\n  }\n\n  return props\n}\n","import Pattern from './pattern'\n\nexport default function Design(config, plugins = false, conditionalPlugins = false) {\n  const pattern = function (settings) {\n    Pattern.call(this, config)\n    // Load plugins\n    if (Array.isArray(plugins)) for (let plugin of plugins) this.use(plugin)\n    else if (plugins) this.use(plugins)\n    // Load conditional plugins\n    if (Array.isArray(conditionalPlugins))\n      for (let plugin of conditionalPlugins) this.useIf(plugin, settings)\n    else if (conditionalPlugins.plugin && conditionalPlugins.condition)\n      this.useIf(conditionalPlugins, settings)\n\n    this.apply(settings)\n\n    return this\n  }\n\n  // Set up inheritance\n  pattern.prototype = Object.create(Pattern.prototype)\n  pattern.prototype.constructor = pattern\n\n  // Make config available without need to instantiate pattern\n  pattern.config = config\n\n  return pattern\n}\n","import Design from './design'\nimport Pattern from './pattern'\nimport Point from './point'\nimport Path from './path'\nimport Snippet from './snippet'\nimport * as utils from './utils'\nimport { version } from '../package.json'\n\nexport default {\n  version,\n  Design,\n  Pattern,\n  Point,\n  Path,\n  Snippet,\n  utils,\n  patterns: {},\n  plugins: {},\n}\n"]},"metadata":{},"sourceType":"module"}