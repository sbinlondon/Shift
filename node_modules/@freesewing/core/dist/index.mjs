/**
 * @freesewing/core | v2.17.0
 * A library for creating made-to-measure sewing patterns
 * (c) 2021 Joost De Cock <joost@joost.at> (https://github.com/joostdecock)
 * @license MIT
 */
function Attributes() {
  this.list = {};
}
/** Adds an attribute */


Attributes.prototype.add = function (name, value) {
  if (typeof this.list[name] === 'undefined') {
    this.list[name] = [];
  }

  this.list[name].push(value);
  return this;
};
/** Sets an attribute, overwriting existing value */


Attributes.prototype.set = function (name, value) {
  this.list[name] = [value];
  return this;
};
/** Removes an attribute */


Attributes.prototype.remove = function (name) {
  delete this.list[name];
  return this;
};
/** Retrieves an attribute */


Attributes.prototype.get = function (name) {
  if (typeof this.list[name] === 'undefined') return false;else return this.list[name].join(' ');
};
/** Retrieves an attribute as array*/


Attributes.prototype.getAsArray = function (name) {
  if (typeof this.list[name] === 'undefined') return false;else return this.list[name];
};
/** Returns SVG code for attributes */


Attributes.prototype.render = function () {
  let svg = '';

  for (let key in this.list) {
    svg += ` ${key}="${this.list[key].join(' ')}"`;
  }

  return svg;
};
/** Returns CSS code for attributes */


Attributes.prototype.renderAsCss = function () {
  let css = '';

  for (let key in this.list) {
    css += ` ${key}:${this.list[key].join(' ')};`;
  }

  return css;
};
/** Returns SVG code for attributes with a fiven prefix
 * typically used for data-text*/


Attributes.prototype.renderIfPrefixIs = function (prefix = '') {
  let svg = '';
  let prefixLen = prefix.length;

  for (let key in this.list) {
    if (key.substr(0, prefixLen) === prefix) {
      svg += ` ${key.substr(prefixLen)}="${this.list[key].join(' ')}"`;
    }
  }

  return svg;
};
/** Returns a props object for attributes with a fiven prefix
 * typically used for data-text*/


Attributes.prototype.asPropsIfPrefixIs = function (prefix = '') {
  let props = {};
  let prefixLen = prefix.length;

  for (let key in this.list) {
    if (key.substr(0, prefixLen) === prefix) {
      let propKey = key.substr(prefixLen);
      if (propKey === 'class') propKey = 'className';
      props[propKey] = this.get(key);
    }
  }

  return props;
};
/** Returns a deep copy of this */


Attributes.prototype.clone = function () {
  let clone = new Attributes();
  clone.list = JSON.parse(JSON.stringify(this.list));
  return clone;
};

function Point(x, y, debug = false) {
  this.x = x;
  this.y = y;
  this.attributes = new Attributes();
  Object.defineProperty(this, 'debug', {
    value: debug,
    configurable: true
  });
}
/** Adds the raise method for a path not created through the proxy **/


Point.prototype.withRaise = function (raise = false) {
  if (raise) Object.defineProperty(this, 'raise', {
    value: raise
  });
  return this;
};
/** Debug method to validate point data **/


Point.prototype.check = function () {
  if (typeof this.x !== 'number') this.raise.warning('X value of `Point` is not a number');
  if (typeof this.y !== 'number') this.raise.warning('Y value of `Point` is not a number');
};
/** Radians to degrees */


Point.prototype.rad2deg = function (radians) {
  return radians * 57.29577951308232;
};
/** Degrees to radians */


Point.prototype.deg2rad = function (degrees) {
  return degrees / 57.29577951308232;
};
/** Adds an attribute. This is here to make this call chainable in assignment */


Point.prototype.attr = function (name, value, overwrite = false) {
  if (this.debug) this.check();
  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);
  return this;
};
/** Returns the distance between this point and that point */


Point.prototype.dist = function (that) {
  if (this.debug) {
    this.check();
    that.check();
  }

  let dx = this.x - that.x;
  let dy = this.y - that.y;
  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
};
/** Returns slope of a line made by this point and that point */


Point.prototype.slope = function (that) {
  if (this.debug) {
    this.check();
    that.check();
  }

  return (that.y - this.y) / (that.x - this.x);
};
/** Returns the x-delta between this point and that point */


Point.prototype.dx = function (that) {
  if (this.debug) {
    this.check();
    that.check();
  }

  return that.x - this.x;
};
/** Returns the y-delta between this point and that point */


Point.prototype.dy = function (that) {
  if (this.debug) {
    this.check();
    that.check();
  }

  return that.y - this.y;
};
/** Returns the angle between this point and that point */


Point.prototype.angle = function (that) {
  if (this.debug) {
    this.check();
    that.check();
  }

  let rad = Math.atan2(-1 * this.dy(that), this.dx(that));

  while (rad < 0) rad += 2 * Math.PI;

  return this.rad2deg(rad);
};
/** Rotate this point deg around that point */


Point.prototype.rotate = function (deg, that) {
  if (this.debug) {
    this.check();
    that.check();
    if (typeof deg !== 'number') this.raise.warning('Called `Point.rotate(deg,that)` but `deg` is not a number');
    if (that instanceof Point !== true) this.raise.warning('Called `Point.rotate(deg,that)` but `that` is not a `Point` object');
  }

  let radius = this.dist(that);
  let angle = this.angle(that);
  let x = that.x + radius * Math.cos(this.deg2rad(angle + deg)) * -1;
  let y = that.y + radius * Math.sin(this.deg2rad(angle + deg));
  return new Point(x, y, this.debug).withRaise(this.raise);
};
/** returns an identical copy of this point */


Point.prototype.copy = function () {
  if (this.debug) this.check();
  return new Point(this.x, this.y, this.debug).withRaise(this.raise);
};
/** Mirrors this point around X value of that point */


Point.prototype.flipX = function (that = false) {
  if (this.debug) {
    this.check();

    if (that) {
      if (that instanceof Point !== true) this.raise.warning('Called `Point.rotate(deg,that)` but `that` is not a `Point` object');
      that.check();
    }
  }

  if (that === false || that.x === 0) return new Point(this.x * -1, this.y, this.debug).withRaise(this.raise);else return new Point(that.x + this.dx(that), this.y, this.debug).withRaise(this.raise);
};
/** Mirrors this point around Y value of that point */


Point.prototype.flipY = function (that = false) {
  if (this.debug) {
    this.check();

    if (that) {
      if (that instanceof Point !== true) this.raise.warning('Called `Point.flipY(that)` but `that` is not a `Point` object');
      that.check();
    }
  }

  if (that === false || that.y === 0) return new Point(this.x, this.y * -1, this.debug).withRaise(this.raise);else return new Point(this.x, that.y + this.dy(that), this.debug).withRaise(this.raise);
};
/** Shifts this point distance in the deg direction */


Point.prototype.shift = function (deg, distance) {
  if (this.debug) {
    this.check();
    if (typeof distance !== 'number') this.raise.warning('Called `Point.shift` but `distance` is not a number');
  }

  let p = this.copy();
  p.x += distance;
  return p.rotate(deg, this);
};
/** Shifts this point distance in the direction of that point */


Point.prototype.shiftTowards = function (that, distance) {
  if (this.debug) {
    if (typeof distance !== 'number') this.raise.warning('Called `Point.shiftTowards` but `distance` is not a number');
    if (that instanceof Point !== true) this.raise.warning('Called `Point.shiftTowards(that, distance)` but `that` is not a `Point` object');
    this.check();
    that.check();
  }

  if (this.debug) this.check();
  return this.shift(this.angle(that), distance);
};
/** Checks whether this has the same coordinates as that */


Point.prototype.sitsOn = function (that) {
  if (this.debug) {
    if (that instanceof Point !== true) this.raise.warning('Called `Point.sitsOn(that)` but `that` is not a `Point` object');
    this.check();
    that.check();
  }

  if (this.x === that.x && this.y === that.y) return true;else return false;
};
/** Checks whether this has roughly the same coordinates as that */


Point.prototype.sitsRoughlyOn = function (that) {
  if (this.debug) {
    if (that instanceof Point !== true) this.raise.warning('Called `Point.sitsRoughlyOn(that)` but `that` is not a `Point` object');
    this.check();
    that.check();
  }

  if (Math.round(this.x) === Math.round(that.x) && Math.round(this.y) === Math.round(that.y)) return true;else return false;
};
/** Shifts this point fraction of the distance towards that point */


Point.prototype.shiftFractionTowards = function (that, fraction) {
  if (this.debug) {
    if (that instanceof Point !== true) this.raise.warning('Called `Point.shiftFractionTowards(that, fraction)` but `that` is not a `Point` object');
    if (typeof fraction !== 'number') this.raise.warning('Called `Point.shiftFractionTowards` but `fraction` is not a number');
    this.check();
    that.check();
  }

  return this.shiftTowards(that, this.dist(that) * fraction);
};
/** Shifts this point distance beyond that point */


Point.prototype.shiftOutwards = function (that, distance) {
  if (this.debug) {
    if (that instanceof Point !== true) this.raise.warning('Called `Point.shiftOutwards(that, distance)` but `that` is not a `Point` object');
    if (typeof distance !== 'number') this.raise.warning('Called `Point.shiftOutwards(that, distance)` but `distance` is not a number');
    this.check();
    that.check();
  }

  return this.shiftTowards(that, this.dist(that) + distance);
};
/** Returns a deep copy of this */


Point.prototype.clone = function () {
  if (this.debug) this.check();
  let clone = new Point(this.x, this.y, this.debug).withRaise(this.raise);
  clone.attributes = this.attributes.clone();
  return clone;
};
/** Applies a translate transform */


Point.prototype.translate = function (x, y) {
  if (this.debug) {
    this.check();
    if (typeof x !== 'number') this.raise.warning('Called `Point.translate(x,y)` but `x` is not a number');
    if (typeof y !== 'number') this.raise.warning('Called `Point.translate(x,y)` but `y` is not a number');
  }

  let p = this.copy();
  p.x += x;
  p.y += y;
  return p;
};

const {
  abs: abs$1,
  cos: cos$1,
  sin: sin$1,
  acos: acos$1,
  atan2,
  sqrt: sqrt$1,
  pow
} = Math; // cube root function yielding real roots

function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
} // trig constants


const pi$1 = Math.PI,
      tau = 2 * pi$1,
      quart = pi$1 / 2,
      // float precision significant decimal
epsilon = 0.000001,
      // extremas used in bbox calculation and similar algorithms
nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,
      nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,
      // a zero coordinate, which is surprisingly useful
ZERO = {
  x: 0,
  y: 0,
  z: 0
}; // Bezier utility functions

const utils$1 = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],
  arcfn: function (t, derivativeFn) {
    const d = derivativeFn(t);
    let l = d.x * d.x + d.y * d.y;

    if (typeof d.z !== "undefined") {
      l += d.z * d.z;
    }

    return sqrt$1(l);
  },
  compute: function (t, points, _3d) {
    // shortcuts
    if (t === 0) {
      points[0].t = 0;
      return points[0];
    }

    const order = points.length - 1;

    if (t === 1) {
      points[order].t = 1;
      return points[order];
    }

    const mt = 1 - t;
    let p = points; // constant?

    if (order === 0) {
      points[0].t = t;
      return points[0];
    } // linear?


    if (order === 1) {
      const ret = {
        x: mt * p[0].x + t * p[1].x,
        y: mt * p[0].y + t * p[1].y,
        t: t
      };

      if (_3d) {
        ret.z = mt * p[0].z + t * p[1].z;
      }

      return ret;
    } // quadratic/cubic curve?


    if (order < 4) {
      let mt2 = mt * mt,
          t2 = t * t,
          a,
          b,
          c,
          d = 0;

      if (order === 2) {
        p = [p[0], p[1], p[2], ZERO];
        a = mt2;
        b = mt * t * 2;
        c = t2;
      } else if (order === 3) {
        a = mt2 * mt;
        b = mt2 * t * 3;
        c = mt * t2 * 3;
        d = t * t2;
      }

      const ret = {
        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
        t: t
      };

      if (_3d) {
        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
      }

      return ret;
    } // higher order curves: use de Casteljau's computation


    const dCpts = JSON.parse(JSON.stringify(points));

    while (dCpts.length > 1) {
      for (let i = 0; i < dCpts.length - 1; i++) {
        dCpts[i] = {
          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t
        };

        if (typeof dCpts[i].z !== "undefined") {
          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
        }
      }

      dCpts.splice(dCpts.length - 1, 1);
    }

    dCpts[0].t = t;
    return dCpts[0];
  },
  computeWithRatios: function (t, points, ratios, _3d) {
    const mt = 1 - t,
          r = ratios,
          p = points;
    let f1 = r[0],
        f2 = r[1],
        f3 = r[2],
        f4 = r[3],
        d; // spec for linear

    f1 *= mt;
    f2 *= t;

    if (p.length === 2) {
      d = f1 + f2;
      return {
        x: (f1 * p[0].x + f2 * p[1].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
        t: t
      };
    } // upgrade to quadratic


    f1 *= mt;
    f2 *= 2 * mt;
    f3 *= t * t;

    if (p.length === 3) {
      d = f1 + f2 + f3;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
        t: t
      };
    } // upgrade to cubic


    f1 *= mt;
    f2 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t * t * t;

    if (p.length === 4) {
      d = f1 + f2 + f3 + f4;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
        t: t
      };
    }
  },
  derive: function (points, _3d) {
    const dpoints = [];

    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
      const list = [];

      for (let j = 0, dpt; j < c; j++) {
        dpt = {
          x: c * (p[j + 1].x - p[j].x),
          y: c * (p[j + 1].y - p[j].y)
        };

        if (_3d) {
          dpt.z = c * (p[j + 1].z - p[j].z);
        }

        list.push(dpt);
      }

      dpoints.push(list);
      p = list;
    }

    return dpoints;
  },
  between: function (v, m, M) {
    return m <= v && v <= M || utils$1.approximately(v, m) || utils$1.approximately(v, M);
  },
  approximately: function (a, b, precision) {
    return abs$1(a - b) <= (precision || epsilon);
  },
  length: function (derivativeFn) {
    const z = 0.5,
          len = utils$1.Tvalues.length;
    let sum = 0;

    for (let i = 0, t; i < len; i++) {
      t = z * utils$1.Tvalues[i] + z;
      sum += utils$1.Cvalues[i] * utils$1.arcfn(t, derivativeFn);
    }

    return z * sum;
  },
  map: function (v, ds, de, ts, te) {
    const d1 = de - ds,
          d2 = te - ts,
          v2 = v - ds,
          r = v2 / d1;
    return ts + d2 * r;
  },
  lerp: function (r, v1, v2) {
    const ret = {
      x: v1.x + r * (v2.x - v1.x),
      y: v1.y + r * (v2.y - v1.y)
    };

    if (v1.z !== undefined && v2.z !== undefined) {
      ret.z = v1.z + r * (v2.z - v1.z);
    }

    return ret;
  },
  pointToString: function (p) {
    let s = p.x + "/" + p.y;

    if (typeof p.z !== "undefined") {
      s += "/" + p.z;
    }

    return s;
  },
  pointsToString: function (points) {
    return "[" + points.map(utils$1.pointToString).join(", ") + "]";
  },
  copy: function (obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function (o, v1, v2) {
    const dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1 * dy2 - dy1 * dx2,
          dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function (v, d) {
    const s = "" + v;
    const pos = s.indexOf(".");
    return parseFloat(s.substring(0, pos + 1 + d));
  },
  dist: function (p1, p2) {
    const dx = p1.x - p2.x,
          dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function (LUT, point) {
    let mdist = pow(2, 63),
        mpos,
        d;
    LUT.forEach(function (p, idx) {
      d = utils$1.dist(point, p);

      if (d < mdist) {
        mdist = d;
        mpos = idx;
      }
    });
    return {
      mdist: mdist,
      mpos: mpos
    };
  },
  abcratio: function (t, n) {
    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }

    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }

    const bottom = pow(t, n) + pow(1 - t, n),
          top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function (t, n) {
    // see u(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }

    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }

    const top = pow(1 - t, n),
          bottom = pow(t, n) + top;
    return top / bottom;
  },
  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
          ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
          d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

    if (d == 0) {
      return false;
    }

    return {
      x: nx / d,
      y: ny / d
    };
  },
  lli4: function (p1, p2, p3, p4) {
    const x1 = p1.x,
          y1 = p1.y,
          x2 = p2.x,
          y2 = p2.y,
          x3 = p3.x,
          y3 = p3.y,
          x4 = p4.x,
          y4 = p4.y;
    return utils$1.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function (v1, v2) {
    return utils$1.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function (p1, p2) {
    const x1 = p1.x,
          y1 = p1.y,
          x2 = p2.x,
          y2 = p2.y,
          dx = (x2 - x1) / 3,
          dy = (y2 - y1) / 3;
    return new Bezier(x1, y1, x1 + dx, y1 + dy, x1 + 2 * dx, y1 + 2 * dy, x2, y2);
  },
  findbbox: function (sections) {
    let mx = nMax,
        my = nMax,
        MX = nMin,
        MY = nMin;
    sections.forEach(function (s) {
      const bbox = s.bbox();
      if (mx > bbox.x.min) mx = bbox.x.min;
      if (my > bbox.y.min) my = bbox.y.min;
      if (MX < bbox.x.max) MX = bbox.x.max;
      if (MY < bbox.y.max) MY = bbox.y.max;
    });
    return {
      x: {
        min: mx,
        mid: (mx + MX) / 2,
        max: MX,
        size: MX - mx
      },
      y: {
        min: my,
        mid: (my + MY) / 2,
        max: MY,
        size: MY - my
      }
    };
  },
  shapeintersections: function (s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils$1.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function (l1) {
      if (l1.virtual) return;
      a2.forEach(function (l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);

        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },
  makeshape: function (forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils$1.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils$1.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward: forward,
      back: back,
      endcap: end,
      bbox: utils$1.findbbox([start, forward, back, end])
    };

    shape.intersections = function (s2) {
      return utils$1.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);
    };

    return shape;
  },
  getminmax: function (curve, d, list) {
    if (!list) return {
      min: 0,
      max: 0
    };
    let min = nMax,
        max = nMin,
        t,
        c;

    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }

    if (list.indexOf(1) === -1) {
      list.push(1);
    }

    for (let i = 0, len = list.length; i < len; i++) {
      t = list[i];
      c = curve.get(t);

      if (c[d] < min) {
        min = c[d];
      }

      if (c[d] > max) {
        max = c[d];
      }
    }

    return {
      min: min,
      mid: (min + max) / 2,
      max: max,
      size: max - min
    };
  },
  align: function (points, line) {
    const tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y - ty, line.p2.x - tx),
          d = function (v) {
      return {
        x: (v.x - tx) * cos$1(a) - (v.y - ty) * sin$1(a),
        y: (v.x - tx) * sin$1(a) + (v.y - ty) * cos$1(a)
      };
    };

    return points.map(d);
  },
  roots: function (points, line) {
    line = line || {
      p1: {
        x: 0,
        y: 0
      },
      p2: {
        x: 1,
        y: 0
      }
    };
    const order = points.length - 1;
    const aligned = utils$1.align(points, line);

    const reduce = function (t) {
      return 0 <= t && t <= 1;
    };

    if (order === 2) {
      const a = aligned[0].y,
            b = aligned[1].y,
            c = aligned[2].y,
            d = a - 2 * b + c;

      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a * c),
              m2 = -a + b,
              v1 = -(m1 + m2) / d,
              v2 = -(-m1 + m2) / d;
        return [v1, v2].filter(reduce);
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);
      }

      return [];
    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm


    const pa = aligned[0].y,
          pb = aligned[1].y,
          pc = aligned[2].y,
          pd = aligned[3].y;
    let d = -pa + 3 * pb - 3 * pc + pd,
        a = 3 * pa - 6 * pb + 3 * pc,
        b = -3 * pa + 3 * pb,
        c = pa;

    if (utils$1.approximately(d, 0)) {
      // this is not a cubic curve.
      if (utils$1.approximately(a, 0)) {
        // in fact, this is not a quadratic curve either.
        if (utils$1.approximately(b, 0)) {
          // in fact in fact, there are no solutions.
          return [];
        } // linear solution:


        return [-c / b].filter(reduce);
      } // quadratic solution:


      const q = sqrt$1(b * b - 4 * a * c),
            a2 = 2 * a;
      return [(q - b) / a2, (-b - q) / a2].filter(reduce);
    } // at this point, we know we need a cubic solution:


    a /= d;
    b /= d;
    c /= d;
    const p = (3 * b - a * a) / 3,
          p3 = p / 3,
          q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
          q2 = q / 2,
          discriminant = q2 * q2 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;

    if (discriminant < 0) {
      const mp3 = -p / 3,
            mp33 = mp3 * mp3 * mp3,
            r = sqrt$1(mp33),
            t = -q / (2 * r),
            cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
            phi = acos$1(cosphi),
            crtr = crt(r),
            t1 = 2 * crtr;
      x1 = t1 * cos$1(phi / 3) - a / 3;
      x2 = t1 * cos$1((phi + tau) / 3) - a / 3;
      x3 = t1 * cos$1((phi + 2 * tau) / 3) - a / 3;
      return [x1, x2, x3].filter(reduce);
    } else if (discriminant === 0) {
      u1 = q2 < 0 ? crt(-q2) : -crt(q2);
      x1 = 2 * u1 - a / 3;
      x2 = -u1 - a / 3;
      return [x1, x2].filter(reduce);
    } else {
      const sd = sqrt$1(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      return [u1 - v1 - a / 3].filter(reduce);
    }
  },
  droots: function (p) {
    // quadratic roots are easy
    if (p.length === 3) {
      const a = p[0],
            b = p[1],
            c = p[2],
            d = a - 2 * b + c;

      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a * c),
              m2 = -a + b,
              v1 = -(m1 + m2) / d,
              v2 = -(-m1 + m2) / d;
        return [v1, v2];
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * (b - c))];
      }

      return [];
    } // linear roots are even easier


    if (p.length === 2) {
      const a = p[0],
            b = p[1];

      if (a !== b) {
        return [a / (a - b)];
      }

      return [];
    }

    return [];
  },
  curvature: function (t, d1, d2, _3d, kOnly) {
    let num,
        dnm,
        adk,
        dk,
        k = 0,
        r = 0; //
    // We're using the following formula for curvature:
    //
    //              x'y" - y'x"
    //   k(t) = ------------------
    //           (x'² + y'²)^(3/2)
    //
    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition
    //
    // With it corresponding 3D counterpart:
    //
    //          sqrt( (y'z" - y"z')² + (z'x" - z"x')² + (x'y" - x"y')²)
    //   k(t) = -------------------------------------------------------
    //                     (x'² + y'² + z'²)^(3/2)
    //

    const d = utils$1.compute(t, d1);
    const dd = utils$1.compute(t, d2);
    const qdsum = d.x * d.x + d.y * d.y;

    if (_3d) {
      num = sqrt$1(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));
      dnm = pow(qdsum + d.z * d.z, 3 / 2);
    } else {
      num = d.x * dd.y - d.y * dd.x;
      dnm = pow(qdsum, 3 / 2);
    }

    if (num === 0 || dnm === 0) {
      return {
        k: 0,
        r: 0
      };
    }

    k = num / dnm;
    r = dnm / num; // We're also computing the derivative of kappa, because
    // there is value in knowing the rate of change for the
    // curvature along the curve. And we're just going to
    // ballpark it based on an epsilon.

    if (!kOnly) {
      // compute k'(t) based on the interval before, and after it,
      // to at least try to not introduce forward/backward pass bias.
      const pk = utils$1.curvature(t - 0.001, d1, d2, _3d, true).k;
      const nk = utils$1.curvature(t + 0.001, d1, d2, _3d, true).k;
      dk = (nk - k + (k - pk)) / 2;
      adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;
    }

    return {
      k: k,
      r: r,
      dk: dk,
      adk: adk
    };
  },
  inflections: function (points) {
    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?

    const p = utils$1.align(points, {
      p1: points[0],
      p2: points.slice(-1)[0]
    }),
          a = p[2].x * p[1].y,
          b = p[3].x * p[1].y,
          c = p[1].x * p[2].y,
          d = p[3].x * p[2].y,
          v1 = 18 * (-3 * a + 2 * b + 3 * c - d),
          v2 = 18 * (3 * a - b - 3 * c),
          v3 = 18 * (c - a);

    if (utils$1.approximately(v1, 0)) {
      if (!utils$1.approximately(v2, 0)) {
        let t = -v3 / v2;
        if (0 <= t && t <= 1) return [t];
      }

      return [];
    }

    const trm = v2 * v2 - 4 * v1 * v3,
          sq = Math.sqrt(trm),
          d2 = 2 * v1;
    if (utils$1.approximately(d2, 0)) return [];
    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {
      return 0 <= r && r <= 1;
    });
  },
  bboxoverlap: function (b1, b2) {
    const dims = ["x", "y"],
          len = dims.length;

    for (let i = 0, dim, l, t, d; i < len; i++) {
      dim = dims[i];
      l = b1[dim].mid;
      t = b2[dim].mid;
      d = (b1[dim].size + b2[dim].size) / 2;
      if (abs$1(l - t) >= d) return false;
    }

    return true;
  },
  expandbox: function (bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }

    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }

    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }

    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }

    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }

    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }

    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;

    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }

    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;

    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },
  pairiteration: function (c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(),
          c2b = c2.bbox(),
          r = 100000,
          threshold = curveIntersectionThreshold || 0.5;

    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + "/" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];
    }

    let cc1 = c1.split(0.5),
        cc2 = c2.split(0.5),
        pairs = [{
      left: cc1.left,
      right: cc2.left
    }, {
      left: cc1.left,
      right: cc2.right
    }, {
      left: cc1.right,
      right: cc2.right
    }, {
      left: cc1.right,
      right: cc2.left
    }];
    pairs = pairs.filter(function (pair) {
      return utils$1.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    if (pairs.length === 0) return results;
    pairs.forEach(function (pair) {
      results = results.concat(utils$1.pairiteration(pair.left, pair.right, threshold));
    });
    results = results.filter(function (v, i) {
      return results.indexOf(v) === i;
    });
    return results;
  },
  getccenter: function (p1, p2, p3) {
    const dx1 = p2.x - p1.x,
          dy1 = p2.y - p1.y,
          dx2 = p3.x - p2.x,
          dy2 = p3.y - p2.y,
          dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart),
          dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart),
          dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart),
          dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart),
          // chord midpoints
    mx1 = (p1.x + p2.x) / 2,
          my1 = (p1.y + p2.y) / 2,
          mx2 = (p2.x + p3.x) / 2,
          my2 = (p2.y + p3.y) / 2,
          // midpoint offsets
    mx1n = mx1 + dx1p,
          my1n = my1 + dy1p,
          mx2n = mx2 + dx2p,
          my2n = my2 + dy2p,
          // intersection of these lines:
    arc = utils$1.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),
          r = utils$1.dist(arc, p1); // arc start/end values, over mid point:

    let s = atan2(p1.y - arc.y, p1.x - arc.x),
        m = atan2(p2.y - arc.y, p2.x - arc.x),
        e = atan2(p3.y - arc.y, p3.x - arc.x),
        _; // determine arc direction (cw/ccw correction)


    if (s < e) {
      // if s<m<e, arc(s, e)
      // if m<s<e, arc(e, s + tau)
      // if s<e<m, arc(e, s + tau)
      if (s > m || m > e) {
        s += tau;
      }

      if (s > e) {
        _ = e;
        e = s;
        s = _;
      }
    } else {
      // if e<m<s, arc(e, s)
      // if m<e<s, arc(s, e + tau)
      // if e<s<m, arc(s, e + tau)
      if (e < m && m < s) {
        _ = e;
        e = s;
        s = _;
      } else {
        e += tau;
      }
    } // assign and done.


    arc.s = s;
    arc.e = e;
    arc.r = r;
    return arc;
  },
  numberSort: function (a, b) {
    return a - b;
  }
};

/**
 * Poly Bezier
 * @param {[type]} curves [description]
 */

class PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;

    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return "[" + this.curves.map(function (curve) {
      return utils$1.pointsToString(curve.points);
    }).join(", ") + "]";
  }

  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }

  length() {
    return this.curves.map(function (v) {
      return v.length();
    }).reduce(function (a, b) {
      return a + b;
    });
  }

  curve(idx) {
    return this.curves[idx];
  }

  bbox() {
    const c = this.curves;
    var bbox = c[0].bbox();

    for (var i = 1; i < c.length; i++) {
      utils$1.expandbox(bbox, c[i].bbox());
    }

    return bbox;
  }

  offset(d) {
    const offset = [];
    this.curves.forEach(function (v) {
      offset.push(...v.offset(d));
    });
    return new PolyBezier(offset);
  }

}

/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/

const {
  abs,
  min,
  max,
  cos,
  sin,
  acos,
  sqrt
} = Math;
const pi = Math.PI; // a zero coordinate, which is surprisingly useful
/**
 * Bezier curve constructor.
 *
 * ...docs pending...
 */

class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;

    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function (point) {
        ["x", "y", "z"].forEach(function (d) {
          if (typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }

    let higher = false;
    const len = args.length;

    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }

        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }

    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";

    const points = this.points = [];

    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point = {
        x: args[idx],
        y: args[idx + 1]
      };

      if (_3d) {
        point.z = args[idx + 2];
      }

      points.push(point);
    }

    const order = this.order = points.length - 1;
    const dims = this.dims = ["x", "y"];
    if (_3d) dims.push("z");
    this.dimlen = dims.length;
    const aligned = utils$1.align(points, {
      p1: points[0],
      p2: points[order]
    });
    this._linear = !aligned.some(p => abs(p.y) > 0.0001);
    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }

  static quadraticFromPoints(p1, p2, p3, t) {
    if (typeof t === "undefined") {
      t = 0.5;
    } // shortcuts, although they're really dumb


    if (t === 0) {
      return new Bezier(p2, p2, p3);
    }

    if (t === 1) {
      return new Bezier(p1, p2, p2);
    } // real fitting.


    const abc = Bezier.getABC(2, p1, p2, p3, t);
    return new Bezier(p1, abc.A, p3);
  }

  static cubicFromPoints(S, B, E, t, d1) {
    if (typeof t === "undefined") {
      t = 0.5;
    }

    const abc = Bezier.getABC(3, S, B, E, t);

    if (typeof d1 === "undefined") {
      d1 = utils$1.dist(B, abc.C);
    }

    const d2 = d1 * (1 - t) / t;
    const selen = utils$1.dist(S, E),
          lx = (E.x - S.x) / selen,
          ly = (E.y - S.y) / selen,
          bx1 = d1 * lx,
          by1 = d1 * ly,
          bx2 = d2 * lx,
          by2 = d2 * ly; // derivation of new hull coordinates

    const e1 = {
      x: B.x - bx1,
      y: B.y - by1
    },
          e2 = {
      x: B.x + bx2,
      y: B.y + by2
    },
          A = abc.A,
          v1 = {
      x: A.x + (e1.x - A.x) / (1 - t),
      y: A.y + (e1.y - A.y) / (1 - t)
    },
          v2 = {
      x: A.x + (e2.x - A.x) / t,
      y: A.y + (e2.y - A.y) / t
    },
          nc1 = {
      x: S.x + (v1.x - S.x) / t,
      y: S.y + (v1.y - S.y) / t
    },
          nc2 = {
      x: E.x + (v2.x - E.x) / (1 - t),
      y: E.y + (v2.y - E.y) / (1 - t)
    }; // ...done

    return new Bezier(S, nc1, nc2, E);
  }

  static getUtils() {
    return utils$1;
  }

  getUtils() {
    return Bezier.getUtils();
  }

  static get PolyBezier() {
    return PolyBezier;
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return utils$1.pointsToString(this.points);
  }

  toSVG() {
    if (this._3d) return false;
    const p = this.points,
          x = p[0].x,
          y = p[0].y,
          s = ["M", x, y, this.order === 2 ? "Q" : "C"];

    for (let i = 1, last = p.length; i < last; i++) {
      s.push(p[i].x);
      s.push(p[i].y);
    }

    return s.join(" ");
  }

  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }

    this.ratios = ratios;
    this._lut = []; //  invalidate any precomputed LUT
  }

  verify() {
    const print = this.coordDigest();

    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }

  coordDigest() {
    return this.points.map(function (c, pos) {
      return "" + pos + c.x + c.y + (c.z ? c.z : 0);
    }).join("");
  }

  update() {
    // invalidate any precomputed LUT
    this._lut = [];
    this.dpoints = utils$1.derive(this.points, this._3d);
    this.computedirection();
  }

  computedirection() {
    const points = this.points;
    const angle = utils$1.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }

  length() {
    return utils$1.length(this.derivative.bind(this));
  }

  static getABC(order = 2, S, B, E, t = 0.5) {
    const u = utils$1.projectionratio(t, order),
          um = 1 - u,
          C = {
      x: u * S.x + um * E.x,
      y: u * S.y + um * E.y
    },
          s = utils$1.abcratio(t, order),
          A = {
      x: B.x + (B.x - C.x) / s,
      y: B.y + (B.y - C.y) / s
    };
    return {
      A,
      B,
      C,
      S,
      E
    };
  }

  getABC(t, B) {
    B = B || this.get(t);
    let S = this.points[0];
    let E = this.points[this.order];
    return Bezier.getABC(this.order, S, B, E, t);
  }

  getLUT(steps) {
    this.verify();
    steps = steps || 100;

    if (this._lut.length === steps) {
      return this._lut;
    }

    this._lut = []; // We want a range from 0 to 1 inclusive, so
    // we decrement and then use <= rather than <:

    steps--;

    for (let i = 0, p, t; i < steps; i++) {
      t = i / (steps - 1);
      p = this.compute(t);
      p.t = t;

      this._lut.push(p);
    }

    return this._lut;
  }

  on(point, error) {
    error = error || 5;
    const lut = this.getLUT(),
          hits = [];

    for (let i = 0, c, t = 0; i < lut.length; i++) {
      c = lut[i];

      if (utils$1.dist(c, point) < error) {
        hits.push(c);
        t += i / lut.length;
      }
    }

    if (!hits.length) return false;
    return t /= hits.length;
  }

  project(point) {
    // step 1: coarse check
    const LUT = this.getLUT(),
          l = LUT.length - 1,
          closest = utils$1.closest(LUT, point),
          mpos = closest.mpos,
          t1 = (mpos - 1) / l,
          t2 = (mpos + 1) / l,
          step = 0.1 / l; // step 2: fine check

    let mdist = closest.mdist,
        t = t1,
        ft = t,
        p;
    mdist += 1;

    for (let d; t < t2 + step; t += step) {
      p = this.compute(t);
      d = utils$1.dist(point, p);

      if (d < mdist) {
        mdist = d;
        ft = t;
      }
    }

    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p = this.compute(ft);
    p.t = ft;
    p.d = mdist;
    return p;
  }

  get(t) {
    return this.compute(t);
  }

  point(idx) {
    return this.points[idx];
  }

  compute(t) {
    if (this.ratios) {
      return utils$1.computeWithRatios(t, this.points, this.ratios, this._3d);
    }

    return utils$1.compute(t, this.points, this._3d, this.ratios);
  }

  raise() {
    const p = this.points,
          np = [p[0]],
          k = p.length;

    for (let i = 1, pi, pim; i < k; i++) {
      pi = p[i];
      pim = p[i - 1];
      np[i] = {
        x: (k - i) / k * pi.x + i / k * pim.x,
        y: (k - i) / k * pi.y + i / k * pim.y
      };
    }

    np[k] = p[k - 1];
    return new Bezier(np);
  }

  derivative(t) {
    return utils$1.compute(t, this.dpoints[0], this._3d);
  }

  dderivative(t) {
    return utils$1.compute(t, this.dpoints[1], this._3d);
  }

  align() {
    let p = this.points;
    return new Bezier(utils$1.align(p, {
      p1: p[0],
      p2: p[p.length - 1]
    }));
  }

  curvature(t) {
    return utils$1.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);
  }

  inflections() {
    return utils$1.inflections(this.points);
  }

  normal(t) {
    return this._3d ? this.__normal3(t) : this.__normal2(t);
  }

  __normal2(t) {
    const d = this.derivative(t);
    const q = sqrt(d.x * d.x + d.y * d.y);
    return {
      x: -d.y / q,
      y: d.x / q
    };
  }

  __normal3(t) {
    // see http://stackoverflow.com/questions/25453159
    const r1 = this.derivative(t),
          r2 = this.derivative(t + 0.01),
          q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),
          q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2; // cross product

    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    };
    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m;
    c.y /= m;
    c.z /= m; // rotation matrix

    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:

    const n = {
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
    return n;
  }

  hull(t) {
    let p = this.points,
        _p = [],
        q = [],
        idx = 0;
    q[idx++] = p[0];
    q[idx++] = p[1];
    q[idx++] = p[2];

    if (this.order === 3) {
      q[idx++] = p[3];
    } // we lerp between all points at each iteration, until we have 1 point left.


    while (p.length > 1) {
      _p = [];

      for (let i = 0, pt, l = p.length - 1; i < l; i++) {
        pt = utils$1.lerp(t, p[i], p[i + 1]);
        q[idx++] = pt;

        _p.push(pt);
      }

      p = _p;
    }

    return q;
  }

  split(t1, t2) {
    // shortcuts
    if (t1 === 0 && !!t2) {
      return this.split(t2).left;
    }

    if (t2 === 1) {
      return this.split(t1).right;
    } // no shortcut: use "de Casteljau" iteration.


    const q = this.hull(t1);
    const result = {
      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),
      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q
    }; // make sure we bind _t1/_t2 information!

    result.left._t1 = utils$1.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils$1.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils$1.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils$1.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done

    if (!t2) {
      return result;
    } // if we have a t2, split again:


    t2 = utils$1.map(t2, t1, 1, 0, 1);
    return result.right.split(t2).left;
  }

  extrema() {
    const result = {};
    let roots = [];
    this.dims.forEach(function (dim) {
      let mfn = function (v) {
        return v[dim];
      };

      let p = this.dpoints[0].map(mfn);
      result[dim] = utils$1.droots(p);

      if (this.order === 3) {
        p = this.dpoints[1].map(mfn);
        result[dim] = result[dim].concat(utils$1.droots(p));
      }

      result[dim] = result[dim].filter(function (t) {
        return t >= 0 && t <= 1;
      });
      roots = roots.concat(result[dim].sort(utils$1.numberSort));
    }.bind(this));
    result.values = roots.sort(utils$1.numberSort).filter(function (v, idx) {
      return roots.indexOf(v) === idx;
    });
    return result;
  }

  bbox() {
    const extrema = this.extrema(),
          result = {};
    this.dims.forEach(function (d) {
      result[d] = utils$1.getminmax(this, d, extrema[d]);
    }.bind(this));
    return result;
  }

  overlaps(curve) {
    const lbbox = this.bbox(),
          tbbox = curve.bbox();
    return utils$1.bboxoverlap(lbbox, tbbox);
  }

  offset(t, d) {
    if (typeof d !== "undefined") {
      const c = this.get(t),
            n = this.normal(t);
      const ret = {
        c: c,
        n: n,
        x: c.x + n.x * d,
        y: c.y + n.y * d
      };

      if (this._3d) {
        ret.z = c.z + n.z * d;
      }

      return ret;
    }

    if (this._linear) {
      const nv = this.normal(0),
            coords = this.points.map(function (p) {
        const ret = {
          x: p.x + t * nv.x,
          y: p.y + t * nv.y
        };

        if (p.z && nv.z) {
          ret.z = p.z + t * nv.z;
        }

        return ret;
      });
      return [new Bezier(coords)];
    }

    return this.reduce().map(function (s) {
      if (s._linear) {
        return s.offset(t)[0];
      }

      return s.scale(t);
    });
  }

  simple() {
    if (this.order === 3) {
      const a1 = utils$1.angle(this.points[0], this.points[3], this.points[1]);
      const a2 = utils$1.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;
    }

    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s = n1.x * n2.x + n1.y * n2.y;

    if (this._3d) {
      s += n1.z * n2.z;
    }

    return abs(acos(s)) < pi / 3;
  }

  reduce() {
    // TODO: examine these var types in more detail...
    let i,
        t1 = 0,
        t2 = 0,
        step = 0.01,
        segment,
        pass1 = [],
        pass2 = []; // first pass: split on extrema

    let extrema = this.extrema().values;

    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }

    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }

    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
      t2 = extrema[i];
      segment = this.split(t1, t2);
      segment._t1 = t1;
      segment._t2 = t2;
      pass1.push(segment);
      t1 = t2;
    } // second pass: further reduce these segments to simple segments


    pass1.forEach(function (p1) {
      t1 = 0;
      t2 = 0;

      while (t2 <= 1) {
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
          segment = p1.split(t1, t2);

          if (!segment.simple()) {
            t2 -= step;

            if (abs(t1 - t2) < step) {
              // we can never form a reduction
              return [];
            }

            segment = p1.split(t1, t2);
            segment._t1 = utils$1.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils$1.map(t2, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t2;
            break;
          }
        }
      }

      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils$1.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }

  scale(d) {
    const order = this.order;
    let distanceFn = false;

    if (typeof d === "function") {
      distanceFn = d;
    }

    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    } // TODO: add special handling for degenerate (=linear) curves.


    const clockwise = this.clockwise;
    const r1 = distanceFn ? distanceFn(0) : d;
    const r2 = distanceFn ? distanceFn(1) : d;
    const v = [this.offset(0, 10), this.offset(1, 10)];
    const points = this.points;
    const np = [];
    const o = utils$1.lli4(v[0], v[0].c, v[1], v[1].c);

    if (!o) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    } // move all points by distance 'd' wrt the origin 'o'
    // move end points by fixed distance along normal.


    [0, 1].forEach(function (t) {
      const p = np[t * order] = utils$1.copy(points[t * order]);
      p.x += (t ? r2 : r1) * v[t].n.x;
      p.y += (t ? r2 : r1) * v[t].n.y;
    });

    if (!distanceFn) {
      // move control points to lie on the intersection of the offset
      // derivative vector, and the origin-through-control vector
      [0, 1].forEach(t => {
        if (order === 2 && !!t) return;
        const p = np[t * order];
        const d = this.derivative(t);
        const p2 = {
          x: p.x + d.x,
          y: p.y + d.y
        };
        np[t + 1] = utils$1.lli4(p, p2, o, points[t + 1]);
      });
      return new Bezier(np);
    } // move control points by "however much necessary to
    // ensure the correct tangent to endpoint".


    [0, 1].forEach(function (t) {
      if (order === 2 && !!t) return;
      var p = points[t + 1];
      var ov = {
        x: p.x - o.x,
        y: p.y - o.y
      };
      var rc = distanceFn ? distanceFn((t + 1) / order) : d;
      if (distanceFn && !clockwise) rc = -rc;
      var m = sqrt(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m;
      ov.y /= m;
      np[t + 1] = {
        x: p.x + rc * ov.x,
        y: p.y + rc * ov.y
      };
    });
    return new Bezier(np);
  }

  outline(d1, d2, d3, d4) {
    d2 = typeof d2 === "undefined" ? d1 : d2;
    const reduced = this.reduce(),
          len = reduced.length,
          fcurves = [];
    let bcurves = [],
        p,
        alen = 0,
        tlen = this.length();
    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";

    function linearDistanceFunction(s, e, tlen, alen, slen) {
      return function (v) {
        const f1 = alen / tlen,
              f2 = (alen + slen) / tlen,
              d = e - s;
        return utils$1.map(v, 0, 1, s + f1 * d, s + f2 * d);
      };
    } // form curve oulines


    reduced.forEach(function (segment) {
      const slen = segment.length();

      if (graduated) {
        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));
        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d2));
      }

      alen += slen;
    }); // reverse the "return" outline

    bcurves = bcurves.map(function (s) {
      p = s.points;

      if (p[3]) {
        s.points = [p[3], p[2], p[1], p[0]];
      } else {
        s.points = [p[2], p[1], p[0]];
      }

      return s;
    }).reverse(); // form the endcaps as lines

    const fs = fcurves[0].points[0],
          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],
          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],
          be = bcurves[0].points[0],
          ls = utils$1.makeline(bs, fs),
          le = utils$1.makeline(fe, be),
          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
          segments.length;
    return new PolyBezier(segments);
  }

  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves;
    const shapes = [];

    for (let i = 1, len = outline.length; i < len / 2; i++) {
      const shape = utils$1.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);
      shape.startcap.virtual = i > 1;
      shape.endcap.virtual = i < len / 2 - 1;
      shapes.push(shape);
    }

    return shapes;
  }

  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);

    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }

    if (curve instanceof Bezier) {
      curve = curve.reduce();
    }

    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
  }

  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x),
          my = min(line.p1.y, line.p2.y),
          MX = max(line.p1.x, line.p2.x),
          MY = max(line.p1.y, line.p2.y);
    return utils$1.roots(this.points, line).filter(t => {
      var p = this.get(t);
      return utils$1.between(p.x, mx, MX) && utils$1.between(p.y, my, MY);
    });
  }

  selfintersects(curveIntersectionThreshold) {
    // "simple" curves cannot intersect with their direct
    // neighbour, so for each segment X we check whether
    // it intersects [0:x-2][x+2:last].
    const reduced = this.reduce(),
          len = reduced.length - 2,
          results = [];

    for (let i = 0, result, left, right; i < len; i++) {
      left = reduced.slice(i, i + 1);
      right = reduced.slice(i + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }

    return results;
  }

  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = []; // step 1: pair off any overlapping segments

    c1.forEach(function (l) {
      c2.forEach(function (r) {
        if (l.overlaps(r)) {
          pairs.push({
            left: l,
            right: r
          });
        }
      });
    }); // step 2: for each pairing, run through the convergence algorithm.

    let intersections = [];
    pairs.forEach(function (pair) {
      const result = utils$1.pairiteration(pair.left, pair.right, curveIntersectionThreshold);

      if (result.length > 0) {
        intersections = intersections.concat(result);
      }
    });
    return intersections;
  }

  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }

  _error(pc, np1, s, e) {
    const q = (e - s) / 4,
          c1 = this.get(s + q),
          c2 = this.get(e - q),
          ref = utils$1.dist(pc, np1),
          d1 = utils$1.dist(pc, c1),
          d2 = utils$1.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }

  _iterate(errorThreshold, circles) {
    let t_s = 0,
        t_e = 1,
        safety; // we do a binary search to find the "good `t` closest to no-longer-good"

    do {
      safety = 0; // step 1: start with the maximum possible arc

      t_e = 1; // points:

      let np1 = this.get(t_s),
          np2,
          np3,
          arc,
          prev_arc; // booleans:

      let curr_good = false,
          prev_good = false,
          done; // numbers:

      let t_m = t_e,
          prev_e = 1;
 // step 2: find the best possible arc

      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;
        np2 = this.get(t_m);
        np3 = this.get(t_e);
        arc = utils$1.getccenter(np1, np2, np3); //also save the t values

        arc.interval = {
          start: t_s,
          end: t_e
        };

        let error = this._error(arc, np1, t_s, t_e);

        curr_good = error <= errorThreshold;
        done = prev_good && !curr_good;
        if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc

        if (curr_good) {
          // if e is already at max, then we're done for this arc.
          if (t_e >= 1) {
            // make sure we cap at t=1
            arc.interval.end = prev_e = 1;
            prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that
            // the arc's end angle is correct with respect to the bezier end point.

            if (t_e > 1) {
              let d = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils$1.angle({
                x: arc.x,
                y: arc.y
              }, d, this.get(1));
            }

            break;
          } // if not, move it up by half the iteration distance


          t_e = t_e + (t_e - t_s) / 2;
        } else {
          // this is a bad arc: we need to move 'e' down to find a good arc
          t_e = t_m;
        }
      } while (!done && safety++ < 100);

      if (safety >= 100) {
        break;
      } // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);


      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);

    return circles;
  }

}

function Path(debug = false) {
  this.render = true;
  this.topLeft = false;
  this.bottomRight = false;
  this.attributes = new Attributes();
  this.ops = [];
  Object.defineProperty(this, 'debug', {
    value: debug,
    configurable: true
  });
}
/** Adds the raise method for a path not created through the proxy **/


Path.prototype.withRaise = function (raise = false) {
  if (raise) Object.defineProperty(this, 'raise', {
    value: raise
  });
  return this;
};
/** Chainable way to set the render property */


Path.prototype.setRender = function (render = true) {
  if (render) this.render = true;else this.render = false;
  if (this.debug) this.raise.debug('Setting `Path.render` to ' + (render ? '`true`' : '`false`'));
  return this;
};
/** Adds a move operation to Point to */


Path.prototype.move = function (to) {
  if (this.debug && to instanceof Point !== true) this.raise.warning('Called `Path.rotate(to)` but `to` is not a `Point` object');
  this.ops.push({
    type: 'move',
    to
  });
  return this;
};
/** Adds a line operation to Point to */


Path.prototype.line = function (to) {
  if (this.debug && to instanceof Point !== true) this.raise.warning('Called `Path.line(to)` but `to` is not a `Point` object');
  this.ops.push({
    type: 'line',
    to
  });
  return this;
};
/** Adds a curve operation via cp1 & cp2 to Point to */


Path.prototype.curve = function (cp1, cp2, to) {
  if (this.debug) {
    if (to instanceof Point !== true) this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `to` is not a `Point` object');
    if (cp1 instanceof Point !== true) this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `cp1` is not a `Point` object');
    if (cp2 instanceof Point !== true) this.raise.warning('Called `Path.curve(cp1, cp2, to)` but `cp2` is not a `Point` object');
  }

  this.ops.push({
    type: 'curve',
    cp1,
    cp2,
    to
  });
  return this;
};
/** Adds a curve operation without cp1 via cp2 to Point to */


Path.prototype._curve = function (cp2, to) {
  if (this.debug) {
    if (to instanceof Point !== true) this.raise.warning('Called `Path._curve(cp2, to)` but `to` is not a `Point` object');
    if (cp2 instanceof Point !== true) this.raise.warning('Called `Path._curve(cp2, to)` but `cp2` is not a `Point` object');
  }

  let cp1 = this.ops.slice(-1).pop().to;
  this.ops.push({
    type: 'curve',
    cp1,
    cp2,
    to
  });
  return this;
};
/** Adds a curve operation via cp1 with no cp2 to Point to */


Path.prototype.curve_ = function (cp1, to) {
  if (this.debug) {
    if (to instanceof Point !== true) this.raise.warning('Called `Path.curve_(cp1, to)` but `to` is not a `Point` object');
    if (cp1 instanceof Point !== true) this.raise.warning('Called `Path.curve_(cp1, to)` but `cp2` is not a `Point` object');
  }

  let cp2 = to.copy();
  this.ops.push({
    type: 'curve',
    cp1,
    cp2,
    to
  });
  return this;
};
/** Adds a close operation */


Path.prototype.close = function () {
  this.ops.push({
    type: 'close'
  });
  return this;
};
/** Adds a noop operation */


Path.prototype.noop = function (id = false) {
  this.ops.push({
    type: 'noop',
    id
  });
  return this;
};
/** Replace a noop operation with the ops from path */


Path.prototype.insop = function (noopId, path) {
  if (this.debug) {
    if (!noopId) this.raise.warning('Called `Path.insop(noopId, path)` but `noopId` is undefined or false');
    if (path instanceof Path !== true) this.raise.warning('Called `Path.insop(noopId, path) but `path` is not a `Path` object');
  }

  let newPath = this.clone();

  for (let i in newPath.ops) {
    if (newPath.ops[i].type === 'noop' && newPath.ops[i].id === noopId) {
      newPath.ops = newPath.ops.slice(0, i).concat(path.ops).concat(newPath.ops.slice(Number(i) + 1));
    }
  }

  return newPath;
};
/** Adds an attribute. This is here to make this call chainable in assignment */


Path.prototype.attr = function (name, value, overwrite = false) {
  if (this.debug) {
    if (!name) this.raise.warning('Called `Path.attr(name, value, overwrite=false)` but `name` is undefined or false');
    if (typeof value === 'undefined') this.raise.warning('Called `Path.attr(name, value, overwrite=false)` but `value` is undefined');
    if (overwrite) this.raise.debug(`Overwriting \`Path.attribute.${name}\` with ${value} (was: ${this.attributes.get(name)})`);
  }

  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);
  return this;
};
/** Returns SVG pathstring for this path */


Path.prototype.asPathstring = function () {
  let d = '';

  for (let op of this.ops) {
    switch (op.type) {
      case 'move':
        d += `M ${round(op.to.x)},${round(op.to.y)}`;
        break;

      case 'line':
        d += ` L ${round(op.to.x)},${round(op.to.y)}`;
        break;

      case 'curve':
        d += ` C ${round(op.cp1.x)},${round(op.cp1.y)} ${round(op.cp2.x)},${round(op.cp2.y)} ${round(op.to.x)},${round(op.to.y)}`;
        break;

      case 'close':
        d += ' z';
        break;
    }
  }

  return d;
};
/** Returns offset of this path as a new path */


Path.prototype.offset = function (distance) {
  if (typeof distance !== 'number') this.raise.error('Called `Path.offset(distance)` but `distance` is not a number');
  return pathOffset(this, distance, this.raise);
};
/** Returns the length of this path */


Path.prototype.length = function () {
  let current, start;
  let length = 0;

  for (let i in this.ops) {
    let op = this.ops[i];

    if (op.type === 'move') {
      start = op.to;
    } else if (op.type === 'line') {
      length += current.dist(op.to);
    } else if (op.type === 'curve') {
      length += new Bezier({
        x: current.x,
        y: current.y
      }, {
        x: op.cp1.x,
        y: op.cp1.y
      }, {
        x: op.cp2.x,
        y: op.cp2.y
      }, {
        x: op.to.x,
        y: op.to.y
      }).length();
    } else if (op.type === 'close') {
      length += current.dist(start);
    }

    if (op.to) current = op.to;
  }

  return length;
};
/** Returns the startpoint of the path */


Path.prototype.start = function () {
  if (this.ops.length < 1 || typeof this.ops[0].to === 'undefined') this.raise.error('Called `Path.start()` but this path has no drawing operations');
  return this.ops[0].to;
};
/** Returns the endpoint of the path */


Path.prototype.end = function () {
  if (this.ops.length < 1) this.raise.error('Called `Path.end()` but this path has no drawing operations');
  let op = this.ops[this.ops.length - 1];
  if (op.type === 'close') return this.start();else return op.to;
};
/** Finds the bounding box of a path */


Path.prototype.boundary = function () {
  if (this.topLeft) return this; // Cached

  let current;
  let topLeft = new Point(Infinity, Infinity);
  let bottomRight = new Point(-Infinity, -Infinity);
  let edges = [];

  for (let i in this.ops) {
    let op = this.ops[i];

    if (op.type === 'move' || op.type === 'line') {
      if (op.to.x < topLeft.x) {
        topLeft.x = op.to.x;
        edges['leftOp'] = i;
      }

      if (op.to.y < topLeft.y) {
        topLeft.y = op.to.y;
        edges['topOp'] = i;
      }

      if (op.to.x > bottomRight.x) {
        bottomRight.x = op.to.x;
        edges['rightOp'] = i;
      }

      if (op.to.y > bottomRight.y) {
        bottomRight.y = op.to.y;
        edges['bottomOp'] = i;
      }
    } else if (op.type === 'curve') {
      let bb = new Bezier({
        x: current.x,
        y: current.y
      }, {
        x: op.cp1.x,
        y: op.cp1.y
      }, {
        x: op.cp2.x,
        y: op.cp2.y
      }, {
        x: op.to.x,
        y: op.to.y
      }).bbox();

      if (bb.x.min < topLeft.x) {
        topLeft.x = bb.x.min;
        edges['leftOp'] = i;
      }

      if (bb.y.min < topLeft.y) {
        topLeft.y = bb.y.min;
        edges['topOp'] = i;
      }

      if (bb.x.max > bottomRight.x) {
        bottomRight.x = bb.x.max;
        edges['rightOp'] = i;
      }

      if (bb.y.max > bottomRight.y) {
        bottomRight.y = bb.y.max;
        edges['bottomOp'] = i;
      }
    }

    if (op.to) current = op.to;
  }

  this.topLeft = topLeft;
  this.bottomRight = bottomRight;

  for (let side of ['top', 'left', 'bottom', 'right']) {
    let s = side + 'Op';
    this[s] = this.ops[edges[s]];
    this[s].from = this[s].type === 'move' ? this[s].to : this.ops[edges[s] - 1].to;
  }

  return this;
};
/** Returns a deep copy of this */


Path.prototype.clone = function () {
  let clone = new Path(this.debug).withRaise(this.raise).setRender(this.render);
  if (this.topLeft) clone.topLeft = this.topLeft.clone();else clone.topLeft = false;
  if (this.bottomRight) clone.bottomRight = this.bottomRight.clone();else clone.bottomRight = false;
  clone.attributes = this.attributes.clone();
  clone.ops = [];

  for (let i in this.ops) {
    let op = this.ops[i];
    clone.ops[i] = {
      type: op.type
    };

    if (op.type === 'move' || op.type === 'line') {
      clone.ops[i].to = op.to.clone();
    } else if (op.type === 'curve') {
      clone.ops[i].to = op.to.clone();
      clone.ops[i].cp1 = op.cp1.clone();
      clone.ops[i].cp2 = op.cp2.clone();
    } else if (op.type === 'noop') {
      clone.ops[i].id = op.id;
    }
  }

  return clone;
};
/** Joins this with that path, closes them if wanted */


Path.prototype.join = function (that, closed = false) {
  if (that instanceof Path !== true) this.raise.error('Called `Path.join(that)` but `that` is not a `Path` object');
  return joinPaths([this, that], closed, this.raise);
};
/** Offsets a path by distance */


function pathOffset(path, distance, raise) {
  let offset = [];
  let current;
  let closed = false;

  for (let i in path.ops) {
    let op = path.ops[i];

    if (op.type === 'line') {
      let segment = offsetLine(current, op.to, distance, path.debug, path.raise);
      if (segment) offset.push(segment);
    } else if (op.type === 'curve') {
      // We need to avoid a control point sitting on top of start or end
      // because that will break the offset in bezier-js
      let cp1, cp2;

      if (current.sitsRoughlyOn(op.cp1)) {
        cp1 = new Path(path.debug).withRaise(path.raise).move(current).curve(op.cp1, op.cp2, op.to).shiftAlong(2);
      } else cp1 = op.cp1;

      if (op.cp2.sitsRoughlyOn(op.to)) {
        cp2 = new Path(path.debug).withRaise(path.raise).move(op.to).curve(op.cp2, op.cp1, current).shiftAlong(2);
      } else cp2 = op.cp2;

      let b = new Bezier({
        x: current.x,
        y: current.y
      }, {
        x: cp1.x,
        y: cp1.y
      }, {
        x: cp2.x,
        y: cp2.y
      }, {
        x: op.to.x,
        y: op.to.y
      });

      for (let bezier of b.offset(distance)) offset.push(asPath(bezier, path.debug, path.raise));
    } else if (op.type === 'close') closed = true;

    if (op.to) current = op.to;
  }

  return joinPaths(offset, closed, raise);
}
/** Offsets a line by distance */


function offsetLine(from, to, distance, debug = false, raise = false) {
  if (from.x === to.x && from.y === to.y) return false;
  let angle = from.angle(to) - 90;
  return new Path(debug).withRaise(raise).move(from.shift(angle, distance)).line(to.shift(angle, distance));
}
/** Converts a bezier-js instance to a path */


function asPath(bezier, debug = false, raise = false) {
  return new Path(debug).withRaise(raise).move(new Point(bezier.points[0].x, bezier.points[0].y)).curve(new Point(bezier.points[1].x, bezier.points[1].y), new Point(bezier.points[2].x, bezier.points[2].y), new Point(bezier.points[3].x, bezier.points[3].y));
}
/** Joins path segments together into one path */


function joinPaths(paths, closed = false, raise = false) {
  let joint = new Path(paths[0].debug).withRaise(paths[0].raise).move(paths[0].ops[0].to);
  let current;

  for (let p of paths) {
    for (let op of p.ops) {
      if (op.type === 'curve') {
        joint.curve(op.cp1, op.cp2, op.to);
      } else if (op.type !== 'close') {
        // We're using sitsRoughlyOn here to avoid miniscule line segments
        if (current && !op.to.sitsRoughlyOn(current)) joint.line(op.to);
      } else {
        let err = 'Cannot join a closed path with another';
        joint.raise.error(err);
        throw new Error(err);
      }

      if (op.to) current = op.to;
    }
  }

  if (closed) joint.close();
  return joint;
}
/** Returns a point that lies at distance along this */


Path.prototype.shiftAlong = function (distance, stepsPerMm = 25) {
  if (typeof distance !== 'number') this.raise.error('Called `Path.shiftAlong(distance)` but `distance` is not a number');
  let len = 0;
  let current;

  for (let i in this.ops) {
    let op = this.ops[i];

    if (op.type === 'line') {
      let thisLen = op.to.dist(current);
      if (Math.abs(len + thisLen - distance) < 0.1) return op.to;
      if (len + thisLen > distance) return current.shiftTowards(op.to, distance - len);
      len += thisLen;
    } else if (op.type === 'curve') {
      let bezier = new Bezier({
        x: current.x,
        y: current.y
      }, {
        x: op.cp1.x,
        y: op.cp1.y
      }, {
        x: op.cp2.x,
        y: op.cp2.y
      }, {
        x: op.to.x,
        y: op.to.y
      });
      let thisLen = bezier.length();
      if (Math.abs(len + thisLen - distance) < 0.1) return op.to;
      if (len + thisLen > distance) return shiftAlongBezier(distance - len, bezier, thisLen * stepsPerMm);
      len += thisLen;
    }

    current = op.to;
  }

  this.raise.error(`Called \`Path.shiftAlong(distance)\` with a \`distance\` of \`${distance}\` but \`Path.length()\` is only \`${this.length()}\``);
};
/** Returns a point that lies at fraction along this */


Path.prototype.shiftFractionAlong = function (fraction, stepsPerMm = 25) {
  if (typeof fraction !== 'number') this.raise.error('Called `Path.shiftFractionAlong(fraction)` but `fraction` is not a number');
  return this.shiftAlong(this.length() * fraction, stepsPerMm);
};
/** Returns a point that lies at distance along bezier */


function shiftAlongBezier(distance, bezier, steps = 100) {
  let previous, next, t, thisLen;
  let len = 0;

  for (let i = 0; i <= steps; i++) {
    t = i / steps;
    next = bezier.get(t);
    next = new Point(next.x, next.y);

    if (i > 0) {
      thisLen = next.dist(previous);
      if (len + thisLen > distance) return next;else len += thisLen;
    }

    previous = next;
  }
}
/** Returns a point at the top edge of a bounding box of this */


Path.prototype.bbox = function () {
  let bbs = [];
  let current;

  for (let i in this.ops) {
    let op = this.ops[i];

    if (op.type === 'line') {
      bbs.push(lineBoundingBox({
        from: current,
        to: op.to
      }));
    } else if (op.type === 'curve') {
      bbs.push(curveBoundingBox(new Bezier({
        x: current.x,
        y: current.y
      }, {
        x: op.cp1.x,
        y: op.cp1.y
      }, {
        x: op.cp2.x,
        y: op.cp2.y
      }, {
        x: op.to.x,
        y: op.to.y
      })));
    }

    if (op.to) current = op.to;
  }

  return bbbbox(bbs);
};

function lineBoundingBox(line) {
  let from = line.from;
  let to = line.to;

  if (from.x === to.x) {
    if (from.y < to.y) return {
      topLeft: from,
      bottomRight: to
    };else return {
      topLeft: to,
      bottomRight: from
    };
  } else if (from.y === to.y) {
    if (from.x < to.x) return {
      topLeft: from,
      bottomRight: to
    };else return {
      topLeft: to,
      bottomRight: from
    };
  } else if (from.x < to.x) {
    if (from.y < to.y) return {
      topLeft: from,
      bottomRight: to
    };else return {
      topLeft: new Point(from.x, to.y),
      bottomRight: new Point(to.x, from.y)
    };
  } else if (from.x > to.x) {
    if (from.y < to.y) return {
      topLeft: new Point(to.x, from.y),
      bottomRight: new Point(from.x, to.y)
    };else return {
      topLeft: new Point(to.x, to.y),
      bottomRight: new Point(from.x, from.y)
    };
  }
}

function curveBoundingBox(curve) {
  let bb = curve.bbox();
  return {
    topLeft: new Point(bb.x.min, bb.y.min),
    bottomRight: new Point(bb.x.max, bb.y.max)
  };
}

function bbbbox(boxes) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;

  for (let box of boxes) {
    if (box.topLeft.x < minX) minX = box.topLeft.x;
    if (box.topLeft.y < minY) minY = box.topLeft.y;
    if (box.bottomRight.x > maxX) maxX = box.bottomRight.x;
    if (box.bottomRight.y > maxY) maxY = box.bottomRight.y;
  }

  return {
    topLeft: new Point(minX, minY),
    bottomRight: new Point(maxX, maxY)
  };
}
/** Returns a reversed version of this */


Path.prototype.reverse = function () {
  let sections = [];
  let current;
  let closed = false;

  for (let i in this.ops) {
    let op = this.ops[i];

    if (op.type === 'line') {
      if (!op.to.sitsOn(current)) sections.push(new Path(this.debug).withRaise(this.raise).move(op.to).line(current));
    } else if (op.type === 'curve') {
      sections.push(new Path(this.debug).withRaise(this.raise).move(op.to).curve(op.cp2, op.cp1, current));
    } else if (op.type === 'close') {
      closed = true;
    }

    if (op.to) current = op.to;
  }

  let rev = new Path(this.debug).withRaise(this.raise).move(current);

  for (let section of sections.reverse()) rev.ops.push(section.ops[1]);

  if (closed) rev.close();
  return rev;
};
/** Returns the point at an edge of this path */


Path.prototype.edge = function (side) {
  this.boundary();
  if (side === 'topLeft') return this.topLeft;else if (side === 'bottomRight') return this.bottomRight;else if (side === 'topRight') return new Point(this.bottomRight.x, this.topLeft.y);else if (side === 'bottomLeft') return new Point(this.topLeft.x, this.bottomRight.y);else {
    let s = side + 'Op';
    if (this[s].type === 'move') return this[s].to;else if (this[s].type === 'line') {
      if (side === 'top') {
        if (this.topOp.to.y < this.topOp.from.y) return this.topOp.to;else return this.topOp.from;
      } else if (side === 'left') {
        if (this.leftOp.to.x < this.leftOp.from.x) return this.leftOp.to;else return this.leftOp.from;
      } else if (side === 'bottom') {
        if (this.bottomOp.to.y > this.bottomOp.from.y) return this.bottomOp.to;else return this.bottomOp.from;
      } else if (side === 'right') {
        if (this.rightOp.to.x > this.rightOp.from.x) return this.rightOp.to;else return this.rightOp.from;
      }
    } else if (this[s].type === 'curve') {
      let curve = edgeCurveAsBezier(this[s]);
      return curveEdge(curve, side);
    }
  }
  this.raise.error(`Unable to find \`Path.edge(side)\` for side ${side}`);
};

function edgeCurveAsBezier(op) {
  return new Bezier({
    x: op.from.x,
    y: op.from.y
  }, {
    x: op.cp1.x,
    y: op.cp1.y
  }, {
    x: op.cp2.x,
    y: op.cp2.y
  }, {
    x: op.to.x,
    y: op.to.y
  });
}
/** Divides a path into atomic paths */


Path.prototype.divide = function () {
  let paths = [];
  let current, start;

  for (let i in this.ops) {
    let op = this.ops[i];

    if (op.type === 'move') {
      start = op.to;
    } else if (op.type === 'line') {
      if (!op.to.sitsRoughlyOn(current)) paths.push(new Path(this.debug).withRaise(this.raise).move(current).line(op.to));
    } else if (op.type === 'curve') {
      paths.push(new Path(this.debug).withRaise(this.raise).move(current).curve(op.cp1, op.cp2, op.to));
    } else if (op.type === 'close') {
      paths.push(new Path(this.debug).withRaise(this.raise).move(current).line(start));
    }

    if (op.to) current = op.to;
  }

  return paths;
};
/** Finds intersections between this path and an X value */


Path.prototype.intersectsX = function (x) {
  if (typeof x !== 'number') this.raise.error('Called `Path.intersectsX(x)` but `x` is not a number');
  return this.intersectsAxis(x, 'x');
};
/** Finds intersections between this path and an Y value */


Path.prototype.intersectsY = function (y) {
  if (typeof y !== 'number') this.raise.error('Called `Path.intersectsX(y)` but `y` is not a number');
  return this.intersectsAxis(y, 'y');
};
/** Finds intersections between this path and a X or Y value */


Path.prototype.intersectsAxis = function (val = false, mode) {
  let intersections = [];
  let lineStart = mode === 'x' ? new Point(val, -100000) : new Point(-10000, val);
  let lineEnd = mode === 'x' ? new Point(val, 100000) : new Point(100000, val);

  for (let path of this.divide()) {
    if (path.ops[1].type === 'line') {
      addIntersectionsToArray(linesIntersect(path.ops[0].to, path.ops[1].to, lineStart, lineEnd), intersections);
    } else if (path.ops[1].type === 'curve') {
      addIntersectionsToArray(lineIntersectsCurve(lineStart, lineEnd, path.ops[0].to, path.ops[1].cp1, path.ops[1].cp2, path.ops[1].to), intersections);
    }
  }

  return intersections;
};
/** Finds intersections between this path and another path */


Path.prototype.intersects = function (path) {
  if (this === path) this.raise.error('You called Path.intersects(path)` but `path` and `this` are the same object');
  let intersections = [];

  for (let pathA of this.divide()) {
    for (let pathB of path.divide()) {
      if (pathA.ops[1].type === 'line') {
        if (pathB.ops[1].type === 'line') {
          addIntersectionsToArray(linesIntersect(pathA.ops[0].to, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].to), intersections);
        } else if (pathB.ops[1].type === 'curve') {
          addIntersectionsToArray(lineIntersectsCurve(pathA.ops[0].to, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].cp1, pathB.ops[1].cp2, pathB.ops[1].to), intersections);
        }
      } else if (pathA.ops[1].type === 'curve') {
        if (pathB.ops[1].type === 'line') {
          addIntersectionsToArray(lineIntersectsCurve(pathB.ops[0].to, pathB.ops[1].to, pathA.ops[0].to, pathA.ops[1].cp1, pathA.ops[1].cp2, pathA.ops[1].to), intersections);
        } else if (pathB.ops[1].type === 'curve') {
          addIntersectionsToArray(curvesIntersect(pathA.ops[0].to, pathA.ops[1].cp1, pathA.ops[1].cp2, pathA.ops[1].to, pathB.ops[0].to, pathB.ops[1].cp1, pathB.ops[1].cp2, pathB.ops[1].to), intersections);
        }
      }
    }
  }

  return intersections;
};

function addIntersectionsToArray(candidates, intersections) {
  if (!candidates) return;

  if (typeof candidates === 'object') {
    if (typeof candidates.x === 'number') intersections.push(candidates);else {
      for (let candidate of candidates) intersections.push(candidate);
    }
  }
}
/** Splits path on point, and retuns both halves */


Path.prototype.split = function (point) {
  if (point instanceof Point !== true) this.raise.error('Called `Path.split(point)` but `point` is not a `Point` object');
  let divided = this.divide();
  let firstHalf = false;
  let secondHalf = false;

  for (let pi = 0; pi < divided.length; pi++) {
    let path = divided[pi];

    if (path.ops[1].type === 'line') {
      if (pointOnLine(path.ops[0].to, path.ops[1].to, point)) {
        firstHalf = divided.slice(0, pi);
        firstHalf.push(new Path(this.debug).withRaise(this.raise).move(path.ops[0].to).line(point));
        pi++;
        secondHalf = divided.slice(pi);
        secondHalf.unshift(new Path(this.debug).withRaise(this.raise).move(point).line(path.ops[1].to));
      }
    } else if (path.ops[1].type === 'curve') {
      let t = pointOnCurve(path.ops[0].to, path.ops[1].cp1, path.ops[1].cp2, path.ops[1].to, point);

      if (t !== false) {
        let curve = new Bezier({
          x: path.ops[0].to.x,
          y: path.ops[0].to.y
        }, {
          x: path.ops[1].cp1.x,
          y: path.ops[1].cp1.y
        }, {
          x: path.ops[1].cp2.x,
          y: path.ops[1].cp2.y
        }, {
          x: path.ops[1].to.x,
          y: path.ops[1].to.y
        });
        let split = curve.split(t);
        firstHalf = divided.slice(0, pi);
        firstHalf.push(new Path(this.debug).withRaise(this.raise).move(new Point(split.left.points[0].x, split.left.points[0].y)).curve(new Point(split.left.points[1].x, split.left.points[1].y), new Point(split.left.points[2].x, split.left.points[2].y), new Point(split.left.points[3].x, split.left.points[3].y)));
        pi++;
        secondHalf = divided.slice(pi);
        secondHalf.unshift(new Path(this.debug).withRaise(this.raise).move(new Point(split.right.points[0].x, split.right.points[0].y)).curve(new Point(split.right.points[1].x, split.right.points[1].y), new Point(split.right.points[2].x, split.right.points[2].y), new Point(split.right.points[3].x, split.right.points[3].y)));
      }
    }
  }

  if (firstHalf) firstHalf = joinPaths(firstHalf, false, this.raise);
  if (secondHalf) secondHalf = joinPaths(secondHalf, false, this.raise);
  return [firstHalf, secondHalf];
};
/** Removes self-intersections (overlap) from the path */


Path.prototype.trim = function () {
  let chunks = this.divide();

  for (let i = 0; i < chunks.length; i++) {
    let firstCandidate = parseInt(i) + 2;
    let lastCandidate = parseInt(chunks.length) - 1;

    for (let j = firstCandidate; j < lastCandidate; j++) {
      let intersections = chunks[i].intersects(chunks[j]);

      if (intersections.length > 0) {
        let intersection = intersections.pop();
        let trimmedStart = chunks.slice(0, i);
        let trimmedEnd = chunks.slice(parseInt(j) + 1);
        let glue = new Path(this.debug).withRaise(this.raise);
        let first = true;

        for (let k of [i, j]) {
          let ops = chunks[k].ops;

          if (ops[1].type === 'line') {
            glue.line(intersection);
          } else if (ops[1].type === 'curve') {
            // handle curve
            let curve = new Bezier({
              x: ops[0].to.x,
              y: ops[0].to.y
            }, {
              x: ops[1].cp1.x,
              y: ops[1].cp1.y
            }, {
              x: ops[1].cp2.x,
              y: ops[1].cp2.y
            }, {
              x: ops[1].to.x,
              y: ops[1].to.y
            });
            let t = pointOnCurve(ops[0].to, ops[1].cp1, ops[1].cp2, ops[1].to, intersection);
            let split = curve.split(t);
            let side;
            if (first) side = split.left;else side = split.right;
            glue.curve(new Point(side.points[1].x, side.points[1].y), new Point(side.points[2].x, side.points[2].y), new Point(side.points[3].x, side.points[3].y));
          }

          first = false;
        }

        let joint;
        if (trimmedStart.length > 0) joint = joinPaths(trimmedStart, false, this.raise).join(glue);else joint = glue;
        if (trimmedEnd.length > 0) joint = joint.join(joinPaths(trimmedEnd, false, this.raise));
        return joint.trim();
      }
    }
  }

  return this;
};
/** Applies a path translate transform */


Path.prototype.translate = function (x, y) {
  if (this.debug) {
    if (typeof x !== 'number') this.raise.warning('Called `Path.translate(x, y)` but `x` is not a number');
    if (typeof y !== 'number') this.raise.warning('Called `Path.translate(x, y)` but `y` is not a number');
  }

  let clone = this.clone();

  for (let op of clone.ops) {
    if (op.type !== 'close') {
      op.to = op.to.translate(x, y);
    }

    if (op.type === 'curve') {
      op.cp1 = op.cp1.translate(x, y);
      op.cp2 = op.cp2.translate(x, y);
    }
  }

  return clone;
};

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/** Checks for a valid coordinate value **/

function isCoord(value) {
  return value === value // NaN does not equal itself
  ? typeof value === 'number' : false;
}
/** Returns internal hook name for a macro */

function macroName(name) {
  return `_macro_${name}`;
}
/** Find intersection of two (endless) lines */

function beamsIntersect(a1, a2, b1, b2) {
  let slopeA = a1.slope(a2);
  let slopeB = b1.slope(b2);
  if (slopeA === slopeB) return false; // Parallel lines

  if (a1.x === a2.x) return new Point(a1.x, slopeB * a1.x + (b1.y - slopeB * b1.x)); // Vertical line A
  else if (b1.x === b2.x) return new Point(b1.x, slopeA * b1.x + (a1.y - slopeA * a1.x)); // Vertical line B
    else {
        // Swap points if line A or B goes from right to left
        if (a1.x > a2.x) a1 = a2.copy();
        if (b1.x > b2.x) b1 = b2.copy(); // Find y intercept

        let iA = a1.y - slopeA * a1.x;
        let iB = b1.y - slopeB * b1.x; // Find intersection

        let x = (iB - iA) / (slopeA - slopeB);
        let y = slopeA * x + iA;
        return new Point(x, y);
      }
}
/** Find intersection of two line segments */

function linesIntersect(a1, a2, b1, b2) {
  let p = beamsIntersect(a1, a2, b1, b2);
  if (!p) return false;
  let lenA = a1.dist(a2);
  let lenB = b1.dist(b2);
  let lenC = a1.dist(p) + p.dist(a2);
  let lenD = b1.dist(p) + p.dist(b2);
  if (Math.round(lenA) == Math.round(lenC) && Math.round(lenB) == Math.round(lenD)) return p;else return false;
}
/** Finds out whether a point lies on an endless line */

function pointOnBeam(from, to, check, precision = 1e6) {
  if (from.sitsOn(check)) return true;
  if (to.sitsOn(check)) return true;
  let cross = check.dx(from) * to.dy(from) - check.dy(from) * to.dx(from);
  if (Math.abs(Math.round(cross * precision) / precision) === 0) return true;else return false;
}
/** Finds out whether a point lies on a line segment */

function pointOnLine(from, to, check, precision = 1e6) {
  if (!pointOnBeam(from, to, check, precision)) return false;
  let lenA = from.dist(to);
  let lenB = from.dist(check) + check.dist(to);
  if (Math.round(lenA) == Math.round(lenB)) return true;else return false;
}
/** Finds out whether a point lies on a curve */

function pointOnCurve(start, cp1, cp2, end, check) {
  if (start.sitsOn(check)) return true;
  if (end.sitsOn(check)) return true;
  let curve = new Bezier({
    x: start.x,
    y: start.y
  }, {
    x: cp1.x,
    y: cp1.y
  }, {
    x: cp2.x,
    y: cp2.y
  }, {
    x: end.x,
    y: end.y
  });
  let intersections = curve.intersects({
    p1: {
      x: check.x - 1,
      y: check.y
    },
    p2: {
      x: check.x + 1,
      y: check.y
    }
  });

  if (intersections.length === 0) {
    // Handle edge case of a curve that's a perfect horizontal line
    intersections = curve.intersects({
      p1: {
        x: check.x,
        y: check.y - 1
      },
      p2: {
        x: check.x,
        y: check.y + 1
      }
    });
  }

  if (intersections.length > 0) return intersections.shift();else return false;
}
/** Splits a curve on a point */

function splitCurve(start, cp1, cp2, end, split) {
  let [c1, c2] = new Path().move(start).curve(cp1, cp2, end).split(split);
  return [{
    start: c1.ops[0].to,
    cp1: c1.ops[1].cp1,
    cp2: c1.ops[1].cp2,
    end: c1.ops[1].to
  }, {
    start: c2.ops[0].to,
    cp1: c2.ops[1].cp1,
    cp2: c2.ops[1].cp2,
    end: c2.ops[1].to
  }];
}
/** Find where an (endless) line intersects with a certain X-value */

function beamIntersectsX(from, to, x) {
  if (from.x === to.x) return false; // Vertical line

  let top = new Point(x, -10);
  let bottom = new Point(x, 10);
  return beamsIntersect(from, to, top, bottom);
}
/** Find where an (endless) line intersects with a certain Y-value */

function beamIntersectsY(from, to, y) {
  if (from.y === to.y) return false; // Horizontal line

  let left = new Point(-10, y);
  let right = new Point(10, y);
  return beamsIntersect(from, to, left, right);
}
/** Convert value in mm to cm or imperial units */

function units(value, to = 'metric') {
  if (to === 'imperial') return round(value / 25.4) + '&quot;';else return round(value / 10) + 'cm';
}
/** Find where a curve intersects with line */

function lineIntersectsCurve(start, end, from, cp1, cp2, to) {
  let intersections = [];
  let bz = new Bezier({
    x: from.x,
    y: from.y
  }, {
    x: cp1.x,
    y: cp1.y
  }, {
    x: cp2.x,
    y: cp2.y
  }, {
    x: to.x,
    y: to.y
  });
  let line = {
    p1: {
      x: start.x,
      y: start.y
    },
    p2: {
      x: end.x,
      y: end.y
    }
  };

  for (let t of bz.intersects(line)) {
    let isect = bz.get(t);
    intersections.push(new Point(isect.x, isect.y));
  }

  if (intersections.length === 0) return false;else if (intersections.length === 1) return intersections[0];else return intersections;
}
/** Find where a curve intersects with a given X-value */

function curveIntersectsX(from, cp1, cp2, to, x) {
  let start = new Point(x, -10000);
  let end = new Point(x, 10000);
  return lineIntersectsCurve(start, end, from, cp1, cp2, to);
}
/** Find where a curve intersects with a given Y-value */

function curveIntersectsY(from, cp1, cp2, to, y) {
  let start = new Point(-10000, y);
  let end = new Point(10000, y);
  return lineIntersectsCurve(start, end, from, cp1, cp2, to);
}
/** Find where a curve intersects with another curve */

function curvesIntersect(fromA, cp1A, cp2A, toA, fromB, cp1B, cp2B, toB) {
  let precision = 0.005; // See https://github.com/Pomax/bezierjs/issues/99

  let intersections = [];
  let curveA = new Bezier({
    x: fromA.x,
    y: fromA.y
  }, {
    x: cp1A.x,
    y: cp1A.y
  }, {
    x: cp2A.x,
    y: cp2A.y
  }, {
    x: toA.x,
    y: toA.y
  });
  let curveB = new Bezier({
    x: fromB.x,
    y: fromB.y
  }, {
    x: cp1B.x,
    y: cp1B.y
  }, {
    x: cp2B.x,
    y: cp2B.y
  }, {
    x: toB.x,
    y: toB.y
  });

  for (let tvalues of curveA.intersects(curveB, precision)) {
    let intersection = curveA.get(tvalues.substr(0, tvalues.indexOf('/')));
    intersections.push(new Point(intersection.x, intersection.y));
  }

  if (intersections.length === 0) return false;else if (intersections.length === 1) return intersections.shift();else {
    let unique = [];

    for (let i of intersections) {
      let dupe = false;

      for (let u of unique) {
        if (i.sitsRoughlyOn(u)) dupe = true;
      }

      if (!dupe) unique.push(i);
    }

    return unique;
  }
}
/** Find the intersections between two circles */

function circlesIntersect(c1, r1, c2, r2, sort = 'x') {
  let dx = c1.dx(c2);
  let dy = c1.dy(c2);
  let dist = c1.dist(c2); // Check for edge cases

  if (dist > parseFloat(r1) + parseFloat(r2)) return false; // Circles do not intersect

  if (dist < parseFloat(r2) - parseFloat(r1)) return false; // One circle is contained in the other

  if (dist === 0 && r1 === r2) return false; // Two circles are identical

  let chorddistance = (Math.pow(r1, 2) - Math.pow(r2, 2) + Math.pow(dist, 2)) / (2 * dist);
  let halfchordlength = Math.sqrt(Math.pow(r1, 2) - Math.pow(chorddistance, 2));
  let chordmidpointx = c1.x + chorddistance * dx / dist;
  let chordmidpointy = c1.y + chorddistance * dy / dist;
  let i1 = new Point(chordmidpointx + halfchordlength * dy / dist, chordmidpointy - halfchordlength * dx / dist);
  let i2 = new Point(chordmidpointx - halfchordlength * dy / dist, chordmidpointy + halfchordlength * dx / dist);
  if (sort === 'x' && i1.x <= i2.x || sort === 'y' && i1.y <= i2.y) return [i1, i2];else return [i2, i1];
}
/** Find the intersections between a beam and a circle */

function beamIntersectsCircle(c, r, p1, p2, sort = 'x') {
  let dx = p2.x - p1.x;
  let dy = p2.y - p1.y;
  let A = Math.pow(dx, 2) + Math.pow(dy, 2);
  let B = 2 * (dx * (p1.x - c.x) + dy * (p1.y - c.y));
  let C = Math.pow(p1.x - c.x, 2) + Math.pow(p1.y - c.y, 2) - Math.pow(r, 2);
  let det = Math.pow(B, 2) - 4 * A * C;
  if (A <= 0.0000001 || det < 0) return false; // No real solutions
  else if (det === 0) {
      // One solution
      let t = -1 * B / (2 * A);
      let i1 = new Point(p1.x + t * dx, p1.y + t * dy);
      return [i1];
    } else {
      // Two solutions
      let t = (-1 * B + Math.sqrt(det)) / (2 * A);
      let i1 = new Point(p1.x + t * dx, p1.y + t * dy);
      t = (-1 * B - Math.sqrt(det)) / (2 * A);
      let i2 = new Point(p1.x + t * dx, p1.y + t * dy);
      if (sort === 'x' && i1.x <= i2.x || sort === 'y' && i1.y <= i2.y) return [i1, i2];else return [i2, i1];
    }
}
/** Find the intersections between a line and a circle */

function lineIntersectsCircle(c, r, p1, p2, sort = 'x') {
  let intersections = beamIntersectsCircle(c, r, p1, p2, sort);
  if (intersections === false) return false;else {
    if (intersections.length === 1) {
      if (pointOnLine(p1, p2, intersections[0])) return intersections;else return false;
    } else {
      let i1 = intersections[0];
      let i2 = intersections[1];
      if (!pointOnLine(p1, p2, i1, 5) && !pointOnLine(p1, p2, i2, 5)) return false;else if (pointOnLine(p1, p2, i1, 5) && pointOnLine(p1, p2, i2, 5)) {
        if (sort === 'x' && i1.x <= i2.x || sort === 'y' && i1.y <= i2.y) return [i1, i2];else return [i2, i1];
      } else if (pointOnLine(p1, p2, i1, 5)) return [i1];else if (pointOnLine(p1, p2, i2, 5)) return [i2];
    }
  }
}
function curveEdge(curve, edge, steps = 500) {
  let x = Infinity;
  let y = Infinity;
  let p;
  if (edge === 'bottom') y = -Infinity;
  if (edge === 'right') x = -Infinity;

  for (let i = 0; i < steps; i++) {
    p = curve.get(i / steps);

    if (edge === 'top' && p.y < y || edge === 'bottom' && p.y > y || edge === 'right' && p.x > x || edge === 'left' && p.x < x) {
      x = p.x;
      y = p.y;
    }
  }

  return new Point(x, y);
}
/**
 * Calculates scale factor based on stretch factor
 *
 * The way people measure stretch intuitively is
 * different from the way we handle stretch in code.
 * When people say '25% stretch' they mean that
 * 10cm fabric should get stretched to 12.5cm fabric.
 * In our code, that means we need to scale things by 80%.
 *
 * This method does that calculation.
 */

function stretchToScale(stretch) {
  return 1 / (1 + parseFloat(stretch));
}
function round(value) {
  return Math.round(value * 1e2) / 1e2;
}
function sampleStyle(run, runs, styles = false) {
  return styles && Array.isArray(styles) && styles.length > 0 ? styles[run % styles.length] : `stroke: hsl(${(run - 1) * (330 / runs)}, 100%, 35%);`;
}
function deg2rad(degrees) {
  return degrees * (Math.PI / 180);
}
function rad2deg(radians) {
  return radians / Math.PI * 180;
} // Export bezier-js so plugins can use it

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  capitalize: capitalize,
  isCoord: isCoord,
  macroName: macroName,
  beamsIntersect: beamsIntersect,
  linesIntersect: linesIntersect,
  pointOnBeam: pointOnBeam,
  pointOnLine: pointOnLine,
  pointOnCurve: pointOnCurve,
  splitCurve: splitCurve,
  beamIntersectsX: beamIntersectsX,
  beamIntersectsY: beamIntersectsY,
  units: units,
  lineIntersectsCurve: lineIntersectsCurve,
  curveIntersectsX: curveIntersectsX,
  curveIntersectsY: curveIntersectsY,
  curvesIntersect: curvesIntersect,
  circlesIntersect: circlesIntersect,
  beamIntersectsCircle: beamIntersectsCircle,
  lineIntersectsCircle: lineIntersectsCircle,
  curveEdge: curveEdge,
  stretchToScale: stretchToScale,
  round: round,
  sampleStyle: sampleStyle,
  deg2rad: deg2rad,
  rad2deg: rad2deg,
  Bezier: Bezier
});

function Snippet(def, anchor, debug = false) {
  this.def = def;
  this.anchor = anchor;
  this.attributes = new Attributes();
  Object.defineProperty(this, 'debug', {
    value: debug,
    configurable: true
  });
  return this;
}
/** Adds the raise method for a snippet not created through the proxy **/


Snippet.prototype.withRaise = function (raise = false) {
  if (raise) Object.defineProperty(this, 'raise', {
    value: raise
  });
  return this;
};
/** Adds an attribute. This is here to make this call chainable in assignment */


Snippet.prototype.attr = function (name, value, overwrite = false) {
  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);
  return this;
};
/** Returns a deep copy of this */


Snippet.prototype.clone = function () {
  let clone = new Snippet(this.def, this.anchor.clone(), this.debug).withRaise(this.raise);
  clone.attributes = this.attributes.clone();
  return clone;
};

function Hooks() {
  return {
    preDraft: [],
    postDraft: [],
    preSample: [],
    postSample: [],
    preRender: [],
    postRender: [],
    insertText: []
  };
}

function Part() {
  this.attributes = new Attributes();
  this.points = {};
  this.paths = {};
  this.snippets = {};
  this.freeId = 0;
  this.topLeft = false;
  this.bottomRight = false;
  this.width = false;
  this.height = false;
  this.render = true;
  this.utils = utils;
  this.Point = Point;
  this.Path = Path;
  this.Snippet = Snippet;
  this.hooks = new Hooks(); // Hooks container

  return this;
}

Part.prototype.macroClosure = function (args) {
  let self = this;

  let method = function (key, args) {
    let macro = macroName(key);
    if (typeof self[macro] === 'function') self[macro](args);
  };

  return method;
};

Part.prototype.runHooks = function (hookName, data = false) {
  if (data === false) data = this;
  let hooks = this.hooks[hookName];

  if (hooks && hooks.length > 0) {
    for (let hook of hooks) {
      hook.method(data, hook.data);
    }
  }
};
/** Returns an unused ID */


Part.prototype.getId = function (prefix = '') {
  this.freeId += 1;
  return prefix + this.freeId;
};
/** Returns a value formatted for units provided in settings */


Part.prototype.unitsClosure = function (value) {
  let self = this;

  let method = function (value) {
    if (self.context.settings.debug && typeof value !== 'number') self.context.raise.debug(`Calling \`units(value)\` but \`value\` is not a number (\`${typeof value}\`)`);
    return units(value, self.context.settings.units);
  };

  return method;
};
/** Calculates the part's bounding box and sets it */


Part.prototype.boundary = function () {
  if (this.topLeft) return this; // Cached

  let topLeft = new Point(Infinity, Infinity);
  let bottomRight = new Point(-Infinity, -Infinity);

  for (let key in this.paths) {
    try {
      let path = this.paths[key].boundary();

      if (path.render) {
        if (path.topLeft.x < topLeft.x) topLeft.x = path.topLeft.x;
        if (path.topLeft.y < topLeft.y) topLeft.y = path.topLeft.y;
        if (path.bottomRight.x > bottomRight.x) bottomRight.x = path.bottomRight.x;
        if (path.bottomRight.y > bottomRight.y) bottomRight.y = path.bottomRight.y;
      }
    } catch (err) {
      this.context.raise.error(`Could not calculate boundary of \`paths.${key}\``);
      this.context.raise.debug(`Since \`paths.${key}\` has no boundary, neither does \`parts.${this.name}\`. Ejecting part`);
      return false;
    }
  }

  for (let key in this.points) {
    let point = this.points[key];
    let radius = point.attributes.get('data-circle');

    if (radius) {
      radius = parseFloat(radius);
      if (point.x - radius < topLeft.x) topLeft.x = point.x - radius;
      if (point.y - radius < topLeft.y) topLeft.y = point.y - radius;
      if (point.x + radius > bottomRight.x) bottomRight.x = point.x + radius;
      if (point.y + radius > bottomRight.y) bottomRight.y = point.y + radius;
    }
  } // Fix infinity if part has no paths


  if (topLeft.x === Infinity) topLeft.x = 0;
  if (topLeft.y === Infinity) topLeft.y = 0;
  if (bottomRight.x === -Infinity) bottomRight.x = 0;
  if (bottomRight.y === -Infinity) bottomRight.y = 0; // Add margin

  let margin = this.context.settings.margin;
  if (this.context.settings.paperless && margin < 10) margin = 10;
  this.topLeft = new Point(topLeft.x - margin, topLeft.y - margin);
  this.bottomRight = new Point(bottomRight.x + margin, bottomRight.y + margin);
  this.width = this.bottomRight.x - this.topLeft.x;
  this.height = this.bottomRight.y - this.topLeft.y;
  return this;
};
/** Stacks part so that its top left corner is in (0,0) */


Part.prototype.stack = function () {
  if (this.topLeft !== false) return this;else this.boundary();
  if (this.topLeft.x == 0 && this.topLeft.y == 0) return this;else this.attr('transform', `translate(${this.topLeft.x * -1}, ${this.topLeft.y * -1})`);
  return this;
};
/** Adds an attribute. This is here to make this call chainable in assignment */


Part.prototype.attr = function (name, value, overwrite = false) {
  if (overwrite) this.attributes.set(name, value);else this.attributes.add(name, value);
  return this;
};
/** Copies point/path/snippet data from part orig into this */


Part.prototype.inject = function (orig) {
  const findBasePoint = p => {
    for (let i in orig.points) {
      if (orig.points[i] === p) return i;
    }

    return false;
  };

  for (let i in orig.points) this.points[i] = orig.points[i].clone();

  for (let i in orig.paths) {
    this.paths[i] = orig.paths[i].clone(); // Keep link between points and path ops where possible

    for (let j in orig.paths[i].ops) {
      let op = orig.paths[i].ops[j];

      if (op.type !== 'close') {
        let toPoint = findBasePoint(op.to);
        if (toPoint) this.paths[i].ops[j].to = this.points[toPoint];
      }

      if (op.type === 'curve') {
        let cp1Point = findBasePoint(op.cp1);
        if (cp1Point) this.paths[i].ops[j].cp1 = this.points[cp1Point];
        let cp2Point = findBasePoint(op.cp2);
        if (cp2Point) this.paths[i].ops[j].cp2 = this.points[cp2Point];
      }
    }
  }

  for (let i in orig.snippets) {
    this.snippets[i] = orig.snippets[i].clone();
  }

  return this;
};

Part.prototype.units = function (input) {
  return units(input, this.context.settings.units);
};
/** Returns an object with shorthand access for pattern design */


Part.prototype.shorthand = function () {
  let complete = this.context.settings.complete ? true : false;
  let paperless = this.context.settings.paperless === true ? true : false;
  let sa = this.context.settings.complete ? this.context.settings.sa || 0 : 0;
  const shorthand = {
    sa,
    store: this.context.store,
    macro: this.macroClosure(),
    units: this.unitsClosure(),
    utils: utils,
    complete,
    paperless,
    events: this.context.events,
    raise: this.context.raise
  };

  if (this.context.settings.debug) {
    // We'll need this
    let self = this; // Wrap the Point constructor so objects can raise events

    shorthand.Point = function (x, y) {
      Point.apply(this, [x, y, true]);
      Object.defineProperty(this, 'raise', {
        value: self.context.raise
      });
    };

    shorthand.Point.prototype = Object.create(Point.prototype); // Wrap the Path constructor so objects can raise events

    shorthand.Path = function () {
      Path.apply(this, [true]);
      Object.defineProperty(this, 'raise', {
        value: self.context.raise
      });
    };

    shorthand.Path.prototype = Object.create(Path.prototype); // Wrap the Snippet constructor so objects can raise events

    shorthand.Snippet = function (def, anchor) {
      Snippet.apply(this, [def, anchor, true]);
      Snippet.apply(this, arguments);
      Object.defineProperty(this, 'raise', {
        value: self.context.raise
      });
    };

    shorthand.Snippet.prototype = Object.create(Snippet.prototype); // Proxy the points object

    const pointsProxy = {
      get: function () {
        return Reflect.get(...arguments);
      },
      set: (points, name, value) => {
        // Constructor checks
        if (value instanceof Point !== true) self.context.raise.warning(`\`points.${name}\` was set with a value that is not a \`Point\` object`);
        if (value.x == null || !isCoord(value.x)) self.context.raise.warning(`\`points.${name}\` was set with a \`x\` parameter that is not a \`number\``);
        if (value.y == null || !isCoord(value.y)) self.context.raise.warning(`\`points.${name}\` was set with a \`y\` parameter that is not a \`number\``);

        try {
          value.name = name;
        } catch (err) {
          self.context.raise.warning(`Could not set \`name\` property on \`points.${name}\``);
        }

        return self.points[name] = value;
      }
    };
    shorthand.points = new Proxy(this.points || {}, pointsProxy); // Proxy the paths object

    const pathsProxy = {
      get: function () {
        return Reflect.get(...arguments);
      },
      set: (paths, name, value) => {
        // Constructor checks
        if (value instanceof Path !== true) self.context.raise.warning(`\`paths.${name}\` was set with a value that is not a \`Path\` object`);

        try {
          value.name = name;
        } catch (err) {
          self.context.raise.warning(`Could not set \`name\` property on \`paths.${name}\``);
        }

        return self.paths[name] = value;
      }
    };
    shorthand.paths = new Proxy(this.paths || {}, pathsProxy); // Proxy the snippets object

    const snippetsProxy = {
      get: function (target, prop, receiver) {
        return Reflect.get(...arguments);
      },
      set: (snippets, name, value) => {
        // Constructor checks
        if (value instanceof Snippet !== true) self.context.raise.warning(`\`snippets.${name}\` was set with a value that is not a \`Snippet\` object`);
        if (typeof value.def !== 'string') self.context.raise.warning(`\`snippets.${name}\` was set with a \`def\` parameter that is not a \`string\``);
        if (value.anchor instanceof Point !== true) self.context.raise.warning(`\`snippets.${name}\` was set with an \`anchor\` parameter that is not a \`Point\``);

        try {
          value.name = name;
        } catch (err) {
          self.context.raise.warning(`Could not set \`name\` property on \`snippets.${name}\``);
        }

        return self.snippets[name] = value;
      }
    };
    shorthand.snippets = new Proxy(this.snippets || {}, snippetsProxy); // Proxy the measurements object

    const measurementsProxy = {
      get: function (measurements, name) {
        if (typeof measurements[name] === 'undefined') self.context.raise.warning(`Tried to access \`measurements.${name}\` but it is \`undefined\``);
        return Reflect.get(...arguments);
      },
      set: (measurements, name, value) => self.context.settings.measurements[name] = value
    };
    shorthand.measurements = new Proxy(this.context.settings.measurements || {}, measurementsProxy); // Proxy the options object

    const optionsProxy = {
      get: function (options, name) {
        if (typeof options[name] === 'undefined') self.context.raise.warning(`Tried to access \`options.${name}\` but it is \`undefined\``);
        return Reflect.get(...arguments);
      },
      set: (options, name, value) => self.context.settings.options[name] = value
    };
    shorthand.options = new Proxy(this.context.settings.options || {}, optionsProxy);
  } else {
    shorthand.Point = Point;
    shorthand.Path = Path;
    shorthand.Snippet = Snippet;
    shorthand.points = this.points || {};
    shorthand.paths = this.paths || {};
    shorthand.snippets = this.snippets || {};
    shorthand.measurements = this.context.settings.measurements || {};
    shorthand.options = this.context.settings.options || {};
  }

  return shorthand;
};

var version = "2.17.0";

function Svg(pattern) {
  this.openGroups = [];
  this.layout = {};
  this.freeId = 0;
  this.body = '';
  this.style = '';
  this.script = '';
  this.defs = '';
  this.pattern = pattern; // Needed to expose pattern to hooks

  this.prefix = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>';
  this.attributes = new Attributes();
  this.attributes.add('xmlns', 'http://www.w3.org/2000/svg');
  this.attributes.add('xmlns:svg', 'http://www.w3.org/2000/svg');
  this.attributes.add('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  this.attributes.add('xml:lang', pattern.settings.locale);
  this.attributes.add('xmlns:freesewing', 'http://freesewing.org/namespaces/freesewing');
  this.attributes.add('freesewing', version);
}

Svg.prototype.runHooks = function (hookName, data = false) {
  if (data === false) data = this;
  let hooks = this.hooks[hookName];

  if (hooks.length > 0) {
    for (let hook of hooks) {
      hook.method(data, hook.data);
    }
  }
};
/** Runs insertText hooks */


Svg.prototype.insertText = function (text) {
  if (this.hooks.insertText.length > 0) {
    for (let hook of this.hooks.insertText) text = hook.method(this.pattern.settings.locale, text, hook.data);
  }

  return text;
};
/** Renders a draft object as SVG */


Svg.prototype.render = function (pattern) {
  this.idPrefix = pattern.settings.idPrefix;
  this.runHooks('preRender');

  if (!pattern.settings.embed) {
    this.attributes.add('width', round(pattern.width) + 'mm');
    this.attributes.add('height', round(pattern.height) + 'mm');
  }

  this.attributes.add('viewBox', `0 0 ${pattern.width} ${pattern.height}`);
  this.head = this.renderHead();
  this.tail = this.renderTail();
  this.svg = '';
  this.layout = {}; // Reset layout

  for (let partId in pattern.parts) {
    let part = pattern.parts[partId];

    if (part.render) {
      let partSvg = this.renderPart(part);
      this.layout[partId] = {
        svg: partSvg,
        transform: part.attributes.getAsArray('transform')
      };
      this.svg += this.openGroup(`${this.idPrefix}part-${partId}`, part.attributes);
      this.svg += partSvg;
      this.svg += this.closeGroup();
    }
  }

  this.svg = this.prefix + this.renderSvgTag() + this.head + this.svg + this.tail;
  this.runHooks('postRender');
  return this.svg;
};
/** Renders SVG head section */


Svg.prototype.renderHead = function () {
  let svg = this.renderStyle();
  svg += this.renderScript();
  svg += this.renderDefs();
  svg += this.openGroup(this.idPrefix + 'container');
  return svg;
};
/** Renders SVG closing section */


Svg.prototype.renderTail = function () {
  let svg = '';
  svg += this.closeGroup();
  svg += this.nl() + '</svg>';
  return svg;
};
/** Returns SVG code for the opening SVG tag */


Svg.prototype.renderSvgTag = function () {
  let svg = '<svg';
  this.indent();
  svg += this.nl() + this.attributes.render();
  this.outdent();
  svg += this.nl() + '>' + this.nl();
  return svg;
};
/** Returns SVG code for the style block */


Svg.prototype.renderStyle = function () {
  let svg = '<style type="text/css"> <![CDATA[ ';
  this.indent();
  svg += this.nl() + this.style;
  this.outdent();
  svg += this.nl() + ']]>' + this.nl() + '</style>' + this.nl();
  return svg;
};
/** Returns SVG code for the script block */


Svg.prototype.renderScript = function () {
  let svg = '<script type="text/javascript"> <![CDATA[';
  this.indent();
  svg += this.nl() + this.script;
  this.outdent();
  svg += this.nl() + ']]>' + this.nl() + '</script>' + this.nl();
  return svg;
};
/** Returns SVG code for the defs block */


Svg.prototype.renderDefs = function () {
  let svg = '<defs>';
  this.indent();
  svg += this.nl() + this.defs;
  this.outdent();
  svg += this.nl() + '</defs>' + this.nl();
  return svg;
};
/** Returns SVG code for a Part object */


Svg.prototype.renderPart = function (part) {
  let svg = '';

  for (let key in part.paths) {
    let path = part.paths[key];
    if (path.render) svg += this.renderPath(path);
  }

  for (let key in part.points) {
    if (part.points[key].attributes.get('data-text')) {
      svg += this.renderText(part.points[key]);
    }

    if (part.points[key].attributes.get('data-circle')) {
      svg += this.renderCircle(part.points[key]);
    }
  }

  for (let key in part.snippets) {
    let snippet = part.snippets[key];
    svg += this.renderSnippet(snippet, part);
  }

  return svg;
};
/** Returns SVG code for a Path object */


Svg.prototype.renderPath = function (path) {
  if (!path.attributes.get('id')) path.attributes.add('id', this.idPrefix + this.getId());
  path.attributes.set('d', path.asPathstring());
  return `${this.nl()}<path ${path.attributes.render()} />${this.renderPathText(path)}`;
};

Svg.prototype.renderPathText = function (path) {
  let text = path.attributes.get('data-text');
  if (!text) return '';else this.text = this.insertText(text);
  let attributes = path.attributes.renderIfPrefixIs('data-text-'); // Sadly aligning text along a patch can't be done in CSS only

  let offset = '';
  let align = path.attributes.get('data-text-class');
  if (align && align.indexOf('center') > -1) offset = ' startOffset="50%" ';else if (align && align.indexOf('right') > -1) offset = ' startOffset="100%" ';
  let svg = this.nl() + '<text>';
  this.indent();
  svg += `<textPath xlink:href="#${path.attributes.get('id')}" ${offset}><tspan ${attributes}>${this.escapeText(this.text)}</tspan></textPath>`;
  this.outdent();
  svg += this.nl() + '</text>';
  return svg;
};

Svg.prototype.renderText = function (point) {
  let text = point.attributes.getAsArray('data-text');

  if (text !== false) {
    let joint = '';

    for (let string of text) {
      this.text = this.insertText(string);
      joint += this.text + ' ';
    }

    this.text = this.insertText(joint);
  }

  point.attributes.set('data-text-x', round(point.x));
  point.attributes.set('data-text-y', round(point.y));
  let lineHeight = point.attributes.get('data-text-lineheight') || 12;
  point.attributes.remove('data-text-lineheight');
  let svg = `${this.nl()}<text ${point.attributes.renderIfPrefixIs('data-text-')}>`;
  this.indent(); // Multi-line text?

  if (this.text.indexOf('\n') !== -1) {
    let lines = this.text.split('\n');
    svg += `<tspan>${lines.shift()}</tspan>`;

    for (let line of lines) {
      svg += `<tspan x="${round(point.x)}" dy="${lineHeight}">${line}</tspan>`;
    }
  } else {
    svg += `<tspan>${this.escapeText(this.text)}</tspan>`;
  }

  this.outdent();
  svg += this.nl() + '</text>';
  return svg;
};

Svg.prototype.escapeText = function (text) {
  return text.replace('"', '&#8220;');
};

Svg.prototype.renderCircle = function (point) {
  return `<circle cx="${round(point.x)}" cy="${round(point.y)}" r="${point.attributes.get('data-circle')}" ${point.attributes.renderIfPrefixIs('data-circle-')}></circle>`;
};
/** Returns SVG code for a snippet */


Svg.prototype.renderSnippet = function (snippet, part) {
  let x = round(snippet.anchor.x);
  let y = round(snippet.anchor.y);
  let scale = snippet.attributes.get('data-scale');

  if (scale) {
    snippet.attributes.add('transform', `translate(${x}, ${y})`);
    snippet.attributes.add('transform', `scale(${scale})`);
    snippet.attributes.add('transform', `translate(${x * -1}, ${y * -1})`);
  }

  let rotate = snippet.attributes.get('data-rotate');

  if (rotate) {
    snippet.attributes.add('transform', `rotate(${rotate}, ${x}, ${y})`);
  }

  let svg = this.nl();
  svg += `<use x="${x}" y="${y}" `;
  svg += `xlink:href="#${snippet.def}" ${snippet.attributes.render()}>`;
  svg += '</use>';
  return svg;
};
/** Returns SVG code to open a group */


Svg.prototype.openGroup = function (id, attributes = false) {
  let svg = this.nl() + this.nl();
  svg += `<!-- Start of group #${id} -->`;
  svg += this.nl();
  svg += `<g id="${id}"`;
  if (attributes) svg += ` ${attributes.render()}`;
  svg += '>';
  this.indent();
  this.openGroups.push(id);
  return svg;
};
/** Returns SVG code to close a group */


Svg.prototype.closeGroup = function () {
  this.outdent();
  return `${this.nl()}</g>${this.nl()}<!-- end of group #${this.openGroups.pop()} -->`;
};
/** Returns a linebreak + identation */


Svg.prototype.nl = function () {
  return '\n' + this.tab();
};
/** Returns indentation */


Svg.prototype.tab = function () {
  let space = '';

  for (let i = 0; i < this.tabs; i++) {
    space += '  ';
  }

  return space;
};
/** Increases indentation by 1 */


Svg.prototype.indent = function () {
  this.tabs += 1;
};
/** Decreases indentation by 1 */


Svg.prototype.outdent = function () {
  this.tabs -= 1;
};
/** Returns an unused ID */


Svg.prototype.getId = function () {
  this.freeId += 1;
  return '' + this.freeId;
};

/******************************************************************************

This is a binary tree based bin packing algorithm that is more complex than
the simple Packer (packer.js). Instead of starting off with a fixed width and
height, it starts with the width and height of the first block passed and then
grows as necessary to accomodate each subsequent block. As it grows it attempts
to maintain a roughly square ratio by making 'smart' choices about whether to
grow right or down.

When growing, the algorithm can only grow to the right OR down. Therefore, if
the new block is BOTH wider and taller than the current target then it will be
rejected. This makes it very important to initialize with a sensible starting
width and height. If you are providing sorted input (largest first) then this
will not be an issue.

A potential way to solve this limitation would be to allow growth in BOTH
directions at once, but this requires maintaining a more complex tree
with 3 children (down, right and center) and that complexity can be avoided
by simply chosing a sensible starting block.

Best results occur when the input blocks are sorted by height, or even better
when sorted by max(width,height).

Inputs:
------

	blocks: array of any objects that have .w and .h attributes

Outputs:
-------

	marks each block that fits with a .fit attribute pointing to a
	node with .x and .y coordinates

Example:
-------

	var blocks = [
		{ w: 100, h: 100 },
		{ w: 100, h: 100 },
		{ w:  80, h:  80 },
		{ w:  80, h:  80 },
		etc
		etc
	];

	var packer = new GrowingPacker();
	packer.fit(blocks);

	for(var n = 0 ; n < blocks.length ; n++) {
		var block = blocks[n];
		if (block.fit) {
			Draw(block.fit.x, block.fit.y, block.w, block.h);
		}
	}


******************************************************************************/

var GrowingPacker$1 = function () {};

GrowingPacker$1.prototype = {
  fit: function (blocks) {
    var n,
        node,
        block,
        len = blocks.length,
        fit;
    var width = len > 0 ? blocks[0].width : 0;
    var height = len > 0 ? blocks[0].height : 0;
    this.root = {
      x: 0,
      y: 0,
      width: width,
      height: height
    };

    for (n = 0; n < len; n++) {
      block = blocks[n];

      if (node = this.findNode(this.root, block.width, block.height)) {
        fit = this.splitNode(node, block.width, block.height);
        block.x = fit.x;
        block.y = fit.y;
      } else {
        fit = this.growNode(block.width, block.height);
        block.x = fit.x;
        block.y = fit.y;
      }
    }
  },
  findNode: function (root, width, height) {
    if (root.used) return this.findNode(root.right, width, height) || this.findNode(root.down, width, height);else if (width <= root.width && height <= root.height) return root;else return null;
  },
  splitNode: function (node, width, height) {
    node.used = true;
    node.down = {
      x: node.x,
      y: node.y + height,
      width: node.width,
      height: node.height - height
    };
    node.right = {
      x: node.x + width,
      y: node.y,
      width: node.width - width,
      height: height
    };
    return node;
  },
  growNode: function (width, height) {
    var canGrowDown = width <= this.root.width;
    var canGrowRight = height <= this.root.height;
    var shouldGrowRight = canGrowRight && this.root.height >= this.root.width + width; // attempt to keep square-ish by growing right when height is much greater than width

    var shouldGrowDown = canGrowDown && this.root.width >= this.root.height + height; // attempt to keep square-ish by growing down  when width  is much greater than height

    if (shouldGrowRight) return this.growRight(width, height);else if (shouldGrowDown) return this.growDown(width, height);else if (canGrowRight) return this.growRight(width, height);else if (canGrowDown) return this.growDown(width, height);else return null; // need to ensure sensible root starting size to avoid this happening
  },
  growRight: function (width, height) {
    this.root = {
      used: true,
      x: 0,
      y: 0,
      width: this.root.width + width,
      height: this.root.height,
      down: this.root,
      right: {
        x: this.root.width,
        y: 0,
        width: width,
        height: this.root.height
      }
    };
    var node;
    if (node = this.findNode(this.root, width, height)) return this.splitNode(node, width, height);else return null;
  },
  growDown: function (width, height) {
    this.root = {
      used: true,
      x: 0,
      y: 0,
      width: this.root.width,
      height: this.root.height + height,
      down: {
        x: 0,
        y: this.root.height,
        width: this.root.width,
        height: height
      },
      right: this.root
    };
    var node;
    if (node = this.findNode(this.root, width, height)) return this.splitNode(node, width, height);else return null;
  }
};
var packer_growing = GrowingPacker$1;

var GrowingPacker = packer_growing;

var binPack = function (items, options) {
  options = options || {};
  var packer = new GrowingPacker();
  var inPlace = options.inPlace || false; // Clone the items.

  var newItems = items.map(function (item) {
    return inPlace ? item : {
      width: item.width,
      height: item.height,
      item: item
    };
  });
  newItems = newItems.sort(function (a, b) {
    // TODO: check that each actually HAS a width and a height.
    // Sort based on the size (area) of each block.
    return b.width * b.height - a.width * a.height;
  });
  packer.fit(newItems);
  var w = newItems.reduce(function (curr, item) {
    return Math.max(curr, item.x + item.width);
  }, 0);
  var h = newItems.reduce(function (curr, item) {
    return Math.max(curr, item.y + item.height);
  }, 0);
  var ret = {
    width: w,
    height: h
  };

  if (!inPlace) {
    ret.items = newItems;
  }

  return ret;
};

function Store(raise) {
  this.data = new Map();
  this.raise = raise;
}
/** Sets a value under index key */


Store.prototype.set = function (key, value) {
  this.data.set(key, value);
};
/** Sets a value under index key */


Store.prototype.setIfUnset = function (key, value) {
  if (!this.data.has(key)) this.data.set(key, value);
};
/** Gets a value under index key */


Store.prototype.get = function (key) {
  if (!this.data.has(key)) this.raise.warning(`Tried to access \`${key}\` in the \`store\` but it is not set`);
  return this.data.get(key);
};

function Pattern(config = {
  options: {}
}) {
  // Events store and raise methods
  this.events = {
    info: [],
    warning: [],
    error: [],
    debug: []
  };
  const events = this.events;
  this.raise = {
    info: function (data) {
      events.info.push(data);
    },
    warning: function (data) {
      events.warning.push(data);
    },
    error: function (data) {
      events.error.push(data);
    },
    debug: function (data) {
      events.debug.push(data);
    }
  };
  this.raise.debug(`New \`@freesewing/${config.name}:${config.version}\` pattern using \`@freesewing/core:${version}\``);
  this.config = config; // Pattern configuration

  this.width = 0; // Will be set after render

  this.height = 0; // Will be set after render

  this.is = ''; // Will be set when drafting/sampling

  this.debug = true; // Will be set when applying settings

  this.store = new Store(this.raise); // Store for sharing data across parts

  this.parts = {}; // Parts container

  this.hooks = new Hooks(); // Hooks container

  this.Point = Point; // Point constructor

  this.Path = Path; // Path constructor

  this.Snippet = Snippet; // Snippet constructor

  this.Attributes = Attributes; // Attributes constructor
  // Default settings

  this.settings = {
    complete: true,
    idPrefix: 'fs-',
    locale: 'en',
    units: 'metric',
    margin: 2,
    layout: true,
    debug: true,
    options: {}
  };
  if (typeof this.config.dependencies === 'undefined') this.config.dependencies = {};
  if (typeof this.config.inject === 'undefined') this.config.inject = {};
  if (typeof this.config.hide === 'undefined') this.config.hide = [];
  this.config.resolvedDependencies = this.resolveDependencies(this.config.dependencies);
  this.config.draftOrder = this.draftOrder(this.config.resolvedDependencies); // Convert options

  for (let i in config.options) {
    let option = config.options[i];

    if (typeof option === 'object') {
      if (typeof option.pct !== 'undefined') this.settings.options[i] = option.pct / 100;else if (typeof option.mm !== 'undefined') this.settings.options[i] = option.mm;else if (typeof option.deg !== 'undefined') this.settings.options[i] = option.deg;else if (typeof option.count !== 'undefined') this.settings.options[i] = option.count;else if (typeof option.bool !== 'undefined') this.settings.options[i] = option.bool;else if (typeof option.dflt !== 'undefined') this.settings.options[i] = option.dflt;else {
        let err = 'Unknown option type: ' + JSON.stringify(option);
        this.raise.error(err);
        throw new Error(err);
      }
    } else {
      this.settings.options[i] = option;
    }
  } // Macros


  this.macros = {}; // Context object to add to Part closure

  const context = {
    parts: this.parts,
    config: this.config,
    settings: this.settings,
    store: this.store,
    macros: this.macros,
    events: this.events,
    raise: this.raise
  }; // Part closure

  this.Part = function (name = false) {
    let part = new Part();
    part.context = context;

    for (let macro in context.macros) {
      part[macroName(macro)] = context.macros[macro];
    }

    if (name) part.name = name;
    return part;
  };
} // Merges settings object with this.settings

Pattern.prototype.apply = function (settings) {
  if (typeof settings !== 'object') {
    this.raise.warning('Pattern initialized without any settings');
    return this;
  }

  for (let key of Object.keys(settings)) {
    if (Array.isArray(settings[key])) {
      if (Array.isArray(this.settings[key])) {
        for (let entry of settings[key]) this.settings[key].push(entry);
      } else this.settings[key] = settings[key];
    } else if (typeof settings[key] === 'object') {
      this.settings[key] = { ...this.settings[key],
        ...settings[key]
      };
    } else this.settings[key] = settings[key];
  }

  if (!this.settings.debug) this.debug = false;
  return this;
};

Pattern.prototype.runHooks = function (hookName, data = false) {
  if (data === false) data = this;
  let hooks = this.hooks[hookName];

  if (hooks.length > 0) {
    if (this.debug) this.raise.debug(`Running \`${hookName}\` hooks`);

    for (let hook of hooks) {
      hook.method(data, hook.data);
    }
  }
};
/**
 *  The default draft method with pre- and postDraft hooks
 */


Pattern.prototype.draft = function () {
  if (this.is !== 'sample') {
    this.is = 'draft';
    if (this.debug) this.raise.debug(`Drafting pattern`);
  }

  this.runHooks('preDraft');

  for (let partName of this.config.draftOrder) {
    if (this.debug) this.raise.debug(`Creating part \`${partName}\``);
    this.parts[partName] = new this.Part(partName);

    if (typeof this.config.inject[partName] === 'string') {
      if (this.debug) this.raise.debug(`Injecting part \`${this.config.inject[partName]}\` into part \`${partName}\``);

      try {
        this.parts[partName].inject(this.parts[this.config.inject[partName]]);
      } catch (err) {
        this.raise.error([`Could not inject part \`${this.config.inject[partName]}\` into part \`${partName}\``, err]);
      }
    }

    if (this.needs(partName)) {
      let method = 'draft' + capitalize(partName);

      if (typeof this[method] !== 'function') {
        this.raise.error(`Method \`pattern.${method}\` is callable`);
        throw new Error('Method "' + method + '" on pattern object is not callable');
      }

      try {
        this.parts[partName] = this[method](this.parts[partName]);
      } catch (err) {
        this.raise.error([`Unable to draft part \`${partName}\``, err]);
      }

      if (typeof this.parts[partName] === 'undefined') {
        this.raise.error(`Result of \`pattern.${method}\` was \`undefined\`. Did you forget to return the \`Part\` object?`);
      }

      try {
        this.parts[partName].render = this.parts[partName].render === false ? false : this.wants(partName);
      } catch (err) {
        this.raise.error([`Unable to set \`render\` property on part \`${partName}\``, err]);
      }
    } else {
      if (this.debug) this.raise.debug(`Part \`${partName}\` is not needed. Skipping draft and setting render to \`false\``);
      this.parts[partName].render = false;
    }
  }

  this.runHooks('postDraft');
  return this;
};
/**
 * Handles pattern sampling
 */


Pattern.prototype.sample = function () {
  if (this.settings.sample.type === 'option') {
    return this.sampleOption(this.settings.sample.option);
  } else if (this.settings.sample.type === 'measurement') {
    return this.sampleMeasurement(this.settings.sample.measurement);
  } else if (this.settings.sample.type === 'models') {
    return this.sampleModels(this.settings.sample.models, this.settings.sample.focus || false);
  }
};

Pattern.prototype.sampleParts = function () {
  let parts = {};
  this.settings.complete = false;
  this.settings.paperless = false;
  this.draft();

  for (let i in this.parts) {
    parts[i] = new this.Part();
    parts[i].render = this.parts[i].render;
  }

  return parts;
};

Pattern.prototype.sampleRun = function (parts, anchors, run, runs, extraClass = false) {
  this.draft();

  for (let i in this.parts) {
    let dx = 0;
    let dy = 0;

    if (this.parts[i].points.anchor) {
      if (typeof anchors[i] === 'undefined') anchors[i] = this.parts[i].points.anchor;else {
        if (!anchors[i].sitsOn(this.parts[i].points.anchor)) {
          dx = this.parts[i].points.anchor.dx(anchors[i]);
          dy = this.parts[i].points.anchor.dy(anchors[i]);
        }
      }
    }

    for (let j in this.parts[i].paths) {
      parts[i].paths[j + '_' + run] = this.parts[i].paths[j].clone().attr('style', extraClass === 'sample-focus' ? this.settings.sample ? this.settings.sample.focusStyle || sampleStyle(run, runs) : sampleStyle(run, runs) : sampleStyle(run, runs, this.settings.sample ? this.settings.sample.styles || false : false)).attr('data-sample-run', run).attr('data-sample-runs', runs);
      if (this.parts[i].points.anchor) parts[i].paths[j + '_' + run] = parts[i].paths[j + '_' + run].translate(dx, dy);
      if (extraClass !== false) parts[i].paths[j + '_' + run].attributes.add('class', extraClass);
    }
  }
};
/**
 * Handles option sampling
 */


Pattern.prototype.sampleOption = function (optionName) {
  this.is = 'sample';
  if (this.debug) this.raise.debug(`Sampling option \`${optionName}\``);
  this.runHooks('preSample');
  let step, val;
  let factor = 1;
  let anchors = {};
  let parts = this.sampleParts();
  let option = this.config.options[optionName];

  if (typeof option.list === 'object') {
    return this.sampleListOption(optionName);
  }

  if (typeof option.min === 'undefined' || typeof option.max === 'undefined') {
    let min = option * 0.9;
    let max = option * 1.1;
    option = {
      min,
      max
    };
  }

  if (typeof option.pct !== 'undefined') factor = 100;
  val = option.min / factor;
  step = (option.max / factor - val) / 9;

  for (let run = 1; run < 11; run++) {
    this.settings.options[optionName] = val;
    this.sampleRun(parts, anchors, run, 10);
    val += step;
  }

  this.parts = parts;
  this.runHooks('postSample');
  return this;
};

Pattern.prototype.sampleListOption = function (optionName) {
  let parts = this.sampleParts();
  let option = this.config.options[optionName];
  let anchors = {};
  let run = 1;
  let runs = option.list.length;

  for (let val of option.list) {
    this.settings.options[optionName] = val;
    this.sampleRun(parts, anchors, run, runs);
    run++;
  }

  this.parts = parts;
  return this;
};
/**
 * Handles measurement sampling
 */


Pattern.prototype.sampleMeasurement = function (measurementName) {
  this.is = 'sample';
  if (this.debug) this.raise.debug(`Sampling measurement \`${measurementName}\``);
  this.runHooks('preSample');
  let anchors = {};
  let parts = this.sampleParts();
  let val = this.settings.measurements[measurementName];
  if (val === undefined) this.raise.error(`Cannot sample measurement \`${measurementName}\` because it's \`undefined\``);
  let step = val / 50;
  val = val * 0.9;

  for (let run = 1; run < 11; run++) {
    this.settings.measurements[measurementName] = val;
    this.sampleRun(parts, anchors, run, 10);
    val += step;
  }

  this.parts = parts;
  this.runHooks('postSample');
  return this;
};
/**
 * Handles models sampling
 */


Pattern.prototype.sampleModels = function (models, focus = false) {
  this.is = 'sample';
  if (this.debug) this.raise.debug(`Sampling models`);
  this.runHooks('preSample');
  let anchors = {};
  let parts = this.sampleParts(); // If there's a focus, do it first so it's at the bottom of the SVG

  if (focus) {
    this.settings.measurements = models[focus];
    this.sampleRun(parts, anchors, -1, -1, 'sample-focus');
    delete models[focus];
  }

  let run = -1;
  let runs = Object.keys(models).length;

  for (let l in models) {
    run++;
    this.settings.measurements = models[l];
    this.sampleRun(parts, anchors, run, runs);
  }

  this.parts = parts;
  this.runHooks('postSample');
  return this;
};

Pattern.prototype.render = function () {
  this.svg = new Svg(this);
  this.svg.hooks = this.hooks;
  return this.pack().svg.render(this);
};

Pattern.prototype.on = function (hook, method, data) {
  this.hooks[hook].push({
    method,
    data
  });
};

Pattern.prototype.use = function (plugin, data) {
  if (this.debug) this.raise.debug(`Loaded plugin \`${plugin.name}:${plugin.version}\``);
  if (plugin.hooks) this.loadPluginHooks(plugin, data);
  if (plugin.macros) this.loadPluginMacros(plugin);
  return this;
};

Pattern.prototype.useIf = function (plugin, settings) {
  if (plugin.condition(settings)) {
    if (this.debug) this.raise.debug(`Condition met: Loaded plugin \`${plugin.plugin.name}:${plugin.plugin.version}\``);
    this.loadPluginHooks(plugin.plugin, plugin.data);
  } else {
    if (this.debug) this.raise.debug(`Condition not met: Skipped loading plugin \`${plugin.plugin.name}:${plugin.plugin.version}\``);
  }

  return this;
};

Pattern.prototype.loadPluginHooks = function (plugin, data) {
  for (let hook of Object.keys(this.hooks)) {
    if (typeof plugin.hooks[hook] === 'function') {
      this.on(hook, plugin.hooks[hook], data);
    } else if (Array.isArray(plugin.hooks[hook])) {
      for (let method of plugin.hooks[hook]) {
        this.on(hook, method, data);
      }
    }
  }
};

Pattern.prototype.loadPluginMacros = function (plugin) {
  for (let macro in plugin.macros) {
    if (typeof plugin.macros[macro] === 'function') {
      this.macro(macro, plugin.macros[macro]);
    }
  }
};

Pattern.prototype.macro = function (key, method) {
  this.macros[key] = method;
};
/** Packs parts in a 2D space and sets pattern size */


Pattern.prototype.pack = function () {
  if (this.events.error.length > 0) {
    this.raise.warning(`One or more errors occured. Not packing pattern parts`);
    return this;
  }

  let bins = [];

  for (let key in this.parts) {
    let part = this.parts[key]; // Avoid multiple render calls to cause stacking of transforms

    part.attributes.remove('transform');

    if (part.render) {
      part.stack();
      let width = part.bottomRight.x - part.topLeft.x;
      let height = part.bottomRight.y - part.topLeft.y;
      if (this.settings.layout === true) bins.push({
        id: key,
        width,
        height
      });else {
        if (this.width < width) this.width = width;
        if (this.height < height) this.height = height;
      }
    }
  }

  if (this.settings.layout === true) {
    let size = binPack(bins, {
      inPlace: true
    });

    for (let bin of bins) {
      let part = this.parts[bin.id];
      if (bin.x !== 0 || bin.y !== 0) part.attr('transform', `translate(${bin.x}, ${bin.y})`);
    }

    this.width = size.width;
    this.height = size.height;
  } else if (typeof this.settings.layout === 'object') {
    this.width = this.settings.layout.width;
    this.height = this.settings.layout.height;

    for (let partId of Object.keys(this.settings.layout.parts)) {
      let transforms = this.settings.layout.parts[partId]; // Moving

      if (typeof transforms.move === 'object') {
        this.parts[partId].attributes.set('transform', 'translate(' + transforms.move.x + ', ' + transforms.move.y + ')');
      } // Mirrorring


      let center = this.parts[partId].topLeft.shiftFractionTowards(this.parts[partId].bottomRight, 0.5);
      let anchor = {
        x: 0,
        y: 0
      };

      if (transforms.flipX) {
        let dx = anchor.x - center.x;
        let transform = `translate(${center.x * -1}, ${center.y * -1})`;
        transform += ' scale(-1, 1)';
        transform += ` translate(${center.x * -1 + 2 * dx}, ${center.y})`;
        this.parts[partId].attributes.add('transform', transform);
      }

      if (transforms.flipY) {
        let dy = anchor.y - center.y;
        let transform = `translate(${center.x * -1}, ${center.y * -1})`;
        transform += ' scale(1, -1)';
        transform += ` translate(${center.x}, ${center.y * -1 + 2 * dy})`;
        this.parts[partId].attributes.add('transform', transform);
      }

      if (transforms.rotate) {
        let transform = `rotate(${transforms.rotate}, ${center.x - anchor.x}, ${center.y - anchor.y})`;
        this.parts[partId].attributes.add('transform', transform);
      }
    }
  }

  return this;
};
/** Determines the order to draft parts in, based on dependencies */


Pattern.prototype.draftOrder = function (graph = this.resolveDependencies()) {
  let sorted = [];
  let visited = {};
  Object.keys(graph).forEach(function visit(name, ancestors) {
    if (!Array.isArray(ancestors)) ancestors = [];
    ancestors.push(name);
    visited[name] = true;

    if (typeof graph[name] !== 'undefined') {
      graph[name].forEach(function (dep) {
        if (visited[dep]) return;
        visit(dep, ancestors.slice(0));
      });
    }

    if (sorted.indexOf(name) < 0) sorted.push(name);
  });
  return sorted;
};
/** Recursively solves part dependencies for a part */


Pattern.prototype.resolveDependency = function (seen, part, graph = this.config.dependencies, deps = []) {
  if (typeof seen[part] === 'undefined') seen[part] = true;
  if (typeof graph[part] === 'string') graph[part] = [graph[part]];

  if (Array.isArray(graph[part])) {
    if (graph[part].length === 0) return [];else {
      if (deps.indexOf(graph[part]) === -1) deps.push(...graph[part]);

      for (let apart of graph[part]) deps.concat(this.resolveDependency(seen, apart, graph, deps));
    }
  }

  return deps;
};
/** Resolves part dependencies into a flat array */


Pattern.prototype.resolveDependencies = function (graph = this.config.dependencies) {
  for (let i in this.config.inject) {
    let dependency = this.config.inject[i];
    if (typeof this.config.dependencies[i] === 'undefined') this.config.dependencies[i] = dependency;else if (this.config.dependencies[i] !== dependency) {
      if (typeof this.config.dependencies[i] === 'string') this.config.dependencies[i] = [this.config.dependencies[i], dependency];else if (Array.isArray(this.config.dependencies[i])) {
        if (this.config.dependencies[i].indexOf(dependency) === -1) this.config.dependencies[i].push(dependency);
      } else {
        this.raise.error('Part dependencies should be a string or an array of strings');
        throw new Error('Part dependencies should be a string or an array of strings');
      }
    } // Parts both in the parts and dependencies array trip up the dependency resolver

    if (Array.isArray(this.config.parts)) {
      let pos = this.config.parts.indexOf(this.config.inject[i]);
      if (pos !== -1) this.config.parts.splice(pos, 1);
    }
  } // Include parts outside the dependency graph


  if (Array.isArray(this.config.parts)) {
    for (let part of this.config.parts) {
      if (typeof this.config.dependencies[part] === 'undefined') this.config.dependencies[part] = [];
    }
  }

  let resolved = {};
  let seen = {};

  for (let part in graph) resolved[part] = this.resolveDependency(seen, part, graph);

  for (let part in seen) if (typeof resolved[part] === 'undefined') resolved[part] = [];

  return resolved;
};
/** Determines whether a part is needed
 * This depends on the 'only' setting and the
 * configured dependencies.
 */


Pattern.prototype.needs = function (partName) {
  if (typeof this.settings.only === 'undefined' || this.settings.only === false) return true;else if (typeof this.settings.only === 'string') {
    if (this.settings.only === partName) return true;

    if (Array.isArray(this.config.resolvedDependencies[this.settings.only])) {
      for (let dependency of this.config.resolvedDependencies[this.settings.only]) {
        if (dependency === partName) return true;
      }
    }
  } else if (Array.isArray(this.settings.only)) {
    for (let part of this.settings.only) {
      if (part === partName) return true;

      for (let dependency of this.config.resolvedDependencies[part]) {
        if (dependency === partName) return true;
      }
    }
  }
  return false;
};
/* Checks whether a part is hidden in the config */


Pattern.prototype.isHidden = function (partName) {
  if (Array.isArray(this.config.hide)) {
    if (this.config.hide.indexOf(partName) !== -1) return true;
  }

  return false;
};
/** Determines whether a part is wanted by the user
 * This depends on the 'only' setting
 */


Pattern.prototype.wants = function (partName) {
  if (typeof this.settings.only === 'undefined' || this.settings.only === false) {
    if (this.isHidden(partName)) return false;
  } else if (typeof this.settings.only === 'string') {
    if (this.settings.only === partName) return true;
    return false;
  } else if (Array.isArray(this.settings.only)) {
    for (let part of this.settings.only) {
      if (part === partName) return true;
    }

    return false;
  }

  return true;
};
/** Returns props required to render this pattern through
 *  an external renderer (eg. a React component)
 */


Pattern.prototype.getRenderProps = function () {
  // Run pre-render hook
  let svg = new Svg(this);
  svg.hooks = this.hooks;
  svg.runHooks('preRender');
  this.pack();
  let props = {
    svg
  };
  props.width = this.width;
  props.height = this.height;
  props.settings = this.settings;
  props.events = {
    debug: this.events.debug,
    info: this.events.info,
    warning: this.events.warning,
    error: this.events.error
  };
  props.parts = {};

  for (let p in this.parts) {
    if (this.parts[p].render) {
      props.parts[p] = {
        paths: this.parts[p].paths,
        points: this.parts[p].points,
        snippets: this.parts[p].snippets,
        attributes: this.parts[p].attributes,
        height: this.parts[p].height,
        width: this.parts[p].width,
        bottomRight: this.parts[p].bottomRight,
        topLeft: this.parts[p].topLeft
      };
    }
  }

  return props;
};

function Design(config, plugins = false, conditionalPlugins = false) {
  const pattern = function (settings) {
    Pattern.call(this, config); // Load plugins

    if (Array.isArray(plugins)) for (let plugin of plugins) this.use(plugin);else if (plugins) this.use(plugins); // Load conditional plugins

    if (Array.isArray(conditionalPlugins)) for (let plugin of conditionalPlugins) this.useIf(plugin, settings);else if (conditionalPlugins.plugin && conditionalPlugins.condition) this.useIf(conditionalPlugins, settings);
    this.apply(settings);
    return this;
  }; // Set up inheritance


  pattern.prototype = Object.create(Pattern.prototype);
  pattern.prototype.constructor = pattern; // Make config available without need to instantiate pattern

  pattern.config = config;
  return pattern;
}

var index = {
  version,
  Design,
  Pattern,
  Point,
  Path,
  Snippet,
  utils,
  patterns: {},
  plugins: {}
};

export default index;
//# sourceMappingURL=index.mjs.map
